/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/shaders/frag.glsl":
/*!*******************************!*\
  !*** ./src/shaders/frag.glsl ***!
  \*******************************/
/***/ ((module) => {

module.exports = "#version 300 es\r\n\r\nprecision mediump float;\r\n\r\n/*\r\ncontributors: [Stefan Gustavson, Ian McEwan]\r\ndescription: modulus of 289\r\nuse: <float|vec2|vec3|vec4> mod289(<float|vec2|vec3|vec4> x)\r\n*/\r\n\r\n#ifndef FNC_MOD289\r\n#define FNC_MOD289\r\n\r\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\n\r\n#endif\r\n\r\n/*\r\ncontributors: [Stefan Gustavson, Ian McEwan]\r\ndescription: modulus of 289\r\nuse: <float|vec2|vec3|vec4> mod289(<float|vec2|vec3|vec4> x)\r\n*/\r\n\r\n#ifndef FNC_MOD289\r\n#define FNC_MOD289\r\n\r\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\n\r\n#endif\r\n\r\n\r\n/*\r\ncontributors: [Stefan Gustavson, Ian McEwan]\r\ndescription: permute\r\nuse: <float|vec2|vec3|vec4> permute(<float|vec2|vec3|vec4> x)\r\nexamples:\r\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/math_functions.frag\r\n*/\r\n\r\n#ifndef FNC_PERMUTE\r\n#define FNC_PERMUTE\r\n\r\nfloat permute(const in float v) { return mod289(((v * 34.0) + 1.0) * v); }\r\nvec2 permute(const in vec2 v) { return mod289(((v * 34.0) + 1.0) * v); }\r\nvec3 permute(const in vec3 v) { return mod289(((v * 34.0) + 1.0) * v); }\r\nvec4 permute(const in vec4 v) { return mod289(((v * 34.0) + 1.0) * v); }\r\n\r\n#endif\r\n\r\n/*\r\ncontributors: [Stefan Gustavson, Ian McEwan]\r\ndescription: Fast, accurate inverse square root. \r\nuse: <float|vec2|vec3|vec4> taylorInvSqrt(<float|vec2|vec3|vec4> x)\r\n*/\r\n\r\n#ifndef FNC_TAYLORINVSQRT\r\n#define FNC_TAYLORINVSQRT\r\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\r\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\r\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\r\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\r\n#endif\r\n/*\r\ncontributors: [Stefan Gustavson, Ian McEwan]\r\ndescription: grad4, used for snoise(vec4 v)\r\nuse: grad4(<float> j, <vec4> ip)\r\n*/\r\n\r\n#ifndef FNC_GRAD4\r\n#define FNC_GRAD4\r\nvec4 grad4(float j, vec4 ip) {\r\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\r\n    vec4 p,s;\r\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\r\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\r\n    s = vec4(lessThan(p, vec4(0.0)));\r\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\r\n    return p;\r\n}\r\n#endif\r\n\r\n\r\n/*\r\ncontributors: [Stefan Gustavson, Ian McEwan]\r\ndescription: Simplex Noise https://github.com/stegu/webgl-noise\r\nuse: snoise(<vec2|vec3|vec4> pos)\r\nlicense: |\r\n    Copyright 2021-2023 by Stefan Gustavson and Ian McEwan.\r\n    Published under the terms of the MIT license:\r\n    https://opensource.org/license/mit/\r\nexamples:\r\n    - /shaders/generative_snoise.frag\r\n*/\r\n\r\n#ifndef FNC_SNOISE\r\n#define FNC_SNOISE\r\nfloat snoise(in vec2 v) {\r\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\r\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\r\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\r\n                        0.024390243902439); // 1.0 / 41.0\r\n    // First corner\r\n    vec2 i  = floor(v + dot(v, C.yy) );\r\n    vec2 x0 = v -   i + dot(i, C.xx);\r\n\r\n    // Other corners\r\n    vec2 i1;\r\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\r\n    //i1.y = 1.0 - i1.x;\r\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\r\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\r\n    // x1 = x0 - i1 + 1.0 * C.xx ;\r\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\r\n    vec4 x12 = x0.xyxy + C.xxzz;\r\n    x12.xy -= i1;\r\n\r\n    // Permutations\r\n    i = mod289(i); // Avoid truncation effects in permutation\r\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\r\n    + i.x + vec3(0.0, i1.x, 1.0 ));\r\n\r\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\r\n    m = m*m ;\r\n    m = m*m ;\r\n\r\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\r\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\r\n\r\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\r\n    vec3 h = abs(x) - 0.5;\r\n    vec3 ox = floor(x + 0.5);\r\n    vec3 a0 = x - ox;\r\n\r\n    // Normalise gradients implicitly by scaling m\r\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\r\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\r\n\r\n    // Compute final noise value at P\r\n    vec3 g;\r\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\r\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n    return 130.0 * dot(m, g);\r\n}\r\n\r\n\r\nfloat snoise(in vec3 v) {\r\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n    // First corner\r\n    vec3 i  = floor(v + dot(v, C.yyy) );\r\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n    // Other corners\r\n    vec3 g = step(x0.yzx, x0.xyz);\r\n    vec3 l = 1.0 - g;\r\n    vec3 i1 = min( g.xyz, l.zxy );\r\n    vec3 i2 = max( g.xyz, l.zxy );\r\n\r\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\r\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\r\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\r\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\r\n    vec3 x1 = x0 - i1 + C.xxx;\r\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\r\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\r\n\r\n    // Permutations\r\n    i = mod289(i);\r\n    vec4 p = permute( permute( permute(\r\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\r\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\r\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\r\n    float n_ = 0.142857142857; // 1.0/7.0\r\n    vec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\r\n\r\n    vec4 x_ = floor(j * ns.z);\r\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n    vec4 x = x_ *ns.x + ns.yyyy;\r\n    vec4 y = y_ *ns.x + ns.yyyy;\r\n    vec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n    vec4 b0 = vec4( x.xy, y.xy );\r\n    vec4 b1 = vec4( x.zw, y.zw );\r\n\r\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\r\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\r\n    vec4 s0 = floor(b0)*2.0 + 1.0;\r\n    vec4 s1 = floor(b1)*2.0 + 1.0;\r\n    vec4 sh = -step(h, vec4(0.0));\r\n\r\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n    vec3 p0 = vec3(a0.xy,h.x);\r\n    vec3 p1 = vec3(a0.zw,h.y);\r\n    vec3 p2 = vec3(a1.xy,h.z);\r\n    vec3 p3 = vec3(a1.zw,h.w);\r\n\r\n    //Normalise gradients\r\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n    p0 *= norm.x;\r\n    p1 *= norm.y;\r\n    p2 *= norm.z;\r\n    p3 *= norm.w;\r\n\r\n    // Mix final noise value\r\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n    m = m * m;\r\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\r\n                                dot(p2,x2), dot(p3,x3) ) );\r\n}\r\n\r\nfloat snoise(in vec4 v) {\r\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\r\n                        0.276393202250021,  // 2 * G4\r\n                        0.414589803375032,  // 3 * G4\r\n                        -0.447213595499958); // -1 + 4 * G4\r\n\r\n    // First corner\r\n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\r\n    vec4 x0 = v -   i + dot(i, C.xxxx);\r\n\r\n    // Other corners\r\n\r\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\r\n    vec4 i0;\r\n    vec3 isX = step( x0.yzw, x0.xxx );\r\n    vec3 isYZ = step( x0.zww, x0.yyz );\r\n    //  i0.x = dot( isX, vec3( 1.0 ) );\r\n    i0.x = isX.x + isX.y + isX.z;\r\n    i0.yzw = 1.0 - isX;\r\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\r\n    i0.y += isYZ.x + isYZ.y;\r\n    i0.zw += 1.0 - isYZ.xy;\r\n    i0.z += isYZ.z;\r\n    i0.w += 1.0 - isYZ.z;\r\n\r\n    // i0 now contains the unique values 0,1,2,3 in each channel\r\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\r\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\r\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\r\n\r\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\r\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\r\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\r\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\r\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\r\n    vec4 x1 = x0 - i1 + C.xxxx;\r\n    vec4 x2 = x0 - i2 + C.yyyy;\r\n    vec4 x3 = x0 - i3 + C.zzzz;\r\n    vec4 x4 = x0 + C.wwww;\r\n\r\n    // Permutations\r\n    i = mod289(i);\r\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\r\n    vec4 j1 = permute( permute( permute( permute (\r\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\r\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\r\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\r\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\r\n\r\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\r\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\r\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\r\n\r\n    vec4 p0 = grad4(j0,   ip);\r\n    vec4 p1 = grad4(j1.x, ip);\r\n    vec4 p2 = grad4(j1.y, ip);\r\n    vec4 p3 = grad4(j1.z, ip);\r\n    vec4 p4 = grad4(j1.w, ip);\r\n\r\n    // Normalise gradients\r\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n    p0 *= norm.x;\r\n    p1 *= norm.y;\r\n    p2 *= norm.z;\r\n    p3 *= norm.w;\r\n    p4 *= taylorInvSqrt(dot(p4,p4));\r\n\r\n    // Mix contributions from the five corners\r\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\r\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\r\n    m0 = m0 * m0;\r\n    m1 = m1 * m1;\r\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\r\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\r\n}\r\n\r\nvec2 snoise2( vec2 x ){\r\n    float s  = snoise(vec2( x ));\r\n    float s1 = snoise(vec2( x.y - 19.1, x.x + 47.2 ));\r\n    return vec2( s , s1 );\r\n}\r\n\r\nvec3 snoise3( vec3 x ){\r\n    float s  = snoise(vec3( x ));\r\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n    return vec3( s , s1 , s2 );\r\n}\r\n\r\nvec3 snoise3( vec4 x ){\r\n    float s  = snoise(vec4( x ));\r\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\r\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\r\n    return vec3( s , s1 , s2 );\r\n}\r\n\r\n#endif\r\n\r\n\r\nuniform vec2 u_resolution;\r\nuniform float u_time;\r\n\r\nin vec2 fragPosition;\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  float n = snoise(vec3(fragPosition, u_time));\r\n  fragColor = vec4(n, n, n, 1.0);\r\n}\r\n"

/***/ }),

/***/ "./src/shaders/vert.glsl":
/*!*******************************!*\
  !*** ./src/shaders/vert.glsl ***!
  \*******************************/
/***/ ((module) => {

module.exports = "#version 300 es\r\n\r\nin vec2 position;\r\nout vec2 fragPosition;\r\n\r\nvoid main() {\r\n  fragPosition = position;\r\n  gl_Position = vec4(position, 0.0, 1.0);\r\n}\r\n"

/***/ }),

/***/ "./node_modules/twgl.js/dist/5.x/twgl-full.module.js":
/*!***********************************************************!*\
  !*** ./node_modules/twgl.js/dist/5.x/twgl-full.module.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addExtensionsToContext: () => (/* binding */ addExtensionsToContext),
/* harmony export */   attributes: () => (/* binding */ attributes),
/* harmony export */   bindFramebufferInfo: () => (/* binding */ bindFramebufferInfo),
/* harmony export */   bindTransformFeedbackInfo: () => (/* binding */ bindTransformFeedbackInfo),
/* harmony export */   bindUniformBlock: () => (/* binding */ bindUniformBlock),
/* harmony export */   canFilter: () => (/* binding */ canFilter),
/* harmony export */   canGenerateMipmap: () => (/* binding */ canGenerateMipmap),
/* harmony export */   createAttribsFromArrays: () => (/* binding */ createAttribsFromArrays),
/* harmony export */   createAttributeSetters: () => (/* binding */ createAttributeSetters),
/* harmony export */   createBufferFromArray: () => (/* binding */ createBufferFromArray),
/* harmony export */   createBufferFromTypedArray: () => (/* binding */ createBufferFromTypedArray),
/* harmony export */   createBufferInfoFromArrays: () => (/* binding */ createBufferInfoFromArrays),
/* harmony export */   createBuffersFromArrays: () => (/* binding */ createBuffersFromArrays),
/* harmony export */   createFramebufferInfo: () => (/* binding */ createFramebufferInfo),
/* harmony export */   createProgram: () => (/* binding */ createProgram),
/* harmony export */   createProgramAsync: () => (/* binding */ createProgramAsync),
/* harmony export */   createProgramFromScripts: () => (/* binding */ createProgramFromScripts),
/* harmony export */   createProgramFromSources: () => (/* binding */ createProgramFromSources),
/* harmony export */   createProgramInfo: () => (/* binding */ createProgramInfo),
/* harmony export */   createProgramInfoAsync: () => (/* binding */ createProgramInfoAsync),
/* harmony export */   createProgramInfoFromProgram: () => (/* binding */ createProgramInfoFromProgram),
/* harmony export */   createProgramInfos: () => (/* binding */ createProgramInfos),
/* harmony export */   createProgramInfosAsync: () => (/* binding */ createProgramInfosAsync),
/* harmony export */   createPrograms: () => (/* binding */ createPrograms),
/* harmony export */   createProgramsAsync: () => (/* binding */ createProgramsAsync),
/* harmony export */   createSampler: () => (/* binding */ createSampler),
/* harmony export */   createSamplers: () => (/* binding */ createSamplers),
/* harmony export */   createTexture: () => (/* binding */ createTexture),
/* harmony export */   createTextures: () => (/* binding */ createTextures),
/* harmony export */   createTransformFeedback: () => (/* binding */ createTransformFeedback),
/* harmony export */   createTransformFeedbackInfo: () => (/* binding */ createTransformFeedbackInfo),
/* harmony export */   createUniformBlockInfo: () => (/* binding */ createUniformBlockInfo),
/* harmony export */   createUniformBlockInfoFromProgram: () => (/* binding */ createUniformBlockInfoFromProgram),
/* harmony export */   createUniformBlockSpecFromProgram: () => (/* binding */ createUniformBlockSpecFromProgram),
/* harmony export */   createUniformSetters: () => (/* binding */ createUniformSetters),
/* harmony export */   createVAOAndSetAttributes: () => (/* binding */ createVAOAndSetAttributes),
/* harmony export */   createVAOFromBufferInfo: () => (/* binding */ createVAOFromBufferInfo),
/* harmony export */   createVertexArrayInfo: () => (/* binding */ createVertexArrayInfo),
/* harmony export */   draw: () => (/* binding */ draw),
/* harmony export */   drawBufferInfo: () => (/* binding */ drawBufferInfo),
/* harmony export */   drawObjectList: () => (/* binding */ drawObjectList),
/* harmony export */   framebuffers: () => (/* binding */ framebuffers),
/* harmony export */   getArray_: () => (/* binding */ getArray$1),
/* harmony export */   getBytesPerElementForInternalFormat: () => (/* binding */ getBytesPerElementForInternalFormat),
/* harmony export */   getContext: () => (/* binding */ getContext),
/* harmony export */   getFormatAndTypeForInternalFormat: () => (/* binding */ getFormatAndTypeForInternalFormat),
/* harmony export */   getGLTypeForTypedArray: () => (/* binding */ getGLTypeForTypedArray),
/* harmony export */   getGLTypeForTypedArrayType: () => (/* binding */ getGLTypeForTypedArrayType),
/* harmony export */   getNumComponentsForFormat: () => (/* binding */ getNumComponentsForFormat),
/* harmony export */   getNumComponents_: () => (/* binding */ getNumComponents$1),
/* harmony export */   getTypedArrayTypeForGLType: () => (/* binding */ getTypedArrayTypeForGLType),
/* harmony export */   getWebGLContext: () => (/* binding */ getWebGLContext),
/* harmony export */   glEnumToString: () => (/* binding */ glEnumToString),
/* harmony export */   isArrayBuffer: () => (/* binding */ isArrayBuffer$1),
/* harmony export */   isWebGL1: () => (/* binding */ isWebGL1),
/* harmony export */   isWebGL2: () => (/* binding */ isWebGL2),
/* harmony export */   loadTextureFromUrl: () => (/* binding */ loadTextureFromUrl),
/* harmony export */   m4: () => (/* binding */ m4),
/* harmony export */   primitives: () => (/* binding */ primitives),
/* harmony export */   programs: () => (/* binding */ programs),
/* harmony export */   resizeCanvasToDisplaySize: () => (/* binding */ resizeCanvasToDisplaySize),
/* harmony export */   resizeFramebufferInfo: () => (/* binding */ resizeFramebufferInfo),
/* harmony export */   resizeTexture: () => (/* binding */ resizeTexture),
/* harmony export */   setAttribInfoBufferFromArray: () => (/* binding */ setAttribInfoBufferFromArray),
/* harmony export */   setAttributeDefaults_: () => (/* binding */ setDefaults$2),
/* harmony export */   setAttributePrefix: () => (/* binding */ setAttributePrefix),
/* harmony export */   setAttributes: () => (/* binding */ setAttributes),
/* harmony export */   setBlockUniforms: () => (/* binding */ setBlockUniforms),
/* harmony export */   setBuffersAndAttributes: () => (/* binding */ setBuffersAndAttributes),
/* harmony export */   setDefaultTextureColor: () => (/* binding */ setDefaultTextureColor),
/* harmony export */   setDefaults: () => (/* binding */ setDefaults),
/* harmony export */   setEmptyTexture: () => (/* binding */ setEmptyTexture),
/* harmony export */   setSamplerParameters: () => (/* binding */ setSamplerParameters),
/* harmony export */   setTextureDefaults_: () => (/* binding */ setDefaults$1),
/* harmony export */   setTextureFilteringForSize: () => (/* binding */ setTextureFilteringForSize),
/* harmony export */   setTextureFromArray: () => (/* binding */ setTextureFromArray),
/* harmony export */   setTextureFromElement: () => (/* binding */ setTextureFromElement),
/* harmony export */   setTextureParameters: () => (/* binding */ setTextureParameters),
/* harmony export */   setUniformBlock: () => (/* binding */ setUniformBlock),
/* harmony export */   setUniforms: () => (/* binding */ setUniforms),
/* harmony export */   setUniformsAndBindTextures: () => (/* binding */ setUniformsAndBindTextures),
/* harmony export */   textures: () => (/* binding */ textures),
/* harmony export */   typedarrays: () => (/* binding */ typedarrays),
/* harmony export */   utils: () => (/* binding */ utils),
/* harmony export */   v3: () => (/* binding */ v3),
/* harmony export */   vertexArrays: () => (/* binding */ vertexArrays)
/* harmony export */ });
/* @license twgl.js 5.5.4 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
Available via the MIT license.
see: http://github.com/greggman/twgl.js for details */
/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 *
 * Vec3 math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new Vec3. In other words you can do this
 *
 *     var v = v3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.
 *
 * or
 *
 *     var v = v3.create();
 *     v3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any vector as the destination. So for example
 *
 *     v3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 * @module twgl/v3
 */

let VecType = Float32Array;

/**
 * A JavaScript array with 3 values or a Float32Array with 3 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/v3.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Vec3
 * @memberOf module:twgl/v3
 */

/**
 * Sets the type this library creates for a Vec3
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Vec3
 * @memberOf module:twgl/v3
 */
function setDefaultType$1(ctor) {
  const oldType = VecType;
  VecType = ctor;
  return oldType;
}

/**
 * Creates a vec3; may be called with x, y, z to set initial values.
 * @param {number} [x] Initial x value.
 * @param {number} [y] Initial y value.
 * @param {number} [z] Initial z value.
 * @return {module:twgl/v3.Vec3} the created vector
 * @memberOf module:twgl/v3
 */
function create$1(x, y, z) {
  const dst = new VecType(3);
  if (x) {
    dst[0] = x;
  }
  if (y) {
    dst[1] = y;
  }
  if (z) {
    dst[2] = z;
  }
  return dst;
}

/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector tha tis the sum of a and b.
 * @memberOf module:twgl/v3
 */
function add(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];

  return dst;
}

/**
 * Subtracts two vectors.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector that is the difference of a and b.
 * @memberOf module:twgl/v3
 */
function subtract(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];

  return dst;
}

/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {number} t Interpolation coefficient.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The linear interpolated result.
 * @memberOf module:twgl/v3
 */
function lerp(a, b, t, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);

  return dst;
}

/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} t Interpolation coefficients vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} the linear interpolated result.
 * @memberOf module:twgl/v3
 */
function lerpV(a, b, t, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);

  return dst;
}

/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The max components vector.
 * @memberOf module:twgl/v3
 */
function max(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);

  return dst;
}

/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The min components vector.
 * @memberOf module:twgl/v3
 */
function min(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);

  return dst;
}

/**
 * Multiplies a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */
function mulScalar(v, k, dst) {
  dst = dst || new VecType(3);

  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;

  return dst;
}

/**
 * Divides a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */
function divScalar(v, k, dst) {
  dst = dst || new VecType(3);

  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;

  return dst;
}

/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of a cross b.
 * @memberOf module:twgl/v3
 */
function cross(a, b, dst) {
  dst = dst || new VecType(3);

  const t1 = a[2] * b[0] - a[0] * b[2];
  const t2 = a[0] * b[1] - a[1] * b[0];
  dst[0] = a[1] * b[2] - a[2] * b[1];
  dst[1] = t1;
  dst[2] = t2;

  return dst;
}

/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @return {number} dot product
 * @memberOf module:twgl/v3
 */
function dot(a, b) {
  return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
}

/**
 * Computes the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} length of vector.
 * @memberOf module:twgl/v3
 */
function length$1(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

/**
 * Computes the square of the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} square of the length of vector.
 * @memberOf module:twgl/v3
 */
function lengthSq(v) {
  return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
}

/**
 * Computes the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} distance between a and b
 * @memberOf module:twgl/v3
 */
function distance(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

/**
 * Computes the square of the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} square of the distance between a and b
 * @memberOf module:twgl/v3
 */
function distanceSq(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return dx * dx + dy * dy + dz * dz;
}

/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param {module:twgl/v3.Vec3} a The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The normalized vector.
 * @memberOf module:twgl/v3
 */
function normalize(a, dst) {
  dst = dst || new VecType(3);

  const lenSq = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
  const len = Math.sqrt(lenSq);
  if (len > 0.00001) {
    dst[0] = a[0] / len;
    dst[1] = a[1] / len;
    dst[2] = a[2] / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
  }

  return dst;
}

/**
 * Negates a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} -v.
 * @memberOf module:twgl/v3
 */
function negate$1(v, dst) {
  dst = dst || new VecType(3);

  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];

  return dst;
}

/**
 * Copies a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A copy of v.
 * @memberOf module:twgl/v3
 */
function copy$1(v, dst) {
  dst = dst || new VecType(3);

  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];

  return dst;
}

/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of products of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */
function multiply$1(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];

  return dst;
}

/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of quotients of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */
function divide(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];

  return dst;
}

var v3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add,
  copy: copy$1,
  create: create$1,
  cross: cross,
  distance: distance,
  distanceSq: distanceSq,
  divide: divide,
  divScalar: divScalar,
  dot: dot,
  lerp: lerp,
  lerpV: lerpV,
  length: length$1,
  lengthSq: lengthSq,
  max: max,
  min: min,
  mulScalar: mulScalar,
  multiply: multiply$1,
  negate: negate$1,
  normalize: normalize,
  setDefaultType: setDefaultType$1,
  subtract: subtract
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * 4x4 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = m4.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = m4.create();
 *     m4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = m4.identity();
 *     const trans = m4.translation([1, 2, 3]);
 *     m4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 * @module twgl/m4
 */
let MatType = Float32Array;

/**
 * A JavaScript array with 16 values or a Float32Array with 16 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/m4.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Mat4
 * @memberOf module:twgl/m4
 */

/**
 * Sets the type this library creates for a Mat4
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Mat4
 * @memberOf module:twgl/m4
 */
function setDefaultType(ctor) {
  const oldType = MatType;
  MatType = ctor;
  return oldType;
}

/**
 * Negates a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} -m.
 * @memberOf module:twgl/m4
 */
function negate(m, dst) {
  dst = dst || new MatType(16);

  dst[ 0] = -m[ 0];
  dst[ 1] = -m[ 1];
  dst[ 2] = -m[ 2];
  dst[ 3] = -m[ 3];
  dst[ 4] = -m[ 4];
  dst[ 5] = -m[ 5];
  dst[ 6] = -m[ 6];
  dst[ 7] = -m[ 7];
  dst[ 8] = -m[ 8];
  dst[ 9] = -m[ 9];
  dst[10] = -m[10];
  dst[11] = -m[11];
  dst[12] = -m[12];
  dst[13] = -m[13];
  dst[14] = -m[14];
  dst[15] = -m[15];

  return dst;
}

/**
 * Creates a matrix.
 * @return {module:twgl/m4.Mat4} A new matrix.
 * @memberOf module:twgl/m4
 */
function create() {
  return new MatType(16).fill(0);
}

/**
 * Copies a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] The matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A copy of m.
 * @memberOf module:twgl/m4
 */
function copy(m, dst) {
  dst = dst || new MatType(16);

  dst[ 0] = m[ 0];
  dst[ 1] = m[ 1];
  dst[ 2] = m[ 2];
  dst[ 3] = m[ 3];
  dst[ 4] = m[ 4];
  dst[ 5] = m[ 5];
  dst[ 6] = m[ 6];
  dst[ 7] = m[ 7];
  dst[ 8] = m[ 8];
  dst[ 9] = m[ 9];
  dst[10] = m[10];
  dst[11] = m[11];
  dst[12] = m[12];
  dst[13] = m[13];
  dst[14] = m[14];
  dst[15] = m[15];

  return dst;
}

/**
 * Creates an n-by-n identity matrix.
 *
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} An n-by-n identity matrix.
 * @memberOf module:twgl/m4
 */
function identity(dst) {
  dst = dst || new MatType(16);

  dst[ 0] = 1;
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = 1;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Takes the transpose of a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The transpose of m.
 * @memberOf module:twgl/m4
 */
 function transpose(m, dst) {
  dst = dst || new MatType(16);
  if (dst === m) {
    let t;

    t = m[1];
    m[1] = m[4];
    m[4] = t;

    t = m[2];
    m[2] = m[8];
    m[8] = t;

    t = m[3];
    m[3] = m[12];
    m[12] = t;

    t = m[6];
    m[6] = m[9];
    m[9] = t;

    t = m[7];
    m[7] = m[13];
    m[13] = t;

    t = m[11];
    m[11] = m[14];
    m[14] = t;
    return dst;
  }

  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];

  dst[ 0] = m00;
  dst[ 1] = m10;
  dst[ 2] = m20;
  dst[ 3] = m30;
  dst[ 4] = m01;
  dst[ 5] = m11;
  dst[ 6] = m21;
  dst[ 7] = m31;
  dst[ 8] = m02;
  dst[ 9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m03;
  dst[13] = m13;
  dst[14] = m23;
  dst[15] = m33;

  return dst;
}

/**
 * Computes the inverse of a 4-by-4 matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The inverse of m.
 * @memberOf module:twgl/m4
 */
function inverse(m, dst) {
  dst = dst || new MatType(16);

  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  const tmp_0  = m22 * m33;
  const tmp_1  = m32 * m23;
  const tmp_2  = m12 * m33;
  const tmp_3  = m32 * m13;
  const tmp_4  = m12 * m23;
  const tmp_5  = m22 * m13;
  const tmp_6  = m02 * m33;
  const tmp_7  = m32 * m03;
  const tmp_8  = m02 * m23;
  const tmp_9  = m22 * m03;
  const tmp_10 = m02 * m13;
  const tmp_11 = m12 * m03;
  const tmp_12 = m20 * m31;
  const tmp_13 = m30 * m21;
  const tmp_14 = m10 * m31;
  const tmp_15 = m30 * m11;
  const tmp_16 = m10 * m21;
  const tmp_17 = m20 * m11;
  const tmp_18 = m00 * m31;
  const tmp_19 = m30 * m01;
  const tmp_20 = m00 * m21;
  const tmp_21 = m20 * m01;
  const tmp_22 = m00 * m11;
  const tmp_23 = m10 * m01;

  const t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -
      (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
  const t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -
      (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
  const t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -
      (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
  const t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -
      (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);

  const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);

  dst[ 0] = d * t0;
  dst[ 1] = d * t1;
  dst[ 2] = d * t2;
  dst[ 3] = d * t3;
  dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -
          (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
  dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -
          (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
  dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -
          (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
  dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -
          (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
  dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -
          (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
  dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -
          (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
  dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -
          (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
  dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -
          (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
  dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -
          (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
  dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -
          (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
  dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -
          (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
  dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -
          (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));

  return dst;
}

/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right
 * @param {module:twgl/m4.Mat4} a The matrix on the left.
 * @param {module:twgl/m4.Mat4} b The matrix on the right.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix product of a and b.
 * @memberOf module:twgl/m4
 */
function multiply(a, b, dst) {
  dst = dst || new MatType(16);

  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a03 = a[3];
  const a10 = a[ 4 + 0];
  const a11 = a[ 4 + 1];
  const a12 = a[ 4 + 2];
  const a13 = a[ 4 + 3];
  const a20 = a[ 8 + 0];
  const a21 = a[ 8 + 1];
  const a22 = a[ 8 + 2];
  const a23 = a[ 8 + 3];
  const a30 = a[12 + 0];
  const a31 = a[12 + 1];
  const a32 = a[12 + 2];
  const a33 = a[12 + 3];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b03 = b[3];
  const b10 = b[ 4 + 0];
  const b11 = b[ 4 + 1];
  const b12 = b[ 4 + 2];
  const b13 = b[ 4 + 3];
  const b20 = b[ 8 + 0];
  const b21 = b[ 8 + 1];
  const b22 = b[ 8 + 2];
  const b23 = b[ 8 + 3];
  const b30 = b[12 + 0];
  const b31 = b[12 + 1];
  const b32 = b[12 + 2];
  const b33 = b[12 + 3];

  dst[ 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
  dst[ 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
  dst[ 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
  dst[ 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
  dst[ 4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
  dst[ 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
  dst[ 6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
  dst[ 7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
  dst[ 8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
  dst[ 9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
  dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
  dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
  dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
  dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
  dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;

  return dst;
}

/**
 * Sets the translation component of a 4-by-4 matrix to the given
 * vector.
 * @param {module:twgl/m4.Mat4} a The matrix.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with translation set.
 * @memberOf module:twgl/m4
 */
function setTranslation(a, v, dst) {
  dst = dst || identity();
  if (a !== dst) {
    dst[ 0] = a[ 0];
    dst[ 1] = a[ 1];
    dst[ 2] = a[ 2];
    dst[ 3] = a[ 3];
    dst[ 4] = a[ 4];
    dst[ 5] = a[ 5];
    dst[ 6] = a[ 6];
    dst[ 7] = a[ 7];
    dst[ 8] = a[ 8];
    dst[ 9] = a[ 9];
    dst[10] = a[10];
    dst[11] = a[11];
  }
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}

/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The translation component of m.
 * @memberOf module:twgl/m4
 */
function getTranslation(m, dst) {
  dst = dst || create$1();
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}

/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} axis The axis 0 = x, 1 = y, 2 = z;
 * @return {module:twgl/v3.Vec3} [dst] vector.
 * @return {module:twgl/v3.Vec3} The axis component of m.
 * @memberOf module:twgl/m4
 */
function getAxis(m, axis, dst) {
  dst = dst || create$1();
  const off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}

/**
 * Sets an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v the axis vector
 * @param {number} axis The axis  0 = x, 1 = y, 2 = z;
 * @param {module:twgl/m4.Mat4} [dst] The matrix to set. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with axis set.
 * @memberOf module:twgl/m4
 */
function setAxis(a, v, axis, dst) {
  if (dst !== a) {
    dst = copy(a, dst);
  }
  const off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  dst[off + 2] = v[2];
  return dst;
}

/**
 * Computes a 4-by-4 perspective transformation matrix given the angular height
 * of the frustum, the aspect ratio, and the near and far clipping planes.  The
 * arguments define a frustum extending in the negative z direction.  The given
 * angle is the vertical angle of the frustum, and the horizontal angle is
 * determined to produce the given aspect ratio.  The arguments near and far are
 * the distances to the near and far clipping planes.  Note that near and far
 * are not z coordinates, but rather they are distances along the negative
 * z-axis.  The matrix generated sends the viewing frustum to the unit box.
 * We assume a unit box extending from -1 to 1 in the x and y dimensions and
 * from 0 to 1 in the z dimension.
 * @param {number} fieldOfViewYInRadians The camera angle from top to bottom (in radians).
 * @param {number} aspect The aspect ratio width / height.
 * @param {number} zNear The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} zFar The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */
function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
  dst = dst || new MatType(16);

  const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
  const rangeInv = 1.0 / (zNear - zFar);

  dst[0]  = f / aspect;
  dst[1]  = 0;
  dst[2]  = 0;
  dst[3]  = 0;

  dst[4]  = 0;
  dst[5]  = f;
  dst[6]  = 0;
  dst[7]  = 0;

  dst[8]  = 0;
  dst[9]  = 0;
  dst[10] = (zNear + zFar) * rangeInv;
  dst[11] = -1;

  dst[12] = 0;
  dst[13] = 0;
  dst[14] = zNear * zFar * rangeInv * 2;
  dst[15] = 0;

  return dst;
}

/**
 * Computes a 4-by-4 orthogonal transformation matrix given the left, right,
 * bottom, and top dimensions of the near clipping plane as well as the
 * near and far clipping plane distances.
 * @param {number} left Left side of the near clipping plane viewport.
 * @param {number} right Right side of the near clipping plane viewport.
 * @param {number} bottom Bottom of the near clipping plane viewport.
 * @param {number} top Top of the near clipping plane viewport.
 * @param {number} near The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} far The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */
function ortho(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);

  dst[0]  = 2 / (right - left);
  dst[1]  = 0;
  dst[2]  = 0;
  dst[3]  = 0;

  dst[4]  = 0;
  dst[5]  = 2 / (top - bottom);
  dst[6]  = 0;
  dst[7]  = 0;

  dst[8]  = 0;
  dst[9]  = 0;
  dst[10] = 2 / (near - far);
  dst[11] = 0;

  dst[12] = (right + left) / (left - right);
  dst[13] = (top + bottom) / (bottom - top);
  dst[14] = (far + near) / (near - far);
  dst[15] = 1;

  return dst;
}

/**
 * Computes a 4-by-4 perspective transformation matrix given the left, right,
 * top, bottom, near and far clipping planes. The arguments define a frustum
 * extending in the negative z direction. The arguments near and far are the
 * distances to the near and far clipping planes. Note that near and far are not
 * z coordinates, but rather they are distances along the negative z-axis. The
 * matrix generated sends the viewing frustum to the unit box. We assume a unit
 * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
 * dimension.
 * @param {number} left The x coordinate of the left plane of the box.
 * @param {number} right The x coordinate of the right plane of the box.
 * @param {number} bottom The y coordinate of the bottom plane of the box.
 * @param {number} top The y coordinate of the right plane of the box.
 * @param {number} near The negative z coordinate of the near plane of the box.
 * @param {number} far The negative z coordinate of the far plane of the box.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective projection matrix.
 * @memberOf module:twgl/m4
 */
function frustum(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);

  const dx = (right - left);
  const dy = (top - bottom);
  const dz = (near - far);

  dst[ 0] = 2 * near / dx;
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = 2 * near / dy;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = (left + right) / dx;
  dst[ 9] = (top + bottom) / dy;
  dst[10] = far / dz;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = near * far / dz;
  dst[15] = 0;

  return dst;
}

let xAxis;
let yAxis;
let zAxis;

/**
 * Computes a 4-by-4 look-at transformation.
 *
 * This is a matrix which positions the camera itself. If you want
 * a view matrix (a matrix which moves things in front of the camera)
 * take the inverse of this.
 *
 * @param {module:twgl/v3.Vec3} eye The position of the eye.
 * @param {module:twgl/v3.Vec3} target The position meant to be viewed.
 * @param {module:twgl/v3.Vec3} up A vector pointing up.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The look-at matrix.
 * @memberOf module:twgl/m4
 */
function lookAt(eye, target, up, dst) {
  dst = dst || new MatType(16);

  xAxis = xAxis || create$1();
  yAxis = yAxis || create$1();
  zAxis = zAxis || create$1();

  normalize(
      subtract(eye, target, zAxis), zAxis);
  normalize(cross(up, zAxis, xAxis), xAxis);
  normalize(cross(zAxis, xAxis, yAxis), yAxis);

  dst[ 0] = xAxis[0];
  dst[ 1] = xAxis[1];
  dst[ 2] = xAxis[2];
  dst[ 3] = 0;
  dst[ 4] = yAxis[0];
  dst[ 5] = yAxis[1];
  dst[ 6] = yAxis[2];
  dst[ 7] = 0;
  dst[ 8] = zAxis[0];
  dst[ 9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = eye[0];
  dst[13] = eye[1];
  dst[14] = eye[2];
  dst[15] = 1;

  return dst;
}

/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translation matrix.
 * @memberOf module:twgl/m4
 */
function translation(v, dst) {
  dst = dst || new MatType(16);

  dst[ 0] = 1;
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = 1;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}

/**
 * Translates the given 4-by-4 matrix by the given vector v.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translated matrix.
 * @memberOf module:twgl/m4
 */
function translate(m, v, dst) {
  dst = dst || new MatType(16);

  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];

  if (m !== dst) {
    dst[ 0] = m00;
    dst[ 1] = m01;
    dst[ 2] = m02;
    dst[ 3] = m03;
    dst[ 4] = m10;
    dst[ 5] = m11;
    dst[ 6] = m12;
    dst[ 7] = m13;
    dst[ 8] = m20;
    dst[ 9] = m21;
    dst[10] = m22;
    dst[11] = m23;
  }

  dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
  dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
  dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
  dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;

  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationX(angleInRadians, dst) {
  dst = dst || new MatType(16);

  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = 1;
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = c;
  dst[ 6] = s;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = -s;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateX(m, angleInRadians, dst) {
  dst = dst || new MatType(16);

  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[4]  = c * m10 + s * m20;
  dst[5]  = c * m11 + s * m21;
  dst[6]  = c * m12 + s * m22;
  dst[7]  = c * m13 + s * m23;
  dst[8]  = c * m20 - s * m10;
  dst[9]  = c * m21 - s * m11;
  dst[10] = c * m22 - s * m12;
  dst[11] = c * m23 - s * m13;

  if (m !== dst) {
    dst[ 0] = m[ 0];
    dst[ 1] = m[ 1];
    dst[ 2] = m[ 2];
    dst[ 3] = m[ 3];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationY(angleInRadians, dst) {
  dst = dst || new MatType(16);

  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = c;
  dst[ 1] = 0;
  dst[ 2] = -s;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = 1;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = s;
  dst[ 9] = 0;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateY(m, angleInRadians, dst) {
  dst = dst || new MatType(16);

  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = c * m00 - s * m20;
  dst[ 1] = c * m01 - s * m21;
  dst[ 2] = c * m02 - s * m22;
  dst[ 3] = c * m03 - s * m23;
  dst[ 8] = c * m20 + s * m00;
  dst[ 9] = c * m21 + s * m01;
  dst[10] = c * m22 + s * m02;
  dst[11] = c * m23 + s * m03;

  if (m !== dst) {
    dst[ 4] = m[ 4];
    dst[ 5] = m[ 5];
    dst[ 6] = m[ 6];
    dst[ 7] = m[ 7];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationZ(angleInRadians, dst) {
  dst = dst || new MatType(16);

  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = c;
  dst[ 1] = s;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = -s;
  dst[ 5] = c;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateZ(m, angleInRadians, dst) {
  dst = dst || new MatType(16);

  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = c * m00 + s * m10;
  dst[ 1] = c * m01 + s * m11;
  dst[ 2] = c * m02 + s * m12;
  dst[ 3] = c * m03 + s * m13;
  dst[ 4] = c * m10 - s * m00;
  dst[ 5] = c * m11 - s * m01;
  dst[ 6] = c * m12 - s * m02;
  dst[ 7] = c * m13 - s * m03;

  if (m !== dst) {
    dst[ 8] = m[ 8];
    dst[ 9] = m[ 9];
    dst[10] = m[10];
    dst[11] = m[11];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A matrix which rotates angle radians
 *     around the axis.
 * @memberOf module:twgl/m4
 */
function axisRotation(axis, angleInRadians, dst) {
  dst = dst || new MatType(16);

  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;

  dst[ 0] = xx + (1 - xx) * c;
  dst[ 1] = x * y * oneMinusCosine + z * s;
  dst[ 2] = x * z * oneMinusCosine - y * s;
  dst[ 3] = 0;
  dst[ 4] = x * y * oneMinusCosine - z * s;
  dst[ 5] = yy + (1 - yy) * c;
  dst[ 6] = y * z * oneMinusCosine + x * s;
  dst[ 7] = 0;
  dst[ 8] = x * z * oneMinusCosine + y * s;
  dst[ 9] = y * z * oneMinusCosine - x * s;
  dst[10] = zz + (1 - zz) * c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function axisRotate(m, axis, angleInRadians, dst) {
  dst = dst || new MatType(16);

  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;

  const r00 = xx + (1 - xx) * c;
  const r01 = x * y * oneMinusCosine + z * s;
  const r02 = x * z * oneMinusCosine - y * s;
  const r10 = x * y * oneMinusCosine - z * s;
  const r11 = yy + (1 - yy) * c;
  const r12 = y * z * oneMinusCosine + x * s;
  const r20 = x * z * oneMinusCosine + y * s;
  const r21 = y * z * oneMinusCosine - x * s;
  const r22 = zz + (1 - zz) * c;

  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];

  dst[ 0] = r00 * m00 + r01 * m10 + r02 * m20;
  dst[ 1] = r00 * m01 + r01 * m11 + r02 * m21;
  dst[ 2] = r00 * m02 + r01 * m12 + r02 * m22;
  dst[ 3] = r00 * m03 + r01 * m13 + r02 * m23;
  dst[ 4] = r10 * m00 + r11 * m10 + r12 * m20;
  dst[ 5] = r10 * m01 + r11 * m11 + r12 * m21;
  dst[ 6] = r10 * m02 + r11 * m12 + r12 * m22;
  dst[ 7] = r10 * m03 + r11 * m13 + r12 * m23;
  dst[ 8] = r20 * m00 + r21 * m10 + r22 * m20;
  dst[ 9] = r20 * m01 + r21 * m11 + r22 * m21;
  dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
  dst[11] = r20 * m03 + r21 * m13 + r22 * m23;

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param {module:twgl/v3.Vec3} v A vector of
 *     three entries specifying the factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaling matrix.
 * @memberOf module:twgl/m4
 */
function scaling(v, dst) {
  dst = dst || new MatType(16);

  dst[ 0] = v[0];
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = v[1];
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = 0;
  dst[10] = v[2];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Scales the given 4-by-4 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param {module:twgl/m4.Mat4} m The matrix to be modified.
 * @param {module:twgl/v3.Vec3} v A vector of three entries specifying the
 *     factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaled matrix.
 * @memberOf module:twgl/m4
 */
function scale(m, v, dst) {
  dst = dst || new MatType(16);

  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];

  dst[ 0] = v0 * m[0 * 4 + 0];
  dst[ 1] = v0 * m[0 * 4 + 1];
  dst[ 2] = v0 * m[0 * 4 + 2];
  dst[ 3] = v0 * m[0 * 4 + 3];
  dst[ 4] = v1 * m[1 * 4 + 0];
  dst[ 5] = v1 * m[1 * 4 + 1];
  dst[ 6] = v1 * m[1 * 4 + 2];
  dst[ 7] = v1 * m[1 * 4 + 3];
  dst[ 8] = v2 * m[2 * 4 + 0];
  dst[ 9] = v2 * m[2 * 4 + 1];
  dst[10] = v2 * m[2 * 4 + 2];
  dst[11] = v2 * m[2 * 4 + 3];

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Takes a 4-by-4 matrix and a vector with 3 entries,
 * interprets the vector as a point, transforms that point by the matrix, and
 * returns the result as a vector with 3 entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The point.
 * @param {module:twgl/v3.Vec3} [dst] optional vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed point.
 * @memberOf module:twgl/m4
 */
function transformPoint(m, v, dst) {
  dst = dst || create$1();
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];

  dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;
  dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;
  dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;

  return dst;
}

/**
 * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a
 * direction, transforms that direction by the matrix, and returns the result;
 * assumes the transformation of 3-dimensional space represented by the matrix
 * is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion. Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The direction.
 * @param {module:twgl/v3.Vec3} [dst] optional Vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed direction.
 * @memberOf module:twgl/m4
 */
function transformDirection(m, v, dst) {
  dst = dst || create$1();

  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];

  dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];

  return dst;
}

/**
 * Takes a 4-by-4 matrix m and a vector v with 3 entries, interprets the vector
 * as a normal to a surface, and computes a vector which is normal upon
 * transforming that surface by the matrix. The effect of this function is the
 * same as transforming v (as a direction) by the inverse-transpose of m.  This
 * function assumes the transformation of 3-dimensional space represented by the
 * matrix is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion.  Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The normal.
 * @param {module:twgl/v3.Vec3} [dst] The direction. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed normal.
 * @memberOf module:twgl/m4
 */
function transformNormal$1(m, v, dst) {
  dst = dst || create$1();
  const mi = inverse(m);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];

  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];

  return dst;
}

var m4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  axisRotate: axisRotate,
  axisRotation: axisRotation,
  copy: copy,
  create: create,
  frustum: frustum,
  getAxis: getAxis,
  getTranslation: getTranslation,
  identity: identity,
  inverse: inverse,
  lookAt: lookAt,
  multiply: multiply,
  negate: negate,
  ortho: ortho,
  perspective: perspective,
  rotateX: rotateX,
  rotateY: rotateY,
  rotateZ: rotateZ,
  rotationX: rotationX,
  rotationY: rotationY,
  rotationZ: rotationZ,
  scale: scale,
  scaling: scaling,
  setAxis: setAxis,
  setDefaultType: setDefaultType,
  setTranslation: setTranslation,
  transformDirection: transformDirection,
  transformNormal: transformNormal$1,
  transformPoint: transformPoint,
  translate: translate,
  translation: translation,
  transpose: transpose
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* DataType */
const BYTE$2                           = 0x1400;
const UNSIGNED_BYTE$3                  = 0x1401;
const SHORT$2                          = 0x1402;
const UNSIGNED_SHORT$3                 = 0x1403;
const INT$3                            = 0x1404;
const UNSIGNED_INT$3                   = 0x1405;
const FLOAT$3                          = 0x1406;
const UNSIGNED_SHORT_4_4_4_4$1       = 0x8033;
const UNSIGNED_SHORT_5_5_5_1$1       = 0x8034;
const UNSIGNED_SHORT_5_6_5$1         = 0x8363;
const HALF_FLOAT$1                   = 0x140B;
const UNSIGNED_INT_2_10_10_10_REV$1  = 0x8368;
const UNSIGNED_INT_10F_11F_11F_REV$1 = 0x8C3B;
const UNSIGNED_INT_5_9_9_9_REV$1     = 0x8C3E;
const FLOAT_32_UNSIGNED_INT_24_8_REV$1 = 0x8DAD;
const UNSIGNED_INT_24_8$1            = 0x84FA;

const glTypeToTypedArray = {};
{
  const tt = glTypeToTypedArray;
  tt[BYTE$2]                           = Int8Array;
  tt[UNSIGNED_BYTE$3]                  = Uint8Array;
  tt[SHORT$2]                          = Int16Array;
  tt[UNSIGNED_SHORT$3]                 = Uint16Array;
  tt[INT$3]                            = Int32Array;
  tt[UNSIGNED_INT$3]                   = Uint32Array;
  tt[FLOAT$3]                          = Float32Array;
  tt[UNSIGNED_SHORT_4_4_4_4$1]         = Uint16Array;
  tt[UNSIGNED_SHORT_5_5_5_1$1]         = Uint16Array;
  tt[UNSIGNED_SHORT_5_6_5$1]           = Uint16Array;
  tt[HALF_FLOAT$1]                     = Uint16Array;
  tt[UNSIGNED_INT_2_10_10_10_REV$1]    = Uint32Array;
  tt[UNSIGNED_INT_10F_11F_11F_REV$1]   = Uint32Array;
  tt[UNSIGNED_INT_5_9_9_9_REV$1]       = Uint32Array;
  tt[FLOAT_32_UNSIGNED_INT_24_8_REV$1] = Uint32Array;
  tt[UNSIGNED_INT_24_8$1]              = Uint32Array;
}

/**
 * Get the GL type for a typedArray
 * @param {ArrayBufferView} typedArray a typedArray
 * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */
function getGLTypeForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array)         { return BYTE$2; }           // eslint-disable-line
  if (typedArray instanceof Uint8Array)        { return UNSIGNED_BYTE$3; }  // eslint-disable-line
  if (typedArray instanceof Uint8ClampedArray) { return UNSIGNED_BYTE$3; }  // eslint-disable-line
  if (typedArray instanceof Int16Array)        { return SHORT$2; }          // eslint-disable-line
  if (typedArray instanceof Uint16Array)       { return UNSIGNED_SHORT$3; } // eslint-disable-line
  if (typedArray instanceof Int32Array)        { return INT$3; }            // eslint-disable-line
  if (typedArray instanceof Uint32Array)       { return UNSIGNED_INT$3; }   // eslint-disable-line
  if (typedArray instanceof Float32Array)      { return FLOAT$3; }          // eslint-disable-line
  throw new Error('unsupported typed array type');
}

/**
 * Get the GL type for a typedArray type
 * @param {ArrayBufferView} typedArrayType a typedArray constructor
 * @return {number} the GL type for type. For example pass in `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */
function getGLTypeForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array)         { return BYTE$2; }           // eslint-disable-line
  if (typedArrayType === Uint8Array)        { return UNSIGNED_BYTE$3; }  // eslint-disable-line
  if (typedArrayType === Uint8ClampedArray) { return UNSIGNED_BYTE$3; }  // eslint-disable-line
  if (typedArrayType === Int16Array)        { return SHORT$2; }          // eslint-disable-line
  if (typedArrayType === Uint16Array)       { return UNSIGNED_SHORT$3; } // eslint-disable-line
  if (typedArrayType === Int32Array)        { return INT$3; }            // eslint-disable-line
  if (typedArrayType === Uint32Array)       { return UNSIGNED_INT$3; }   // eslint-disable-line
  if (typedArrayType === Float32Array)      { return FLOAT$3; }          // eslint-disable-line
  throw new Error('unsupported typed array type');
}

/**
 * Get the typed array constructor for a given GL type
 * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)
 * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).
 * @memberOf module:twgl/typedArray
 */
function getTypedArrayTypeForGLType(type) {
  const CTOR = glTypeToTypedArray[type];
  if (!CTOR) {
    throw new Error('unknown gl type');
  }
  return CTOR;
}

const isArrayBuffer$1 = typeof SharedArrayBuffer !== 'undefined'
  ? function isArrayBufferOrSharedArrayBuffer(a) {
    return a && a.buffer && (a.buffer instanceof ArrayBuffer || a.buffer instanceof SharedArrayBuffer);
  }
  : function isArrayBuffer(a) {
    return a && a.buffer && a.buffer instanceof ArrayBuffer;
  };

var typedarrays = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getGLTypeForTypedArray: getGLTypeForTypedArray,
  getGLTypeForTypedArrayType: getGLTypeForTypedArrayType,
  getTypedArrayTypeForGLType: getTypedArrayTypeForGLType,
  isArrayBuffer: isArrayBuffer$1
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* eslint no-console: "off" */

/**
 * Copy named properties
 *
 * @param {string[]} names names of properties to copy
 * @param {object} src object to copy properties from
 * @param {object} dst object to copy properties to
 * @private
 */
function copyNamedProperties(names, src, dst) {
  names.forEach(function(name) {
    const value = src[name];
    if (value !== undefined) {
      dst[name] = value;
    }
  });
}

/**
 * Copies properties from source to dest only if a matching key is in dest
 *
 * @param {Object.<string, ?>} src the source
 * @param {Object.<string, ?>} dst the dest
 * @private
 */
function copyExistingProperties(src, dst) {
  Object.keys(dst).forEach(function(key) {
    if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {  /* eslint no-prototype-builtins: 0 */
      dst[key] = src[key];
    }
  });
}

function error$1(...args) {
  console.error(...args);
}

function warn$1(...args) {
  console.warn(...args);
}

const isTypeWeakMaps = new Map();

function isType(object, type) {
  if (!object || typeof object !== 'object') {
    return false;
  }
  let weakMap = isTypeWeakMaps.get(type);
  if (!weakMap) {
    weakMap = new WeakMap();
    isTypeWeakMaps.set(type, weakMap);
  }
  let isOfType = weakMap.get(object);
  if (isOfType === undefined) {
    const s = Object.prototype.toString.call(object);
    isOfType = s.substring(8, s.length - 1) === type;
    weakMap.set(object, isOfType);
  }
  return isOfType;
}

function isBuffer(gl, t) {
  return typeof WebGLBuffer !== 'undefined' && isType(t, 'WebGLBuffer');
}

function isRenderbuffer(gl, t) {
  return typeof WebGLRenderbuffer !== 'undefined' && isType(t, 'WebGLRenderbuffer');
}

function isTexture(gl, t) {
  return typeof WebGLTexture !== 'undefined' && isType(t, 'WebGLTexture');
}

function isSampler(gl, t) {
  return typeof WebGLSampler !== 'undefined' && isType(t, 'WebGLSampler');
}

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const STATIC_DRAW                  = 0x88e4;
const ARRAY_BUFFER$1                 = 0x8892;
const ELEMENT_ARRAY_BUFFER$2         = 0x8893;
const BUFFER_SIZE                  = 0x8764;

const BYTE$1                         = 0x1400;
const UNSIGNED_BYTE$2                = 0x1401;
const SHORT$1                        = 0x1402;
const UNSIGNED_SHORT$2               = 0x1403;
const INT$2                          = 0x1404;
const UNSIGNED_INT$2                 = 0x1405;
const FLOAT$2                        = 0x1406;
const defaults$2 = {
  attribPrefix: "",
};

/**
 * Sets the default attrib prefix
 *
 * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 * as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 * In other words I'll create arrays of geometry like this
 *
 *     var arrays = {
 *       position: ...
 *       normal: ...
 *       texcoord: ...
 *     };
 *
 * But need those mapped to attributes and my attributes start with `a_`.
 *
 * @deprecated see {@link module:twgl.setDefaults}
 * @param {string} prefix prefix for attribs
 * @memberOf module:twgl/attributes
 */
function setAttributePrefix(prefix) {
  defaults$2.attribPrefix = prefix;
}

function setDefaults$2(newDefaults) {
  copyExistingProperties(newDefaults, defaults$2);
}

function setBufferFromTypedArray(gl, type, buffer, array, drawType) {
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, array, drawType || STATIC_DRAW);
}

/**
 * Given typed array creates a WebGLBuffer and copies the typed array
 * into it.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken
 * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.
 * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.
 * @return {WebGLBuffer} the created WebGLBuffer
 * @memberOf module:twgl/attributes
 */
function createBufferFromTypedArray(gl, typedArray, type, drawType) {
  if (isBuffer(gl, typedArray)) {
    return typedArray;
  }
  type = type || ARRAY_BUFFER$1;
  const buffer = gl.createBuffer();
  setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);
  return buffer;
}

function isIndices(name) {
  return name === "indices";
}

// This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?
function getNormalizationForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array)    { return true; }  // eslint-disable-line
  if (typedArrayType === Uint8Array)   { return true; }  // eslint-disable-line
  return false;
}

function getArray$1(array) {
  return array.length ? array : array.data;
}

const texcoordRE = /coord|texture/i;
const colorRE = /color|colour/i;

function guessNumComponentsFromName(name, length) {
  let numComponents;
  if (texcoordRE.test(name)) {
    numComponents = 2;
  } else if (colorRE.test(name)) {
    numComponents = 4;
  } else {
    numComponents = 3;  // position, normals, indices ...
  }

  if (length % numComponents > 0) {
    throw new Error(`Can not guess numComponents for attribute '${name}'. Tried ${numComponents} but ${length} values is not evenly divisible by ${numComponents}. You should specify it.`);
  }

  return numComponents;
}

function getNumComponents$1(array, arrayName, numValues) {
  return array.numComponents || array.size || guessNumComponentsFromName(arrayName, numValues || getArray$1(array).length);
}

function makeTypedArray(array, name) {
  if (isArrayBuffer$1(array)) {
    return array;
  }

  if (isArrayBuffer$1(array.data)) {
    return array.data;
  }

  if (Array.isArray(array)) {
    array = {
      data: array,
    };
  }

  let Type = array.type ? typedArrayTypeFromGLTypeOrTypedArrayCtor(array.type) : undefined;
  if (!Type) {
    if (isIndices(name)) {
      Type = Uint16Array;
    } else {
      Type = Float32Array;
    }
  }
  return new Type(array.data);
}

function glTypeFromGLTypeOrTypedArrayType(glTypeOrTypedArrayCtor) {
  return typeof glTypeOrTypedArrayCtor === 'number'
      ? glTypeOrTypedArrayCtor
      : glTypeOrTypedArrayCtor ? getGLTypeForTypedArrayType(glTypeOrTypedArrayCtor) : FLOAT$2;
}

function typedArrayTypeFromGLTypeOrTypedArrayCtor(glTypeOrTypedArrayCtor) {
  return typeof glTypeOrTypedArrayCtor === 'number'
      ? getTypedArrayTypeForGLType(glTypeOrTypedArrayCtor)
      : glTypeOrTypedArrayCtor || Float32Array;
}

function attribBufferFromBuffer(gl, array/*, arrayName */) {
  return {
    buffer: array.buffer,
    numValues: 2 * 3 * 4,  // safely divided by 2, 3, 4
    type: glTypeFromGLTypeOrTypedArrayType(array.type),
    arrayType: typedArrayTypeFromGLTypeOrTypedArrayCtor(array.type),
  };
}

function attribBufferFromSize(gl, array/*, arrayName*/) {
  const numValues = array.data || array;
  const arrayType = typedArrayTypeFromGLTypeOrTypedArrayCtor(array.type);
  const numBytes = numValues * arrayType.BYTES_PER_ELEMENT;
  const buffer = gl.createBuffer();
  gl.bindBuffer(ARRAY_BUFFER$1, buffer);
  gl.bufferData(ARRAY_BUFFER$1, numBytes, array.drawType || STATIC_DRAW);
  return {
    buffer,
    numValues,
    type: getGLTypeForTypedArrayType(arrayType),
    arrayType,
  };
}

function attribBufferFromArrayLike(gl, array, arrayName) {
  const typedArray = makeTypedArray(array, arrayName);
  return {
    arrayType: typedArray.constructor,
    buffer: createBufferFromTypedArray(gl, typedArray, undefined, array.drawType),
    type: getGLTypeForTypedArray(typedArray),
    numValues: 0,
  };
}

/**
 * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer
 * for the attribute.
 *
 * @typedef {Object} AttribInfo
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {number} [numComponents] the number of components for this attribute.
 * @property {number} [size] synonym for `numComponents`.
 * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`
 * @property {boolean} [normalize] whether or not to normalize the data. Default = false
 * @property {number} [offset] offset into buffer in bytes. Default = 0
 * @property {number} [stride] the stride in bytes per element. Default = 0
 * @property {number} [divisor] the divisor in instances. Default = 0.
 *    Requires WebGL2 or the ANGLE_instanced_arrays extension.
 *    and, if you're using WebGL1 you must have called {@link module:twgl.addExtensionsToContext}
 * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute
 * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW
 * @memberOf module:twgl
 */

/**
 * @typedef {(Int8ArrayConstructor|Uint8ArrayConstructor|Int16ArrayConstructor|Uint16ArrayConstructor|Int32ArrayConstructor|Uint32ArrayConstructor|Float32ArrayConstructor)} TypedArrayConstructor
 */

/**
 * Use this type of array spec when TWGL can't guess the type or number of components of an array
 * @typedef {Object} FullArraySpec
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {(number|number[]|ArrayBufferView)} [data] The data of the array. A number alone becomes the number of elements of type.
 * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.
 *    If `coord` is in the name assumes `numComponents = 2`.
 *    If `color` is in the name assumes `numComponents = 4`.
 *    otherwise assumes `numComponents = 3`
 * @property {number|TypedArrayConstructor} [type] type. This is used if `data` is a JavaScript array, or `buffer` is passed in, or `data` is a number.
 *   It can either be the constructor for a typedarray. (eg. `Uint8Array`) OR a WebGL type, (eg `gl.UNSIGNED_BYTE`).
 *   For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: gl.UNSIGNED_BYTE, data: [255,0,255,255, ...], }`.
 * @property {number} [size] synonym for `numComponents`.
 * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.
 * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0
 * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0
 * @property {number} [divisor] divisor for `vertexAttribDivisor`. Default = 0.
 *     Requires WebGL2 or the ANGLE_instanced_arrays extension.
 *     and, if you using WebGL1 you must have called {@link module:twgl.addExtensionsToContext}
 * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.
 * @property {string} [name] synonym for `attrib`.
 * @property {string} [attribName] synonym for `attrib`.
 * @property {WebGLBuffer} [buffer] Buffer to use for this attribute. This lets you use your own buffer
 *    but you will need to supply `numComponents` and `type`. You can effectively pass an `AttribInfo`
 *    to provide this. Example:
 *
 *         const bufferInfo1 = twgl.createBufferInfoFromArrays(gl, {
 *           position: [1, 2, 3, ... ],
 *         });
 *         const bufferInfo2 = twgl.createBufferInfoFromArrays(gl, {
 *           position: bufferInfo1.attribs.position,  // use the same buffer from bufferInfo1
 *         });
 *
 * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW
 * @memberOf module:twgl
 */

/**
 * An individual array in {@link module:twgl.Arrays}
 *
 * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBufferView`
 * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will
 * be `Float32Array`. If an ArraySpec is a number it's the number of floats for an empty (zeroed) buffer.
 *
 * @typedef {(number|number[]|ArrayBufferView|module:twgl.FullArraySpec)} ArraySpec
 * @memberOf module:twgl
 */

/**
 * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your
 * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * Objects with various fields. See {@link module:twgl.FullArraySpec}.
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays
 * @memberOf module:twgl
 */


/**
 * Creates a set of attribute data and WebGLBuffers from set of arrays
 *
 * Given
 *
 *      var arrays = {
 *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },
 *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *      };
 *
 * returns something like
 *
 *      var attribs = {
 *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },
 *      };
 *
 * notes:
 *
 * *   Arrays can take various forms
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * @param {WebGLRenderingContext} gl The webgl rendering context.
 * @param {module:twgl.Arrays} arrays The arrays
 * @param {module:twgl.BufferInfo} [srcBufferInfo] a BufferInfo to copy from
 *   This lets you share buffers. Any arrays you supply will override
 *   the buffers from srcBufferInfo.
 * @return {Object.<string, module:twgl.AttribInfo>} the attribs
 * @memberOf module:twgl/attributes
 */
function createAttribsFromArrays(gl, arrays) {
  const attribs = {};
  Object.keys(arrays).forEach(function(arrayName) {
    if (!isIndices(arrayName)) {
      const array = arrays[arrayName];
      const attribName = array.attrib || array.name || array.attribName || (defaults$2.attribPrefix + arrayName);
      if (array.value) {
        if (!Array.isArray(array.value) && !isArrayBuffer$1(array.value)) {
          throw new Error('array.value is not array or typedarray');
        }
        attribs[attribName] = {
          value: array.value,
        };
      } else {
        let fn;
        if (array.buffer && array.buffer instanceof WebGLBuffer) {
          fn = attribBufferFromBuffer;
        } else if (typeof array === "number" || typeof array.data === "number") {
          fn = attribBufferFromSize;
        } else {
          fn = attribBufferFromArrayLike;
        }
        const {buffer, type, numValues, arrayType} = fn(gl, array, arrayName);
        const normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArrayType(arrayType);
        const numComponents = getNumComponents$1(array, arrayName, numValues);
        attribs[attribName] = {
          buffer:        buffer,
          numComponents: numComponents,
          type:          type,
          normalize:     normalization,
          stride:        array.stride || 0,
          offset:        array.offset || 0,
          divisor:       array.divisor === undefined ? undefined : array.divisor,
          drawType:      array.drawType,
        };
      }
    }
  });
  gl.bindBuffer(ARRAY_BUFFER$1, null);
  return attribs;
}

/**
 * Sets the contents of a buffer attached to an attribInfo
 *
 * This is helper function to dynamically update a buffer.
 *
 * Let's say you make a bufferInfo
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 *  And you want to dynamically update the positions. You could do this
 *
 *     // assuming arrays.position has already been updated with new data.
 *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);
 *
 * @param {WebGLRenderingContext} gl
 * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix
 *   the name of the attribute will include the prefix.
 * @param {ArraySpec} array Note: it is arguably inefficient to pass in anything but a typed array because anything
 *    else will have to be converted to a typed array before it can be used by WebGL. During init time that
 *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.
 * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer
 *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`
 *    for the portion of the array you want to use.
 *
 *        var someArray = new Float32Array(1000); // an array with 1000 floats
 *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray
 *
 *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`
 * @memberOf module:twgl/attributes
 */
function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {
  array = makeTypedArray(array);
  if (offset !== undefined) {
    gl.bindBuffer(ARRAY_BUFFER$1, attribInfo.buffer);
    gl.bufferSubData(ARRAY_BUFFER$1, offset, array);
  } else {
    setBufferFromTypedArray(gl, ARRAY_BUFFER$1, attribInfo.buffer, array, attribInfo.drawType);
  }
}

function getBytesPerValueForGLType(gl, type) {
  if (type === BYTE$1)           return 1;  // eslint-disable-line
  if (type === UNSIGNED_BYTE$2)  return 1;  // eslint-disable-line
  if (type === SHORT$1)          return 2;  // eslint-disable-line
  if (type === UNSIGNED_SHORT$2) return 2;  // eslint-disable-line
  if (type === INT$2)            return 4;  // eslint-disable-line
  if (type === UNSIGNED_INT$2)   return 4;  // eslint-disable-line
  if (type === FLOAT$2)          return 4;  // eslint-disable-line
  return 0;
}

// Tries to get the number of elements from a set of arrays.
const positionKeys = ['position', 'positions', 'a_position'];
function getNumElementsFromNonIndexedArrays(arrays) {
  let key;
  let ii;
  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];
    if (key in arrays) {
      break;
    }
  }
  if (ii === positionKeys.length) {
    key = Object.keys(arrays)[0];
  }
  const array = arrays[key];
  const length = getArray$1(array).length;
  if (length === undefined) {
    return 1;   // There's no arrays
  }
  const numComponents = getNumComponents$1(array, key);
  const numElements = length / numComponents;
  if (length % numComponents > 0) {
    throw new Error(`numComponents ${numComponents} not correct for length ${length}`);
  }
  return numElements;
}

function getNumElementsFromAttributes(gl, attribs) {
  let key;
  let ii;
  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];
    if (key in attribs) {
      break;
    }
    key = defaults$2.attribPrefix + key;
    if (key in attribs) {
      break;
    }
  }
  if (ii === positionKeys.length) {
    key = Object.keys(attribs)[0];
  }
  const attrib = attribs[key];
  if (!attrib.buffer) {
    return 1; // There's no buffer
  }
  gl.bindBuffer(ARRAY_BUFFER$1, attrib.buffer);
  const numBytes = gl.getBufferParameter(ARRAY_BUFFER$1, BUFFER_SIZE);
  gl.bindBuffer(ARRAY_BUFFER$1, null);

  const bytesPerValue = getBytesPerValueForGLType(gl, attrib.type);
  const totalElements = numBytes / bytesPerValue;
  const numComponents = attrib.numComponents || attrib.size;
  // TODO: check stride
  const numElements = totalElements / numComponents;
  if (numElements % 1 !== 0) {
    throw new Error(`numComponents ${numComponents} not correct for length ${length}`);
  }
  return numElements;
}

/**
 * @typedef {Object} BufferInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.
 * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs appropriate to call `setAttributes`
 * @memberOf module:twgl
 */

/**
 * Creates a BufferInfo from an object of arrays.
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * Given an object like
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 *  Creates an BufferInfo like this
 *
 *     bufferInfo = {
 *       numElements: 4,        // or whatever the number of elements is
 *       indices: WebGLBuffer,  // this property will not exist if there are no indices
 *       attribs: {
 *         position: { buffer: WebGLBuffer, numComponents: 3, },
 *         normal:   { buffer: WebGLBuffer, numComponents: 3, },
 *         texcoord: { buffer: WebGLBuffer, numComponents: 2, },
 *       },
 *     };
 *
 *  The properties of arrays can be JavaScript arrays in which case the number of components
 *  will be guessed.
 *
 *     var arrays = {
 *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
 *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
 *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
 *        indices:  [0, 1, 2, 1, 2, 3],
 *     };
 *
 *  They can also be TypedArrays
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *
 *  Or AugmentedTypedArrays
 *
 *     var positions = createAugmentedTypedArray(3, 4);
 *     var texcoords = createAugmentedTypedArray(2, 4);
 *     var normals   = createAugmentedTypedArray(3, 4);
 *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);
 *
 *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);
 *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);
 *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
 *     indices.push([0, 1, 2, 1, 2, 3]);
 *
 *     var arrays = {
 *        position: positions,
 *        texcoord: texcoords,
 *        normal:   normals,
 *        indices:  indices,
 *     };
 *
 * For the last example it is equivalent to
 *
 *     var bufferInfo = {
 *       attribs: {
 *         position: { numComponents: 3, buffer: gl.createBuffer(), },
 *         texcoord: { numComponents: 2, buffer: gl.createBuffer(), },
 *         normal: { numComponents: 3, buffer: gl.createBuffer(), },
 *       },
 *       indices: gl.createBuffer(),
 *       numElements: 6,
 *     };
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.position.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.texcoord.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.normal.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);
 *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.Arrays} arrays Your data
 * @param {module:twgl.BufferInfo} [srcBufferInfo] An existing
 *        buffer info to start from. WebGLBuffers etc specified
 *        in the srcBufferInfo will be used in a new BufferInfo
 *        with any arrays specified overriding the ones in
 *        srcBufferInfo.
 * @return {module:twgl.BufferInfo} A BufferInfo
 * @memberOf module:twgl/attributes
 */
function createBufferInfoFromArrays(gl, arrays, srcBufferInfo) {
  const newAttribs = createAttribsFromArrays(gl, arrays);
  const bufferInfo = Object.assign({}, srcBufferInfo ? srcBufferInfo : {});
  bufferInfo.attribs = Object.assign({}, srcBufferInfo ? srcBufferInfo.attribs : {}, newAttribs);
  const indices = arrays.indices;
  if (indices) {
    const newIndices = makeTypedArray(indices, "indices");
    bufferInfo.indices = createBufferFromTypedArray(gl, newIndices, ELEMENT_ARRAY_BUFFER$2);
    bufferInfo.numElements = newIndices.length;
    bufferInfo.elementType = getGLTypeForTypedArray(newIndices);
  } else if (!bufferInfo.numElements) {
    bufferInfo.numElements = getNumElementsFromAttributes(gl, bufferInfo.attribs);
  }

  return bufferInfo;
}

/**
 * Creates a buffer from an array, typed array, or array spec
 *
 * Given something like this
 *
 *     [1, 2, 3],
 *
 * or
 *
 *     new Uint16Array([1,2,3]);
 *
 * or
 *
 *     {
 *        data: [1, 2, 3],
 *        type: Uint8Array,
 *     }
 *
 * returns a WebGLBuffer that contains the given data.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.
 * @param {string} arrayName name of array. Used to guess the type if type can not be derived otherwise.
 * @return {WebGLBuffer} a WebGLBuffer containing the data in array.
 * @memberOf module:twgl/attributes
 */
function createBufferFromArray(gl, array, arrayName) {
  const type = arrayName === "indices" ? ELEMENT_ARRAY_BUFFER$2 : ARRAY_BUFFER$1;
  const typedArray = makeTypedArray(array, arrayName);
  return createBufferFromTypedArray(gl, typedArray, type);
}

/**
 * Creates buffers from arrays or typed arrays
 *
 * Given something like this
 *
 *     var arrays = {
 *        positions: [1, 2, 3],
 *        normals: [0, 0, 1],
 *     }
 *
 * returns something like
 *
 *     buffers = {
 *       positions: WebGLBuffer,
 *       normals: WebGLBuffer,
 *     }
 *
 * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.Arrays} arrays
 * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array
 * @memberOf module:twgl/attributes
 */
function createBuffersFromArrays(gl, arrays) {
  const buffers = { };
  Object.keys(arrays).forEach(function(key) {
    buffers[key] = createBufferFromArray(gl, arrays[key], key);
  });

  // Ugh!
  if (arrays.indices) {
    buffers.numElements = arrays.indices.length;
    buffers.elementType = getGLTypeForTypedArray(makeTypedArray(arrays.indices));
  } else {
    buffers.numElements = getNumElementsFromNonIndexedArrays(arrays);
  }

  return buffers;
}

var attributes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createAttribsFromArrays: createAttribsFromArrays,
  createBuffersFromArrays: createBuffersFromArrays,
  createBufferFromArray: createBufferFromArray,
  createBufferFromTypedArray: createBufferFromTypedArray,
  createBufferInfoFromArrays: createBufferInfoFromArrays,
  setAttribInfoBufferFromArray: setAttribInfoBufferFromArray,
  setAttributePrefix: setAttributePrefix,
  setAttributeDefaults_: setDefaults$2,
  getNumComponents_: getNumComponents$1,
  getArray_: getArray$1
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const getArray = getArray$1;  // eslint-disable-line
const getNumComponents = getNumComponents$1;  // eslint-disable-line

/**
 * @typedef {(Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array)} TypedArray
 */

/**
 * Add `push` to a typed array. It just keeps a 'cursor'
 * and allows use to `push` values into the array so we
 * don't have to manually compute offsets
 * @param {TypedArray} typedArray TypedArray to augment
 * @param {number} numComponents number of components.
 * @private
 */
function augmentTypedArray(typedArray, numComponents) {
  let cursor = 0;
  typedArray.push = function() {
    for (let ii = 0; ii < arguments.length; ++ii) {
      const value = arguments[ii];
      if (value instanceof Array || isArrayBuffer$1(value)) {
        for (let jj = 0; jj < value.length; ++jj) {
          typedArray[cursor++] = value[jj];
        }
      } else {
        typedArray[cursor++] = value;
      }
    }
  };
  typedArray.reset = function(opt_index) {
    cursor = opt_index || 0;
  };
  typedArray.numComponents = numComponents;
  Object.defineProperty(typedArray, 'numElements', {
    get: function() {
      return this.length / this.numComponents | 0;
    },
  });
  return typedArray;
}

/**
 * creates a typed array with a `push` function attached
 * so that you can easily *push* values.
 *
 * `push` can take multiple arguments. If an argument is an array each element
 * of the array will be added to the typed array.
 *
 * Example:
 *
 *     const array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values
 *     array.push(1, 2, 3);
 *     array.push([4, 5, 6]);
 *     // array now contains [1, 2, 3, 4, 5, 6]
 *
 * Also has `numComponents` and `numElements` properties.
 *
 * @param {number} numComponents number of components
 * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.
 * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.
 * @return {ArrayBufferView} A typed array.
 * @memberOf module:twgl/primitives
 */
function createAugmentedTypedArray(numComponents, numElements, opt_type) {
  const Type = opt_type || Float32Array;
  return augmentTypedArray(new Type(numComponents * numElements), numComponents);
}

function allButIndices(name) {
  return name !== "indices";
}

/**
 * Given indexed vertices creates a new set of vertices un-indexed by expanding the indexed vertices.
 * @param {Object.<string, TypedArray>} vertices The indexed vertices to deindex
 * @return {Object.<string, TypedArray>} The deindexed vertices
 * @memberOf module:twgl/primitives
 */
function deindexVertices(vertices) {
  const indices = vertices.indices;
  const newVertices = {};
  const numElements = indices.length;

  function expandToUnindexed(channel) {
    const srcBuffer = vertices[channel];
    const numComponents = srcBuffer.numComponents;
    const dstBuffer = createAugmentedTypedArray(numComponents, numElements, srcBuffer.constructor);
    for (let ii = 0; ii < numElements; ++ii) {
      const ndx = indices[ii];
      const offset = ndx * numComponents;
      for (let jj = 0; jj < numComponents; ++jj) {
        dstBuffer.push(srcBuffer[offset + jj]);
      }
    }
    newVertices[channel] = dstBuffer;
  }

  Object.keys(vertices).filter(allButIndices).forEach(expandToUnindexed);

  return newVertices;
}

/**
 * flattens the normals of deindexed vertices in place.
 * @param {Object.<string, TypedArray>} vertices The deindexed vertices who's normals to flatten
 * @return {Object.<string, TypedArray>} The flattened vertices (same as was passed in)
 * @memberOf module:twgl/primitives
 */
function flattenNormals(vertices) {
  if (vertices.indices) {
    throw new Error('can not flatten normals of indexed vertices. deindex them first');
  }

  const normals = vertices.normal;
  const numNormals = normals.length;
  for (let ii = 0; ii < numNormals; ii += 9) {
    // pull out the 3 normals for this triangle
    const nax = normals[ii + 0];
    const nay = normals[ii + 1];
    const naz = normals[ii + 2];

    const nbx = normals[ii + 3];
    const nby = normals[ii + 4];
    const nbz = normals[ii + 5];

    const ncx = normals[ii + 6];
    const ncy = normals[ii + 7];
    const ncz = normals[ii + 8];

    // add them
    let nx = nax + nbx + ncx;
    let ny = nay + nby + ncy;
    let nz = naz + nbz + ncz;

    // normalize them
    const length = Math.sqrt(nx * nx + ny * ny + nz * nz);

    nx /= length;
    ny /= length;
    nz /= length;

    // copy them back in
    normals[ii + 0] = nx;
    normals[ii + 1] = ny;
    normals[ii + 2] = nz;

    normals[ii + 3] = nx;
    normals[ii + 4] = ny;
    normals[ii + 5] = nz;

    normals[ii + 6] = nx;
    normals[ii + 7] = ny;
    normals[ii + 8] = nz;
  }

  return vertices;
}

function applyFuncToV3Array(array, matrix, fn) {
  const len = array.length;
  const tmp = new Float32Array(3);
  for (let ii = 0; ii < len; ii += 3) {
    fn(matrix, [array[ii], array[ii + 1], array[ii + 2]], tmp);
    array[ii    ] = tmp[0];
    array[ii + 1] = tmp[1];
    array[ii + 2] = tmp[2];
  }
}

function transformNormal(mi, v, dst) {
  dst = dst || create$1();
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];

  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];

  return dst;
}

/**
 * Reorients directions by the given matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientDirections(array, matrix) {
  applyFuncToV3Array(array, matrix, transformDirection);
  return array;
}

/**
 * Reorients normals by the inverse-transpose of the given
 * matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientNormals(array, matrix) {
  applyFuncToV3Array(array, inverse(matrix), transformNormal);
  return array;
}

/**
 * Reorients positions by the given matrix. In other words, it
 * multiplies each vertex by the given matrix.
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientPositions(array, matrix) {
  applyFuncToV3Array(array, matrix, transformPoint);
  return array;
}

/**
 * @typedef {(number[]|TypedArray)} NativeArrayOrTypedArray
 */

/**
 * Reorients arrays by the given matrix. Assumes arrays have
 * names that contains 'pos' could be reoriented as positions,
 * 'binorm' or 'tan' as directions, and 'norm' as normals.
 *
 * @param {Object.<string, NativeArrayOrTypedArray>} arrays The vertices to reorient
 * @param {module:twgl/m4.Mat4} matrix matrix to reorient by.
 * @return {Object.<string, NativeArrayOrTypedArray>} same arrays that were passed in.
 * @memberOf module:twgl/primitives
 */
function reorientVertices(arrays, matrix) {
  Object.keys(arrays).forEach(function(name) {
    const array = arrays[name];
    if (name.indexOf("pos") >= 0) {
      reorientPositions(array, matrix);
    } else if (name.indexOf("tan") >= 0 || name.indexOf("binorm") >= 0) {
      reorientDirections(array, matrix);
    } else if (name.indexOf("norm") >= 0) {
      reorientNormals(array, matrix);
    }
  });
  return arrays;
}

/**
 * Creates XY quad BufferInfo
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, WebGLBuffer>} the created XY Quad BufferInfo
 * @memberOf module:twgl/primitives
 * @function createXYQuadBuffers
 */

/**
 * Creates XY quad Buffers
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {module:twgl.BufferInfo} the created XY Quad buffers
 * @memberOf module:twgl/primitives
 * @function createXYQuadBufferInfo
 */

/**
 * Creates XY quad vertices
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0, 0.5);
 *
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, TypedArray>} the created XY Quad vertices
 * @memberOf module:twgl/primitives
 */
function createXYQuadVertices(size, xOffset, yOffset) {
  size = size || 2;
  xOffset = xOffset || 0;
  yOffset = yOffset || 0;
  size *= 0.5;
  return {
    position: {
      numComponents: 2,
      data: [
        xOffset + -1 * size, yOffset + -1 * size,
        xOffset +  1 * size, yOffset + -1 * size,
        xOffset + -1 * size, yOffset +  1 * size,
        xOffset +  1 * size, yOffset +  1 * size,
      ],
    },
    normal: [
      0, 0, 1,
      0, 0, 1,
      0, 0, 1,
      0, 0, 1,
    ],
    texcoord: [
      0, 0,
      1, 0,
      0, 1,
      1, 1,
    ],
    indices: [ 0, 1, 2, 2, 1, 3 ],
  };
}

/**
 * Creates XZ plane BufferInfo.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {module:twgl.BufferInfo} The created plane BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createPlaneBufferInfo
 */

/**
 * Creates XZ plane buffers.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, WebGLBuffer>} The created plane buffers.
 * @memberOf module:twgl/primitives
 * @function createPlaneBuffers
 */

/**
 * Creates XZ plane vertices.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, TypedArray>} The created plane vertices.
 * @memberOf module:twgl/primitives
 */
function createPlaneVertices(
    width,
    depth,
    subdivisionsWidth,
    subdivisionsDepth,
    matrix) {
  width = width || 1;
  depth = depth || 1;
  subdivisionsWidth = subdivisionsWidth || 1;
  subdivisionsDepth = subdivisionsDepth || 1;
  matrix = matrix || identity();

  const numVertices = (subdivisionsWidth + 1) * (subdivisionsDepth + 1);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);

  for (let z = 0; z <= subdivisionsDepth; z++) {
    for (let x = 0; x <= subdivisionsWidth; x++) {
      const u = x / subdivisionsWidth;
      const v = z / subdivisionsDepth;
      positions.push(
          width * u - width * 0.5,
          0,
          depth * v - depth * 0.5);
      normals.push(0, 1, 0);
      texcoords.push(u, v);
    }
  }

  const numVertsAcross = subdivisionsWidth + 1;
  const indices = createAugmentedTypedArray(
      3, subdivisionsWidth * subdivisionsDepth * 2, Uint16Array);

  for (let z = 0; z < subdivisionsDepth; z++) {  // eslint-disable-line
    for (let x = 0; x < subdivisionsWidth; x++) {  // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push(
          (z + 0) * numVertsAcross + x,
          (z + 1) * numVertsAcross + x,
          (z + 0) * numVertsAcross + x + 1);

      // Make triangle 2 of quad.
      indices.push(
          (z + 1) * numVertsAcross + x,
          (z + 1) * numVertsAcross + x + 1,
          (z + 0) * numVertsAcross + x + 1);
    }
  }

  const arrays = reorientVertices({
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  }, matrix);
  return arrays;
}

/**
 * Creates sphere BufferInfo.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {module:twgl.BufferInfo} The created sphere BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createSphereBufferInfo
 */

/**
 * Creates sphere buffers.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, WebGLBuffer>} The created sphere buffers.
 * @memberOf module:twgl/primitives
 * @function createSphereBuffers
 */

/**
 * Creates sphere vertices.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, TypedArray>} The created sphere vertices.
 * @memberOf module:twgl/primitives
 */
function createSphereVertices(
    radius,
    subdivisionsAxis,
    subdivisionsHeight,
    opt_startLatitudeInRadians,
    opt_endLatitudeInRadians,
    opt_startLongitudeInRadians,
    opt_endLongitudeInRadians) {
  if (subdivisionsAxis <= 0 || subdivisionsHeight <= 0) {
    throw new Error('subdivisionAxis and subdivisionHeight must be > 0');
  }

  opt_startLatitudeInRadians = opt_startLatitudeInRadians || 0;
  opt_endLatitudeInRadians = opt_endLatitudeInRadians || Math.PI;
  opt_startLongitudeInRadians = opt_startLongitudeInRadians || 0;
  opt_endLongitudeInRadians = opt_endLongitudeInRadians || (Math.PI * 2);

  const latRange = opt_endLatitudeInRadians - opt_startLatitudeInRadians;
  const longRange = opt_endLongitudeInRadians - opt_startLongitudeInRadians;

  // We are going to generate our sphere by iterating through its
  // spherical coordinates and generating 2 triangles for each quad on a
  // ring of the sphere.
  const numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals   = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);

  // Generate the individual vertices in our vertex buffer.
  for (let y = 0; y <= subdivisionsHeight; y++) {
    for (let x = 0; x <= subdivisionsAxis; x++) {
      // Generate a vertex based on its spherical coordinates
      const u = x / subdivisionsAxis;
      const v = y / subdivisionsHeight;
      const theta = longRange * u + opt_startLongitudeInRadians;
      const phi = latRange * v + opt_startLatitudeInRadians;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      positions.push(radius * ux, radius * uy, radius * uz);
      normals.push(ux, uy, uz);
      texcoords.push(1 - u, v);
    }
  }

  const numVertsAround = subdivisionsAxis + 1;
  const indices = createAugmentedTypedArray(3, subdivisionsAxis * subdivisionsHeight * 2, Uint16Array);
  for (let x = 0; x < subdivisionsAxis; x++) {  // eslint-disable-line
    for (let y = 0; y < subdivisionsHeight; y++) {  // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push(
          (y + 0) * numVertsAround + x,
          (y + 0) * numVertsAround + x + 1,
          (y + 1) * numVertsAround + x);

      // Make triangle 2 of quad.
      indices.push(
          (y + 1) * numVertsAround + x,
          (y + 0) * numVertsAround + x + 1,
          (y + 1) * numVertsAround + x + 1);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  };
}

/**
 * Array of the indices of corners of each face of a cube.
 * @type {Array.<number[]>}
 * @private
 */
const CUBE_FACE_INDICES = [
  [3, 7, 5, 1],  // right
  [6, 2, 0, 4],  // left
  [6, 7, 3, 2],  // ??
  [0, 1, 5, 4],  // ??
  [7, 6, 4, 5],  // front
  [2, 3, 1, 0],  // back
];

/**
 * Creates a BufferInfo for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCubeBufferInfo
 */

/**
 * Creates the buffers and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCubeBuffers
 */

/**
 * Creates the vertices and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createCubeVertices(size) {
  size = size || 1;
  const k = size / 2;

  const cornerVertices = [
    [-k, -k, -k],
    [+k, -k, -k],
    [-k, +k, -k],
    [+k, +k, -k],
    [-k, -k, +k],
    [+k, -k, +k],
    [-k, +k, +k],
    [+k, +k, +k],
  ];

  const faceNormals = [
    [+1, +0, +0],
    [-1, +0, +0],
    [+0, +1, +0],
    [+0, -1, +0],
    [+0, +0, +1],
    [+0, +0, -1],
  ];

  const uvCoords = [
    [1, 0],
    [0, 0],
    [0, 1],
    [1, 1],
  ];

  const numVertices = 6 * 4;
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals   = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2 , numVertices);
  const indices   = createAugmentedTypedArray(3, 6 * 2, Uint16Array);

  for (let f = 0; f < 6; ++f) {
    const faceIndices = CUBE_FACE_INDICES[f];
    for (let v = 0; v < 4; ++v) {
      const position = cornerVertices[faceIndices[v]];
      const normal = faceNormals[f];
      const uv = uvCoords[v];

      // Each face needs all four vertices because the normals and texture
      // coordinates are not all the same.
      positions.push(position);
      normals.push(normal);
      texcoords.push(uv);

    }
    // Two triangles make a square face.
    const offset = 4 * f;
    indices.push(offset + 0, offset + 1, offset + 2);
    indices.push(offset + 0, offset + 2, offset + 3);
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  };
}

/**
 * Creates a BufferInfo for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created cone BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBufferInfo
 */

/**
 * Creates buffers for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created cone buffers.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBuffers
 */

/**
 * Creates vertices for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis. .
 *
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created cone vertices.
 * @memberOf module:twgl/primitives
 */
function createTruncatedConeVertices(
    bottomRadius,
    topRadius,
    height,
    radialSubdivisions,
    verticalSubdivisions,
    opt_topCap,
    opt_bottomCap) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }

  if (verticalSubdivisions < 1) {
    throw new Error('verticalSubdivisions must be 1 or greater');
  }

  const topCap = (opt_topCap === undefined) ? true : opt_topCap;
  const bottomCap = (opt_bottomCap === undefined) ? true : opt_bottomCap;

  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);

  const numVertices = (radialSubdivisions + 1) * (verticalSubdivisions + 1 + extra);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals   = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  const indices   = createAugmentedTypedArray(3, radialSubdivisions * (verticalSubdivisions + extra / 2) * 2, Uint16Array);

  const vertsAroundEdge = radialSubdivisions + 1;

  // The slant of the cone is constant across its surface
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const cosSlant = Math.cos(slant);
  const sinSlant = Math.sin(slant);

  const start = topCap ? -2 : 0;
  const end = verticalSubdivisions + (bottomCap ? 2 : 0);

  for (let yy = start; yy <= end; ++yy) {
    let v = yy / verticalSubdivisions;
    let y = height * v;
    let ringRadius;
    if (yy < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (yy > verticalSubdivisions) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius +
        (topRadius - bottomRadius) * (yy / verticalSubdivisions);
    }
    if (yy === -2 || yy === verticalSubdivisions + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let ii = 0; ii < vertsAroundEdge; ++ii) {
      const sin = Math.sin(ii * Math.PI * 2 / radialSubdivisions);
      const cos = Math.cos(ii * Math.PI * 2 / radialSubdivisions);
      positions.push(sin * ringRadius, y, cos * ringRadius);
      if (yy < 0) {
        normals.push(0, -1, 0);
      } else if (yy > verticalSubdivisions) {
        normals.push(0, 1, 0);
      } else if (ringRadius === 0.0) {
        normals.push(0, 0, 0);
      } else {
        normals.push(sin * cosSlant, sinSlant, cos * cosSlant);
      }
      texcoords.push((ii / radialSubdivisions), 1 - v);
    }
  }

  for (let yy = 0; yy < verticalSubdivisions + extra; ++yy) {  // eslint-disable-line
    if (yy === 1 && topCap || yy === verticalSubdivisions + extra - 2 && bottomCap) {
      continue;
    }
    for (let ii = 0; ii < radialSubdivisions; ++ii) {  // eslint-disable-line
      indices.push(vertsAroundEdge * (yy + 0) + 0 + ii,
                   vertsAroundEdge * (yy + 0) + 1 + ii,
                   vertsAroundEdge * (yy + 1) + 1 + ii);
      indices.push(vertsAroundEdge * (yy + 0) + 0 + ii,
                   vertsAroundEdge * (yy + 1) + 1 + ii,
                   vertsAroundEdge * (yy + 1) + 0 + ii);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  };
}

/**
 * Expands RLE data
 * @param {number[]} rleData data in format of run-length, x, y, z, run-length, x, y, z
 * @param {number[]} [padding] value to add each entry with.
 * @return {number[]} the expanded rleData
 * @private
 */
function expandRLEData(rleData, padding) {
  padding = padding || [];
  const data = [];
  for (let ii = 0; ii < rleData.length; ii += 4) {
    const runLength = rleData[ii];
    const element = rleData.slice(ii + 1, ii + 4);
    element.push.apply(element, padding);
    for (let jj = 0; jj < runLength; ++jj) {
      data.push.apply(data, element);
    }
  }
  return data;
}

/**
 * Creates 3D 'F' BufferInfo.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function create3DFBufferInfo
 */

/**
 * Creates 3D 'F' buffers.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function create3DFBuffers
 */

/**
 * Creates 3D 'F' vertices.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color arrays.
 *
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function create3DFVertices() {

  const positions = [
    // left column front
    0,   0,  0,
    0, 150,  0,
    30,   0,  0,
    0, 150,  0,
    30, 150,  0,
    30,   0,  0,

    // top rung front
    30,   0,  0,
    30,  30,  0,
    100,   0,  0,
    30,  30,  0,
    100,  30,  0,
    100,   0,  0,

    // middle rung front
    30,  60,  0,
    30,  90,  0,
    67,  60,  0,
    30,  90,  0,
    67,  90,  0,
    67,  60,  0,

    // left column back
      0,   0,  30,
     30,   0,  30,
      0, 150,  30,
      0, 150,  30,
     30,   0,  30,
     30, 150,  30,

    // top rung back
     30,   0,  30,
    100,   0,  30,
     30,  30,  30,
     30,  30,  30,
    100,   0,  30,
    100,  30,  30,

    // middle rung back
     30,  60,  30,
     67,  60,  30,
     30,  90,  30,
     30,  90,  30,
     67,  60,  30,
     67,  90,  30,

    // top
      0,   0,   0,
    100,   0,   0,
    100,   0,  30,
      0,   0,   0,
    100,   0,  30,
      0,   0,  30,

    // top rung front
    100,   0,   0,
    100,  30,   0,
    100,  30,  30,
    100,   0,   0,
    100,  30,  30,
    100,   0,  30,

    // under top rung
    30,   30,   0,
    30,   30,  30,
    100,  30,  30,
    30,   30,   0,
    100,  30,  30,
    100,  30,   0,

    // between top rung and middle
    30,   30,   0,
    30,   60,  30,
    30,   30,  30,
    30,   30,   0,
    30,   60,   0,
    30,   60,  30,

    // top of middle rung
    30,   60,   0,
    67,   60,  30,
    30,   60,  30,
    30,   60,   0,
    67,   60,   0,
    67,   60,  30,

    // front of middle rung
    67,   60,   0,
    67,   90,  30,
    67,   60,  30,
    67,   60,   0,
    67,   90,   0,
    67,   90,  30,

    // bottom of middle rung.
    30,   90,   0,
    30,   90,  30,
    67,   90,  30,
    30,   90,   0,
    67,   90,  30,
    67,   90,   0,

    // front of bottom
    30,   90,   0,
    30,  150,  30,
    30,   90,  30,
    30,   90,   0,
    30,  150,   0,
    30,  150,  30,

    // bottom
    0,   150,   0,
    0,   150,  30,
    30,  150,  30,
    0,   150,   0,
    30,  150,  30,
    30,  150,   0,

    // left side
    0,   0,   0,
    0,   0,  30,
    0, 150,  30,
    0,   0,   0,
    0, 150,  30,
    0, 150,   0,
  ];

  const texcoords = [
    // left column front
    0.22, 0.19,
    0.22, 0.79,
    0.34, 0.19,
    0.22, 0.79,
    0.34, 0.79,
    0.34, 0.19,

    // top rung front
    0.34, 0.19,
    0.34, 0.31,
    0.62, 0.19,
    0.34, 0.31,
    0.62, 0.31,
    0.62, 0.19,

    // middle rung front
    0.34, 0.43,
    0.34, 0.55,
    0.49, 0.43,
    0.34, 0.55,
    0.49, 0.55,
    0.49, 0.43,

    // left column back
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1,

    // top rung back
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1,

    // middle rung back
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1,

    // top
    0, 0,
    1, 0,
    1, 1,
    0, 0,
    1, 1,
    0, 1,

    // top rung front
    0, 0,
    1, 0,
    1, 1,
    0, 0,
    1, 1,
    0, 1,

    // under top rung
    0, 0,
    0, 1,
    1, 1,
    0, 0,
    1, 1,
    1, 0,

    // between top rung and middle
    0, 0,
    1, 1,
    0, 1,
    0, 0,
    1, 0,
    1, 1,

    // top of middle rung
    0, 0,
    1, 1,
    0, 1,
    0, 0,
    1, 0,
    1, 1,

    // front of middle rung
    0, 0,
    1, 1,
    0, 1,
    0, 0,
    1, 0,
    1, 1,

    // bottom of middle rung.
    0, 0,
    0, 1,
    1, 1,
    0, 0,
    1, 1,
    1, 0,

    // front of bottom
    0, 0,
    1, 1,
    0, 1,
    0, 0,
    1, 0,
    1, 1,

    // bottom
    0, 0,
    0, 1,
    1, 1,
    0, 0,
    1, 1,
    1, 0,

    // left side
    0, 0,
    0, 1,
    1, 1,
    0, 0,
    1, 1,
    1, 0,
  ];

  const normals = expandRLEData([
    // left column front
    // top rung front
    // middle rung front
    18, 0, 0, 1,

    // left column back
    // top rung back
    // middle rung back
    18, 0, 0, -1,

    // top
    6, 0, 1, 0,

    // top rung front
    6, 1, 0, 0,

    // under top rung
    6, 0, -1, 0,

    // between top rung and middle
    6, 1, 0, 0,

    // top of middle rung
    6, 0, 1, 0,

    // front of middle rung
    6, 1, 0, 0,

    // bottom of middle rung.
    6, 0, -1, 0,

    // front of bottom
    6, 1, 0, 0,

    // bottom
    6, 0, -1, 0,

    // left side
    6, -1, 0, 0,
  ]);

  const colors = expandRLEData([
        // left column front
        // top rung front
        // middle rung front
      18, 200,  70, 120,

        // left column back
        // top rung back
        // middle rung back
      18, 80, 70, 200,

        // top
      6, 70, 200, 210,

        // top rung front
      6, 200, 200, 70,

        // under top rung
      6, 210, 100, 70,

        // between top rung and middle
      6, 210, 160, 70,

        // top of middle rung
      6, 70, 180, 210,

        // front of middle rung
      6, 100, 70, 210,

        // bottom of middle rung.
      6, 76, 210, 100,

        // front of bottom
      6, 140, 210, 80,

        // bottom
      6, 90, 130, 110,

        // left side
      6, 160, 160, 220,
  ], [255]);

  const numVerts = positions.length / 3;

  const arrays = {
    position: createAugmentedTypedArray(3, numVerts),
    texcoord: createAugmentedTypedArray(2,  numVerts),
    normal: createAugmentedTypedArray(3, numVerts),
    color: createAugmentedTypedArray(4, numVerts, Uint8Array),
    indices: createAugmentedTypedArray(3, numVerts / 3, Uint16Array),
  };

  arrays.position.push(positions);
  arrays.texcoord.push(texcoords);
  arrays.normal.push(normals);
  arrays.color.push(colors);

  for (let ii = 0; ii < numVerts; ++ii) {
    arrays.indices.push(ii);
  }

  return arrays;
}

/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCresentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCrescentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCrescentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
 function createCrescentVertices(
    verticalRadius,
    outerRadius,
    innerRadius,
    thickness,
    subdivisionsDown,
    startOffset,
    endOffset) {
  if (subdivisionsDown <= 0) {
    throw new Error('subdivisionDown must be > 0');
  }

  startOffset = startOffset || 0;
  endOffset   = endOffset || 1;

  const subdivisionsThick = 2;

  const offsetRange = endOffset - startOffset;
  const numVertices = (subdivisionsDown + 1) * 2 * (2 + subdivisionsThick);
  const positions   = createAugmentedTypedArray(3, numVertices);
  const normals     = createAugmentedTypedArray(3, numVertices);
  const texcoords   = createAugmentedTypedArray(2, numVertices);

  function lerp(a, b, s) {
    return a + (b - a) * s;
  }

  function createArc(arcRadius, x, normalMult, normalAdd, uMult, uAdd) {
    for (let z = 0; z <= subdivisionsDown; z++) {
      const uBack = x / (subdivisionsThick - 1);
      const v = z / subdivisionsDown;
      const xBack = (uBack - 0.5) * 2;
      const angle = (startOffset + (v * offsetRange)) * Math.PI;
      const s = Math.sin(angle);
      const c = Math.cos(angle);
      const radius = lerp(verticalRadius, arcRadius, s);
      const px = xBack * thickness;
      const py = c * verticalRadius;
      const pz = s * radius;
      positions.push(px, py, pz);
      const n = add(multiply$1([0, s, c], normalMult), normalAdd);
      normals.push(n);
      texcoords.push(uBack * uMult + uAdd, v);
    }
  }

  // Generate the individual vertices in our vertex buffer.
  for (let x = 0; x < subdivisionsThick; x++) {
    const uBack = (x / (subdivisionsThick - 1) - 0.5) * 2;
    createArc(outerRadius, x, [1, 1, 1], [0,     0, 0], 1, 0);
    createArc(outerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 0);
    createArc(innerRadius, x, [1, 1, 1], [0,     0, 0], 1, 0);
    createArc(innerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 1);
  }

  // Do outer surface.
  const indices = createAugmentedTypedArray(3, (subdivisionsDown * 2) * (2 + subdivisionsThick), Uint16Array);

  function createSurface(leftArcOffset, rightArcOffset) {
    for (let z = 0; z < subdivisionsDown; ++z) {
      // Make triangle 1 of quad.
      indices.push(
          leftArcOffset + z + 0,
          leftArcOffset + z + 1,
          rightArcOffset + z + 0);

      // Make triangle 2 of quad.
      indices.push(
          leftArcOffset + z + 1,
          rightArcOffset + z + 1,
          rightArcOffset + z + 0);
    }
  }

  const numVerticesDown = subdivisionsDown + 1;
  // front
  createSurface(numVerticesDown * 0, numVerticesDown * 4);
  // right
  createSurface(numVerticesDown * 5, numVerticesDown * 7);
  // back
  createSurface(numVerticesDown * 6, numVerticesDown * 2);
  // left
  createSurface(numVerticesDown * 3, numVerticesDown * 1);

  return {
    position: positions,
    normal:   normals,
    texcoord: texcoords,
    indices:  indices,
  };
}

/**
 * Creates cylinder BufferInfo. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCylinderBufferInfo
 */

 /**
  * Creates cylinder buffers. The cylinder will be created around the origin
  * along the y-axis.
  *
  * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
  * @param {number} radius Radius of cylinder.
  * @param {number} height Height of cylinder.
  * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
  * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
  * @param {boolean} [topCap] Create top cap. Default = true.
  * @param {boolean} [bottomCap] Create bottom cap. Default = true.
  * @return {Object.<string, WebGLBuffer>} The created buffers.
  * @memberOf module:twgl/primitives
  * @function createCylinderBuffers
  */

 /**
  * Creates cylinder vertices. The cylinder will be created around the origin
  * along the y-axis.
  *
  * @param {number} radius Radius of cylinder.
  * @param {number} height Height of cylinder.
  * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
  * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
  * @param {boolean} [topCap] Create top cap. Default = true.
  * @param {boolean} [bottomCap] Create bottom cap. Default = true.
  * @return {Object.<string, TypedArray>} The created vertices.
  * @memberOf module:twgl/primitives
  */
function createCylinderVertices(
    radius,
    height,
    radialSubdivisions,
    verticalSubdivisions,
    topCap,
    bottomCap) {
  return createTruncatedConeVertices(
      radius,
      radius,
      height,
      radialSubdivisions,
      verticalSubdivisions,
      topCap,
      bottomCap);
}

/**
 * Creates BufferInfo for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTorusBufferInfo
 */

/**
 * Creates buffers for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createTorusBuffers
 */

/**
 * Creates vertices for a torus
 *
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createTorusVertices(
    radius,
    thickness,
    radialSubdivisions,
    bodySubdivisions,
    startAngle,
    endAngle) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }

  if (bodySubdivisions < 3) {
    throw new Error('verticalSubdivisions must be 3 or greater');
  }

  startAngle = startAngle || 0;
  endAngle = endAngle || Math.PI * 2;
  const range = endAngle - startAngle;

  const radialParts = radialSubdivisions + 1;
  const bodyParts   = bodySubdivisions + 1;
  const numVertices = radialParts * bodyParts;
  const positions   = createAugmentedTypedArray(3, numVertices);
  const normals     = createAugmentedTypedArray(3, numVertices);
  const texcoords   = createAugmentedTypedArray(2, numVertices);
  const indices     = createAugmentedTypedArray(3, (radialSubdivisions) * (bodySubdivisions) * 2, Uint16Array);

  for (let slice = 0; slice < bodyParts; ++slice) {
    const v = slice / bodySubdivisions;
    const sliceAngle = v * Math.PI * 2;
    const sliceSin = Math.sin(sliceAngle);
    const ringRadius = radius + sliceSin * thickness;
    const ny = Math.cos(sliceAngle);
    const y = ny * thickness;
    for (let ring = 0; ring < radialParts; ++ring) {
      const u = ring / radialSubdivisions;
      const ringAngle = startAngle + u * range;
      const xSin = Math.sin(ringAngle);
      const zCos = Math.cos(ringAngle);
      const x = xSin * ringRadius;
      const z = zCos * ringRadius;
      const nx = xSin * sliceSin;
      const nz = zCos * sliceSin;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      texcoords.push(u, 1 - v);
    }
  }

  for (let slice = 0; slice < bodySubdivisions; ++slice) {  // eslint-disable-line
    for (let ring = 0; ring < radialSubdivisions; ++ring) {  // eslint-disable-line
      const nextRingIndex  = 1 + ring;
      const nextSliceIndex = 1 + slice;
      indices.push(radialParts * slice          + ring,
                   radialParts * nextSliceIndex + ring,
                   radialParts * slice          + nextRingIndex);
      indices.push(radialParts * nextSliceIndex + ring,
                   radialParts * nextSliceIndex + nextRingIndex,
                   radialParts * slice          + nextRingIndex);
    }
  }

  return {
    position: positions,
    normal:   normals,
    texcoord: texcoords,
    indices:  indices,
  };
}


/**
 * Creates a disc BufferInfo. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createDiscBufferInfo
 */

/**
 * Creates disc buffers. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createDiscBuffers
 */

/**
 * Creates disc vertices. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createDiscVertices(
    radius,
    divisions,
    stacks,
    innerRadius,
    stackPower) {
  if (divisions < 3) {
    throw new Error('divisions must be at least 3');
  }

  stacks = stacks ? stacks : 1;
  stackPower = stackPower ? stackPower : 1;
  innerRadius = innerRadius ? innerRadius : 0;

  // Note: We don't share the center vertex because that would
  // mess up texture coordinates.
  const numVertices = (divisions + 1) * (stacks + 1);

  const positions = createAugmentedTypedArray(3, numVertices);
  const normals   = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  const indices   = createAugmentedTypedArray(3, stacks * divisions * 2, Uint16Array);

  let firstIndex = 0;
  const radiusSpan = radius - innerRadius;
  const pointsPerStack = divisions + 1;

  // Build the disk one stack at a time.
  for (let stack = 0; stack <= stacks; ++stack) {
    const stackRadius = innerRadius + radiusSpan * Math.pow(stack / stacks, stackPower);

    for (let i = 0; i <= divisions; ++i) {
      const theta = 2.0 * Math.PI * i / divisions;
      const x = stackRadius * Math.cos(theta);
      const z = stackRadius * Math.sin(theta);

      positions.push(x, 0, z);
      normals.push(0, 1, 0);
      texcoords.push(1 - (i / divisions), stack / stacks);
      if (stack > 0 && i !== divisions) {
        // a, b, c and d are the indices of the vertices of a quad.  unless
        // the current stack is the one closest to the center, in which case
        // the vertices a and b connect to the center vertex.
        const a = firstIndex + (i + 1);
        const b = firstIndex + i;
        const c = firstIndex + i - pointsPerStack;
        const d = firstIndex + (i + 1) - pointsPerStack;

        // Make a quad of the vertices a, b, c, d.
        indices.push(a, b, c);
        indices.push(a, c, d);
      }
    }

    firstIndex += divisions + 1;
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  };
}

/**
 * creates a random integer between 0 and range - 1 inclusive.
 * @param {number} range
 * @return {number} random value between 0 and range - 1 inclusive.
 * @private
 */
function randInt(range) {
  return Math.random() * range | 0;
}

/**
 * Used to supply random colors
 * @callback RandomColorFunc
 * @param {number} ndx index of triangle/quad if unindexed or index of vertex if indexed
 * @param {number} channel 0 = red, 1 = green, 2 = blue, 3 = alpha
 * @return {number} a number from 0 to 255
 * @memberOf module:twgl/primitives
 */

/**
 * @typedef {Object} RandomVerticesOptions
 * @property {number} [vertsPerColor] Defaults to 3 for non-indexed vertices
 * @property {module:twgl/primitives.RandomColorFunc} [rand] A function to generate random numbers
 * @memberOf module:twgl/primitives
 */

/**
 * Creates an augmentedTypedArray of random vertex colors.
 * If the vertices are indexed (have an indices array) then will
 * just make random colors. Otherwise assumes they are triangles
 * and makes one random color for every 3 vertices.
 * @param {Object.<string, AugmentedTypedArray>} vertices Vertices as returned from one of the createXXXVertices functions.
 * @param {module:twgl/primitives.RandomVerticesOptions} [options] options.
 * @return {Object.<string, AugmentedTypedArray>} same vertices as passed in with `color` added.
 * @memberOf module:twgl/primitives
 */
function makeRandomVertexColors(vertices, options) {
  options = options || {};
  const numElements = vertices.position.numElements;
  const vColors = createAugmentedTypedArray(4, numElements, Uint8Array);
  const rand = options.rand || function(ndx, channel) {
    return channel < 3 ? randInt(256) : 255;
  };
  vertices.color = vColors;
  if (vertices.indices) {
    // just make random colors if index
    for (let ii = 0; ii < numElements; ++ii) {
      vColors.push(rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3));
    }
  } else {
    // make random colors per triangle
    const numVertsPerColor = options.vertsPerColor || 3;
    const numSets = numElements / numVertsPerColor;
    for (let ii = 0; ii < numSets; ++ii) {  // eslint-disable-line
      const color = [rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3)];
      for (let jj = 0; jj < numVertsPerColor; ++jj) {
        vColors.push(color);
      }
    }
  }
  return vertices;
}

/**
 * creates a function that calls fn to create vertices and then
 * creates a buffers for them
 * @private
 */
function createBufferFunc(fn) {
  return function(gl) {
    const arrays = fn.apply(this, Array.prototype.slice.call(arguments, 1));
    return createBuffersFromArrays(gl, arrays);
  };
}

/**
 * creates a function that calls fn to create vertices and then
 * creates a bufferInfo object for them
 * @private
 */
function createBufferInfoFunc(fn) {
  return function(gl) {
    const arrays = fn.apply(null,  Array.prototype.slice.call(arguments, 1));
    return createBufferInfoFromArrays(gl, arrays);
  };
}

const arraySpecPropertyNames = [
  "numComponents",
  "size",
  "type",
  "normalize",
  "stride",
  "offset",
  "attrib",
  "name",
  "attribName",
];

/**
 * Copy elements from one array to another
 *
 * @param {Array|TypedArray} src source array
 * @param {Array|TypedArray} dst dest array
 * @param {number} dstNdx index in dest to copy src
 * @param {number} [offset] offset to add to copied values
 * @private
 */
function copyElements(src, dst, dstNdx, offset) {
  offset = offset || 0;
  const length = src.length;
  for (let ii = 0; ii < length; ++ii) {
    dst[dstNdx + ii] = src[ii] + offset;
  }
}

/**
 * Creates an array of the same time
 *
 * @param {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} srcArray array who's type to copy
 * @param {number} length size of new array
 * @return {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} array with same type as srcArray
 * @private
 */
function createArrayOfSameType(srcArray, length) {
  const arraySrc = getArray(srcArray);
  const newArray = new arraySrc.constructor(length);
  let newArraySpec = newArray;
  // If it appears to have been augmented make new one augmented
  if (arraySrc.numComponents && arraySrc.numElements) {
    augmentTypedArray(newArray, arraySrc.numComponents);
  }
  // If it was a full spec make new one a full spec
  if (srcArray.data) {
    newArraySpec = {
      data: newArray,
    };
    copyNamedProperties(arraySpecPropertyNames, srcArray, newArraySpec);
  }
  return newArraySpec;
}

/**
 * Concatenates sets of vertices
 *
 * Assumes the vertices match in composition. For example
 * if one set of vertices has positions, normals, and indices
 * all sets of vertices must have positions, normals, and indices
 * and of the same type.
 *
 * Example:
 *
 *      const cubeVertices = twgl.primitives.createCubeVertices(2);
 *      const sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);
 *      // move the sphere 2 units up
 *      twgl.primitives.reorientVertices(
 *          sphereVertices, twgl.m4.translation([0, 2, 0]));
 *      // merge the sphere with the cube
 *      const cubeSphereVertices = twgl.primitives.concatVertices(
 *          [cubeVertices, sphereVertices]);
 *      // turn them into WebGL buffers and attrib data
 *      const bufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);
 *
 * @param {module:twgl.Arrays[]} arrays Array of arrays of vertices
 * @return {module:twgl.Arrays} The concatenated vertices.
 * @memberOf module:twgl/primitives
 */
function concatVertices(arrayOfArrays) {
  const names = {};
  let baseName;
  // get names of all arrays.
  // and numElements for each set of vertices
  for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
    const arrays = arrayOfArrays[ii];
    Object.keys(arrays).forEach(function(name) {  // eslint-disable-line
      if (!names[name]) {
        names[name] = [];
      }
      if (!baseName && name !== 'indices') {
        baseName = name;
      }
      const arrayInfo = arrays[name];
      const numComponents = getNumComponents(arrayInfo, name);
      const array = getArray(arrayInfo);
      const numElements = array.length / numComponents;
      names[name].push(numElements);
    });
  }

  // compute length of combined array
  // and return one for reference
  function getLengthOfCombinedArrays(name) {
    let length = 0;
    let arraySpec;
    for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
      const arrays = arrayOfArrays[ii];
      const arrayInfo = arrays[name];
      const array = getArray(arrayInfo);
      length += array.length;
      if (!arraySpec || arrayInfo.data) {
        arraySpec = arrayInfo;
      }
    }
    return {
      length: length,
      spec: arraySpec,
    };
  }

  function copyArraysToNewArray(name, base, newArray) {
    let baseIndex = 0;
    let offset = 0;
    for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
      const arrays = arrayOfArrays[ii];
      const arrayInfo = arrays[name];
      const array = getArray(arrayInfo);
      if (name === 'indices') {
        copyElements(array, newArray, offset, baseIndex);
        baseIndex += base[ii];
      } else {
        copyElements(array, newArray, offset);
      }
      offset += array.length;
    }
  }

  const base = names[baseName];

  const newArrays = {};
  Object.keys(names).forEach(function(name) {
    const info = getLengthOfCombinedArrays(name);
    const newArraySpec = createArrayOfSameType(info.spec, info.length);
    copyArraysToNewArray(name, base, getArray(newArraySpec));
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}

/**
 * Creates a duplicate set of vertices
 *
 * This is useful for calling reorientVertices when you
 * also want to keep the original available
 *
 * @param {module:twgl.Arrays} arrays of vertices
 * @return {module:twgl.Arrays} The duplicated vertices.
 * @memberOf module:twgl/primitives
 */
function duplicateVertices(arrays) {
  const newArrays = {};
  Object.keys(arrays).forEach(function(name) {
    const arraySpec = arrays[name];
    const srcArray = getArray(arraySpec);
    const newArraySpec = createArrayOfSameType(arraySpec, srcArray.length);
    copyElements(srcArray, getArray(newArraySpec), 0);
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}

const create3DFBufferInfo = createBufferInfoFunc(create3DFVertices);
const create3DFBuffers = createBufferFunc(create3DFVertices);
const createCubeBufferInfo = createBufferInfoFunc(createCubeVertices);
const createCubeBuffers = createBufferFunc(createCubeVertices);
const createPlaneBufferInfo = createBufferInfoFunc(createPlaneVertices);
const createPlaneBuffers = createBufferFunc(createPlaneVertices);
const createSphereBufferInfo = createBufferInfoFunc(createSphereVertices);
const createSphereBuffers = createBufferFunc(createSphereVertices);
const createTruncatedConeBufferInfo = createBufferInfoFunc(createTruncatedConeVertices);
const createTruncatedConeBuffers = createBufferFunc(createTruncatedConeVertices);
const createXYQuadBufferInfo = createBufferInfoFunc(createXYQuadVertices);
const createXYQuadBuffers = createBufferFunc(createXYQuadVertices);
const createCrescentBufferInfo = createBufferInfoFunc(createCrescentVertices);
const createCrescentBuffers = createBufferFunc(createCrescentVertices);
const createCylinderBufferInfo = createBufferInfoFunc(createCylinderVertices);
const createCylinderBuffers = createBufferFunc(createCylinderVertices);
const createTorusBufferInfo = createBufferInfoFunc(createTorusVertices);
const createTorusBuffers = createBufferFunc(createTorusVertices);
const createDiscBufferInfo = createBufferInfoFunc(createDiscVertices);
const createDiscBuffers = createBufferFunc(createDiscVertices);

// these were mis-spelled until 4.12
const createCresentBufferInfo = createCrescentBufferInfo;
const createCresentBuffers = createCrescentBuffers;
const createCresentVertices = createCrescentVertices;

var primitives = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create3DFBufferInfo: create3DFBufferInfo,
  create3DFBuffers: create3DFBuffers,
  create3DFVertices: create3DFVertices,
  createAugmentedTypedArray: createAugmentedTypedArray,
  createCubeBufferInfo: createCubeBufferInfo,
  createCubeBuffers: createCubeBuffers,
  createCubeVertices: createCubeVertices,
  createPlaneBufferInfo: createPlaneBufferInfo,
  createPlaneBuffers: createPlaneBuffers,
  createPlaneVertices: createPlaneVertices,
  createSphereBufferInfo: createSphereBufferInfo,
  createSphereBuffers: createSphereBuffers,
  createSphereVertices: createSphereVertices,
  createTruncatedConeBufferInfo: createTruncatedConeBufferInfo,
  createTruncatedConeBuffers: createTruncatedConeBuffers,
  createTruncatedConeVertices: createTruncatedConeVertices,
  createXYQuadBufferInfo: createXYQuadBufferInfo,
  createXYQuadBuffers: createXYQuadBuffers,
  createXYQuadVertices: createXYQuadVertices,
  createCresentBufferInfo: createCresentBufferInfo,
  createCresentBuffers: createCresentBuffers,
  createCresentVertices: createCresentVertices,
  createCrescentBufferInfo: createCrescentBufferInfo,
  createCrescentBuffers: createCrescentBuffers,
  createCrescentVertices: createCrescentVertices,
  createCylinderBufferInfo: createCylinderBufferInfo,
  createCylinderBuffers: createCylinderBuffers,
  createCylinderVertices: createCylinderVertices,
  createTorusBufferInfo: createTorusBufferInfo,
  createTorusBuffers: createTorusBuffers,
  createTorusVertices: createTorusVertices,
  createDiscBufferInfo: createDiscBufferInfo,
  createDiscBuffers: createDiscBuffers,
  createDiscVertices: createDiscVertices,
  deindexVertices: deindexVertices,
  flattenNormals: flattenNormals,
  makeRandomVertexColors: makeRandomVertexColors,
  reorientDirections: reorientDirections,
  reorientNormals: reorientNormals,
  reorientPositions: reorientPositions,
  reorientVertices: reorientVertices,
  concatVertices: concatVertices,
  duplicateVertices: duplicateVertices
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Gets the gl version as a number
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {number} version of gl
 * @private
 */
//function getVersionAsNumber(gl) {
//  return parseFloat(gl.getParameter(gl.VERSION).substr(6));
//}

/**
 * Check if context is WebGL 2.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 2.0
 * @memberOf module:twgl
 */
function isWebGL2(gl) {
  // This is the correct check but it's slow
  //  return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0") === 0;
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGL2RenderingContext;
  return !!gl.texStorage2D;
}

/**
 * Check if context is WebGL 1.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 1.0
 * @memberOf module:twgl
 */
function isWebGL1(gl) {
  // This is the correct check but it's slow
  // const version = getVersionAsNumber(gl);
  // return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGLRenderingContext;
  return !gl.texStorage2D;
}

/**
 * Gets a string for WebGL enum
 *
 * Note: Several enums are the same. Without more
 * context (which function) it's impossible to always
 * give the correct enum. As it is, for matching values
 * it gives all enums. Checking the WebGL2RenderingContext
 * that means
 *
 *      0     = ZERO | POINT | NONE | NO_ERROR
 *      1     = ONE | LINES | SYNC_FLUSH_COMMANDS_BIT
 *      32777 = BLEND_EQUATION_RGB | BLEND_EQUATION_RGB
 *      36662 = COPY_READ_BUFFER | COPY_READ_BUFFER_BINDING
 *      36663 = COPY_WRITE_BUFFER | COPY_WRITE_BUFFER_BINDING
 *      36006 = FRAMEBUFFER_BINDING | DRAW_FRAMEBUFFER_BINDING
 *
 * It's also not useful for bits really unless you pass in individual bits.
 * In other words
 *
 *     const bits = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
 *     twgl.glEnumToString(gl, bits);  // not going to work
 *
 * Note that some enums only exist on extensions. If you
 * want them to show up you need to pass the extension at least
 * once. For example
 *
 *     const ext = gl.getExtension('WEBGL_compressed_texture_s3tc');
 *     if (ext) {
 *        twgl.glEnumToString(ext, 0);  // just prime the function
 *
 *        ..later..
 *
 *        const internalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
 *        console.log(twgl.glEnumToString(gl, internalFormat));
 *
 * Notice I didn't have to pass the extension the second time. This means
 * you can have place that generically gets an enum for texture formats for example.
 * and as long as you primed the function with the extensions
 *
 * If you're using `twgl.addExtensionsToContext` to enable your extensions
 * then twgl will automatically get the extension's enums.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext or any extension object
 * @param {number} value the value of the enum you want to look up.
 * @return {string} enum string or hex value
 * @memberOf module:twgl
 * @function glEnumToString
 */
const glEnumToString = (function() {
  const haveEnumsForType = {};
  const enums = {};

  function addEnums(gl) {
    const type = gl.constructor.name;
    if (!haveEnumsForType[type]) {
      for (const key in gl) {
        if (typeof gl[key] === 'number') {
          const existing = enums[gl[key]];
          enums[gl[key]] = existing ? `${existing} | ${key}` : key;
        }
      }
      haveEnumsForType[type] = true;
    }
  }

  return function glEnumToString(gl, value) {
    addEnums(gl);
    return enums[value] || (typeof value === 'number' ? `0x${value.toString(16)}` : value);
  };
}());

var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  glEnumToString: glEnumToString,
  isWebGL1: isWebGL1,
  isWebGL2: isWebGL2
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
const defaults$1 = {
  textureColor: new Uint8Array([128, 192, 255, 255]),
  textureOptions: {},
  crossOrigin: undefined,
};
const isArrayBuffer = isArrayBuffer$1;

// Should we make this on demand?
const getShared2DContext = function() {
  let s_ctx;
  return function getShared2DContext() {
    s_ctx = s_ctx ||
        ((typeof document !== 'undefined' && document.createElement)
          ? document.createElement("canvas").getContext("2d")
          : null);
    return s_ctx;
  };
}();

// NOTE: Chrome supports 2D canvas in a Worker (behind flag as of v64 but
//       not only does Firefox NOT support it but Firefox freezes immediately
//       if you try to create one instead of just returning null and continuing.
//  : (global.OffscreenCanvas && (new global.OffscreenCanvas(1, 1)).getContext("2d"));  // OffscreenCanvas may not support 2d

// NOTE: We can maybe remove some of the need for the 2d canvas. In WebGL2
// we can use the various unpack settings. Otherwise we could try using
// the ability of an ImageBitmap to be cut. Unfortunately cutting an ImageBitmap
// is async and the current TWGL code expects a non-Async result though that
// might not be a problem. ImageBitmap though is not available in Edge or Safari
// as of 2018-01-02

/* PixelFormat */
const ALPHA                          = 0x1906;
const RGB                            = 0x1907;
const RGBA$1                           = 0x1908;
const LUMINANCE                      = 0x1909;
const LUMINANCE_ALPHA                = 0x190A;
const DEPTH_COMPONENT$1                = 0x1902;
const DEPTH_STENCIL$1                  = 0x84F9;

/* TextureWrapMode */
// const REPEAT                         = 0x2901;
// const MIRRORED_REPEAT                = 0x8370;
const CLAMP_TO_EDGE$1                  = 0x812f;

/* TextureMagFilter */
const NEAREST                        = 0x2600;
const LINEAR$1                         = 0x2601;

/* TextureMinFilter */
// const NEAREST_MIPMAP_NEAREST         = 0x2700;
// const LINEAR_MIPMAP_NEAREST          = 0x2701;
// const NEAREST_MIPMAP_LINEAR          = 0x2702;
// const LINEAR_MIPMAP_LINEAR           = 0x2703;

/* Texture Target */
const TEXTURE_2D$2                     = 0x0de1;
const TEXTURE_CUBE_MAP$1               = 0x8513;
const TEXTURE_3D$1                     = 0x806f;
const TEXTURE_2D_ARRAY$1               = 0x8c1a;

/* Cubemap Targets */
const TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
const TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
const TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
const TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
const TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
const TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851a;

/* Texture Parameters */
const TEXTURE_MIN_FILTER             = 0x2801;
const TEXTURE_MAG_FILTER             = 0x2800;
const TEXTURE_WRAP_S                 = 0x2802;
const TEXTURE_WRAP_T                 = 0x2803;
const TEXTURE_WRAP_R                 = 0x8072;
const TEXTURE_MIN_LOD                = 0x813a;
const TEXTURE_MAX_LOD                = 0x813b;
const TEXTURE_BASE_LEVEL             = 0x813c;
const TEXTURE_MAX_LEVEL              = 0x813d;
const TEXTURE_COMPARE_MODE           = 0x884C;
const TEXTURE_COMPARE_FUNC           = 0x884D;

/* Pixel store */
const UNPACK_ALIGNMENT                   = 0x0cf5;
const UNPACK_ROW_LENGTH                  = 0x0cf2;
const UNPACK_IMAGE_HEIGHT                = 0x806e;
const UNPACK_SKIP_PIXELS                 = 0x0cf4;
const UNPACK_SKIP_ROWS                   = 0x0cf3;
const UNPACK_SKIP_IMAGES                 = 0x806d;
const UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
const UNPACK_PREMULTIPLY_ALPHA_WEBGL     = 0x9241;
const UNPACK_FLIP_Y_WEBGL                = 0x9240;

const R8                           = 0x8229;
const R8_SNORM                     = 0x8F94;
const R16F                         = 0x822D;
const R32F                         = 0x822E;
const R8UI                         = 0x8232;
const R8I                          = 0x8231;
const RG16UI                       = 0x823A;
const RG16I                        = 0x8239;
const RG32UI                       = 0x823C;
const RG32I                        = 0x823B;
const RG8                          = 0x822B;
const RG8_SNORM                    = 0x8F95;
const RG16F                        = 0x822F;
const RG32F                        = 0x8230;
const RG8UI                        = 0x8238;
const RG8I                         = 0x8237;
const R16UI                        = 0x8234;
const R16I                         = 0x8233;
const R32UI                        = 0x8236;
const R32I                         = 0x8235;
const RGB8                         = 0x8051;
const SRGB8                        = 0x8C41;
const RGB565$1                       = 0x8D62;
const RGB8_SNORM                   = 0x8F96;
const R11F_G11F_B10F               = 0x8C3A;
const RGB9_E5                      = 0x8C3D;
const RGB16F                       = 0x881B;
const RGB32F                       = 0x8815;
const RGB8UI                       = 0x8D7D;
const RGB8I                        = 0x8D8F;
const RGB16UI                      = 0x8D77;
const RGB16I                       = 0x8D89;
const RGB32UI                      = 0x8D71;
const RGB32I                       = 0x8D83;
const RGBA8                        = 0x8058;
const SRGB8_ALPHA8                 = 0x8C43;
const RGBA8_SNORM                  = 0x8F97;
const RGB5_A1$1                      = 0x8057;
const RGBA4$1                        = 0x8056;
const RGB10_A2                     = 0x8059;
const RGBA16F                      = 0x881A;
const RGBA32F                      = 0x8814;
const RGBA8UI                      = 0x8D7C;
const RGBA8I                       = 0x8D8E;
const RGB10_A2UI                   = 0x906F;
const RGBA16UI                     = 0x8D76;
const RGBA16I                      = 0x8D88;
const RGBA32I                      = 0x8D82;
const RGBA32UI                     = 0x8D70;

const DEPTH_COMPONENT16$1            = 0x81A5;
const DEPTH_COMPONENT24$1            = 0x81A6;
const DEPTH_COMPONENT32F$1           = 0x8CAC;
const DEPTH32F_STENCIL8$1            = 0x8CAD;
const DEPTH24_STENCIL8$1             = 0x88F0;

/* DataType */
const BYTE                         = 0x1400;
const UNSIGNED_BYTE$1                = 0x1401;
const SHORT                        = 0x1402;
const UNSIGNED_SHORT$1               = 0x1403;
const INT$1                          = 0x1404;
const UNSIGNED_INT$1                 = 0x1405;
const FLOAT$1                        = 0x1406;
const UNSIGNED_SHORT_4_4_4_4       = 0x8033;
const UNSIGNED_SHORT_5_5_5_1       = 0x8034;
const UNSIGNED_SHORT_5_6_5         = 0x8363;
const HALF_FLOAT                   = 0x140B;
const HALF_FLOAT_OES               = 0x8D61;  // Thanks Khronos for making this different >:(
const UNSIGNED_INT_2_10_10_10_REV  = 0x8368;
const UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
const UNSIGNED_INT_5_9_9_9_REV     = 0x8C3E;
const FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
const UNSIGNED_INT_24_8            = 0x84FA;

const RG                           = 0x8227;
const RG_INTEGER                   = 0x8228;
const RED                          = 0x1903;
const RED_INTEGER                  = 0x8D94;
const RGB_INTEGER                  = 0x8D98;
const RGBA_INTEGER                 = 0x8D99;

const formatInfo = {};
{
  // NOTE: this is named `numColorComponents` vs `numComponents` so we can let Uglify mangle
  // the name.
  const f = formatInfo;
  f[ALPHA]           = { numColorComponents: 1, };
  f[LUMINANCE]       = { numColorComponents: 1, };
  f[LUMINANCE_ALPHA] = { numColorComponents: 2, };
  f[RGB]             = { numColorComponents: 3, };
  f[RGBA$1]            = { numColorComponents: 4, };
  f[RED]             = { numColorComponents: 1, };
  f[RED_INTEGER]     = { numColorComponents: 1, };
  f[RG]              = { numColorComponents: 2, };
  f[RG_INTEGER]      = { numColorComponents: 2, };
  f[RGB]             = { numColorComponents: 3, };
  f[RGB_INTEGER]     = { numColorComponents: 3, };
  f[RGBA$1]            = { numColorComponents: 4, };
  f[RGBA_INTEGER]    = { numColorComponents: 4, };
  f[DEPTH_COMPONENT$1] = { numColorComponents: 1, };
  f[DEPTH_STENCIL$1]   = { numColorComponents: 2, };
}

/**
 * @typedef {Object} TextureFormatDetails
 * @property {number} textureFormat format to pass texImage2D and similar functions.
 * @property {boolean} colorRenderable true if you can render to this format of texture.
 * @property {boolean} textureFilterable true if you can filter the texture, false if you can ony use `NEAREST`.
 * @property {number[]} type Array of possible types you can pass to texImage2D and similar function
 * @property {Object.<number,number>} bytesPerElementMap A map of types to bytes per element
 * @private
 */

let s_textureInternalFormatInfo;
function getTextureInternalFormatInfo(internalFormat) {
  if (!s_textureInternalFormatInfo) {
    // NOTE: these properties need unique names so we can let Uglify mangle the name.
    const t = {};
    // unsized formats
    t[ALPHA]              = { textureFormat: ALPHA,           colorRenderable: true,  textureFilterable: true,  bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE$1, HALF_FLOAT, HALF_FLOAT_OES, FLOAT$1], };
    t[LUMINANCE]          = { textureFormat: LUMINANCE,       colorRenderable: true,  textureFilterable: true,  bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE$1, HALF_FLOAT, HALF_FLOAT_OES, FLOAT$1], };
    t[LUMINANCE_ALPHA]    = { textureFormat: LUMINANCE_ALPHA, colorRenderable: true,  textureFilterable: true,  bytesPerElement: [2, 4, 4, 8],        type: [UNSIGNED_BYTE$1, HALF_FLOAT, HALF_FLOAT_OES, FLOAT$1], };
    t[RGB]                = { textureFormat: RGB,             colorRenderable: true,  textureFilterable: true,  bytesPerElement: [3, 6, 6, 12, 2],    type: [UNSIGNED_BYTE$1, HALF_FLOAT, HALF_FLOAT_OES, FLOAT$1, UNSIGNED_SHORT_5_6_5], };
    t[RGBA$1]               = { textureFormat: RGBA$1,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE$1, HALF_FLOAT, HALF_FLOAT_OES, FLOAT$1, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1], };
    t[DEPTH_COMPONENT$1]    = { textureFormat: DEPTH_COMPONENT$1, colorRenderable: true,  textureFilterable: false, bytesPerElement: [2, 4],              type: [UNSIGNED_INT$1, UNSIGNED_SHORT$1], };

    // sized formats
    t[R8]                 = { textureFormat: RED,             colorRenderable: true,  textureFilterable: true,  bytesPerElement: [1],        type: [UNSIGNED_BYTE$1], };
    t[R8_SNORM]           = { textureFormat: RED,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [1],        type: [BYTE], };
    t[R16F]               = { textureFormat: RED,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [4, 2],     type: [FLOAT$1, HALF_FLOAT], };
    t[R32F]               = { textureFormat: RED,             colorRenderable: false, textureFilterable: false, bytesPerElement: [4],        type: [FLOAT$1], };
    t[R8UI]               = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [1],        type: [UNSIGNED_BYTE$1], };
    t[R8I]                = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [1],        type: [BYTE], };
    t[R16UI]              = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [2],        type: [UNSIGNED_SHORT$1], };
    t[R16I]               = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [2],        type: [SHORT], };
    t[R32UI]              = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_INT$1], };
    t[R32I]               = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [INT$1], };
    t[RG8]                = { textureFormat: RG,              colorRenderable: true,  textureFilterable: true,  bytesPerElement: [2],        type: [UNSIGNED_BYTE$1], };
    t[RG8_SNORM]          = { textureFormat: RG,              colorRenderable: false, textureFilterable: true,  bytesPerElement: [2],        type: [BYTE], };
    t[RG16F]              = { textureFormat: RG,              colorRenderable: false, textureFilterable: true,  bytesPerElement: [8, 4],     type: [FLOAT$1, HALF_FLOAT], };
    t[RG32F]              = { textureFormat: RG,              colorRenderable: false, textureFilterable: false, bytesPerElement: [8],        type: [FLOAT$1], };
    t[RG8UI]              = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [2],        type: [UNSIGNED_BYTE$1], };
    t[RG8I]               = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [2],        type: [BYTE], };
    t[RG16UI]             = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_SHORT$1], };
    t[RG16I]              = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [SHORT], };
    t[RG32UI]             = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [8],        type: [UNSIGNED_INT$1], };
    t[RG32I]              = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [8],        type: [INT$1], };
    t[RGB8]               = { textureFormat: RGB,             colorRenderable: true,  textureFilterable: true,  bytesPerElement: [3],        type: [UNSIGNED_BYTE$1], };
    t[SRGB8]              = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [3],        type: [UNSIGNED_BYTE$1], };
    t[RGB565$1]             = { textureFormat: RGB,             colorRenderable: true,  textureFilterable: true,  bytesPerElement: [3, 2],     type: [UNSIGNED_BYTE$1, UNSIGNED_SHORT_5_6_5], };
    t[RGB8_SNORM]         = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [3],        type: [BYTE], };
    t[R11F_G11F_B10F]     = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [12, 6, 4], type: [FLOAT$1, HALF_FLOAT, UNSIGNED_INT_10F_11F_11F_REV], };
    t[RGB9_E5]            = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [12, 6, 4], type: [FLOAT$1, HALF_FLOAT, UNSIGNED_INT_5_9_9_9_REV], };
    t[RGB16F]             = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [12, 6],    type: [FLOAT$1, HALF_FLOAT], };
    t[RGB32F]             = { textureFormat: RGB,             colorRenderable: false, textureFilterable: false, bytesPerElement: [12],       type: [FLOAT$1], };
    t[RGB8UI]             = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [3],        type: [UNSIGNED_BYTE$1], };
    t[RGB8I]              = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [3],        type: [BYTE], };
    t[RGB16UI]            = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [6],        type: [UNSIGNED_SHORT$1], };
    t[RGB16I]             = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [6],        type: [SHORT], };
    t[RGB32UI]            = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [12],       type: [UNSIGNED_INT$1], };
    t[RGB32I]             = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [12],       type: [INT$1], };
    t[RGBA8]              = { textureFormat: RGBA$1,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4],        type: [UNSIGNED_BYTE$1], };
    t[SRGB8_ALPHA8]       = { textureFormat: RGBA$1,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4],        type: [UNSIGNED_BYTE$1], };
    t[RGBA8_SNORM]        = { textureFormat: RGBA$1,            colorRenderable: false, textureFilterable: true,  bytesPerElement: [4],        type: [BYTE], };
    t[RGB5_A1$1]            = { textureFormat: RGBA$1,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4, 2, 4],  type: [UNSIGNED_BYTE$1, UNSIGNED_SHORT_5_5_5_1, UNSIGNED_INT_2_10_10_10_REV], };
    t[RGBA4$1]              = { textureFormat: RGBA$1,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4, 2],     type: [UNSIGNED_BYTE$1, UNSIGNED_SHORT_4_4_4_4], };
    t[RGB10_A2]           = { textureFormat: RGBA$1,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4],        type: [UNSIGNED_INT_2_10_10_10_REV], };
    t[RGBA16F]            = { textureFormat: RGBA$1,            colorRenderable: false, textureFilterable: true,  bytesPerElement: [16, 8],    type: [FLOAT$1, HALF_FLOAT], };
    t[RGBA32F]            = { textureFormat: RGBA$1,            colorRenderable: false, textureFilterable: false, bytesPerElement: [16],       type: [FLOAT$1], };
    t[RGBA8UI]            = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_BYTE$1], };
    t[RGBA8I]             = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [BYTE], };
    t[RGB10_A2UI]         = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_INT_2_10_10_10_REV], };
    t[RGBA16UI]           = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [8],        type: [UNSIGNED_SHORT$1], };
    t[RGBA16I]            = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [8],        type: [SHORT], };
    t[RGBA32I]            = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [16],       type: [INT$1], };
    t[RGBA32UI]           = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [16],       type: [UNSIGNED_INT$1], };
    // Sized Internal
    t[DEPTH_COMPONENT16$1]  = { textureFormat: DEPTH_COMPONENT$1, colorRenderable: true,  textureFilterable: false, bytesPerElement: [2, 4],     type: [UNSIGNED_SHORT$1, UNSIGNED_INT$1], };
    t[DEPTH_COMPONENT24$1]  = { textureFormat: DEPTH_COMPONENT$1, colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_INT$1], };
    t[DEPTH_COMPONENT32F$1] = { textureFormat: DEPTH_COMPONENT$1, colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [FLOAT$1], };
    t[DEPTH24_STENCIL8$1]   = { textureFormat: DEPTH_STENCIL$1,   colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_INT_24_8], };
    t[DEPTH32F_STENCIL8$1]  = { textureFormat: DEPTH_STENCIL$1,   colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [FLOAT_32_UNSIGNED_INT_24_8_REV], };

    Object.keys(t).forEach(function(internalFormat) {
      const info = t[internalFormat];
      info.bytesPerElementMap = {};
      info.bytesPerElement.forEach(function(bytesPerElement, ndx) {
        const type = info.type[ndx];
        info.bytesPerElementMap[type] = bytesPerElement;
      });
    });
    s_textureInternalFormatInfo = t;
  }
  return s_textureInternalFormatInfo[internalFormat];
}

/**
 * Gets the number of bytes per element for a given internalFormat / type
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @param {number} type The type parameter for texImage2D etc..
 * @return {number} the number of bytes per element for the given internalFormat, type combo
 * @memberOf module:twgl/textures
 */
function getBytesPerElementForInternalFormat(internalFormat, type) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  const bytesPerElement = info.bytesPerElementMap[type];
  if (bytesPerElement === undefined) {
    throw "unknown internal format";
  }
  return bytesPerElement;
}

/**
 * Info related to a specific texture internalFormat as returned
 * from {@link module:twgl/textures.getFormatAndTypeForInternalFormat}.
 *
 * @typedef {Object} TextureFormatInfo
 * @property {number} format Format to pass to texImage2D and related functions
 * @property {number} type Type to pass to texImage2D and related functions
 * @memberOf module:twgl/textures
 */

/**
 * Gets the format and type for a given internalFormat
 *
 * @param {number} internalFormat The internal format
 * @return {module:twgl/textures.TextureFormatInfo} the corresponding format and type,
 * @memberOf module:twgl/textures
 */
function getFormatAndTypeForInternalFormat(internalFormat) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return {
    format: info.textureFormat,
    type: info.type[0],
  };
}

/**
 * Returns true if value is power of 2
 * @param {number} value number to check.
 * @return true if value is power of 2
 * @private
 */
function isPowerOf2(value) {
  return (value & (value - 1)) === 0;
}

/**
 * Gets whether or not we can generate mips for the given
 * internal format.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number} width The width parameter from texImage2D etc..
 * @param {number} height The height parameter from texImage2D etc..
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */
function canGenerateMipmap(gl, width, height, internalFormat) {
  if (!isWebGL2(gl)) {
    return isPowerOf2(width) && isPowerOf2(height);
  }
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return info.colorRenderable && info.textureFilterable;
}

/**
 * Gets whether or not we can generate mips for the given format
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */
function canFilter(internalFormat) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return info.textureFilterable;
}

/**
 * Gets the number of components for a given image format.
 * @param {number} format the format.
 * @return {number} the number of components for the format.
 * @memberOf module:twgl/textures
 */
function getNumComponentsForFormat(format) {
  const info = formatInfo[format];
  if (!info) {
    throw "unknown format: " + format;
  }
  return info.numColorComponents;
}

/**
 * Gets the texture type for a given array type.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @return {number} the gl texture type
 * @private
 */
function getTextureTypeForArrayType(gl, src, defaultType) {
  if (isArrayBuffer(src)) {
    return getGLTypeForTypedArray(src);
  }
  return defaultType || UNSIGNED_BYTE$1;
}

function guessDimensions(gl, target, width, height, numElements) {
  if (numElements % 1 !== 0) {
    throw "can't guess dimensions";
  }
  if (!width && !height) {
    const size = Math.sqrt(numElements / (target === TEXTURE_CUBE_MAP$1 ? 6 : 1));
    if (size % 1 === 0) {
      width = size;
      height = size;
    } else {
      width = numElements;
      height = 1;
    }
  } else if (!height) {
    height = numElements / width;
    if (height % 1) {
      throw "can't guess dimensions";
    }
  } else if (!width) {
    width = numElements / height;
    if (width % 1) {
      throw "can't guess dimensions";
    }
  }
  return {
    width: width,
    height: height,
  };
}

/**
 * Sets the default texture color.
 *
 * The default texture color is used when loading textures from
 * urls. Because the URL will be loaded async we'd like to be
 * able to use the texture immediately. By putting a 1x1 pixel
 * color in the texture we can start using the texture before
 * the URL has loaded.
 *
 * @param {number[]} color Array of 4 values in the range 0 to 1
 * @deprecated see {@link module:twgl.setDefaults}
 * @memberOf module:twgl/textures
 */
function setDefaultTextureColor(color) {
  defaults$1.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}

function setDefaults$1(newDefaults) {
  copyExistingProperties(newDefaults, defaults$1);
  if (newDefaults.textureColor) {
    setDefaultTextureColor(newDefaults.textureColor);
  }
}

/**
 * A function to generate the source for a texture.
 * @callback TextureFunc
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options the texture options
 * @return {*} Returns any of the things documented for `src` for {@link module:twgl.TextureOptions}.
 * @memberOf module:twgl
 */

/**
 * Texture options passed to most texture functions. Each function will use whatever options
 * are appropriate for its needs. This lets you pass the same options to all functions.
 *
 * Note: A `TexImageSource` is defined in the WebGL spec as a `HTMLImageElement`, `HTMLVideoElement`,
 * `HTMLCanvasElement`, `ImageBitmap`, or `ImageData`.
 *
 * @typedef {Object} TextureOptions
 * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.
 * @property {number} [level] the mip level to affect. Defaults to 0. Note, if set auto will be considered false unless explicitly set to true.
 * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.
 * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.
 * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .
 * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`
 *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.
 * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`
 * @property {number} [minMag] both the min and mag filter settings.
 * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`
 * @property {number} [format] format for texture. Defaults to `gl.RGBA`.
 * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBufferView. If `src`
 *     is ArrayBufferView defaults to type that matches ArrayBufferView type.
 * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D or WebGLSampler). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube
 * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [minLod] TEXTURE_MIN_LOD setting
 * @property {number} [maxLod] TEXTURE_MAX_LOD setting
 * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting
 * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting
 * @property {number} [compareFunc] TEXTURE_COMPARE_FUNC setting
 * @property {number} [compareMode] TEXTURE_COMPARE_MODE setting
 * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.
 * @property {number[]|ArrayBufferView} [color] Color to initialize this texture with if loading an image asynchronously.
 *     The default use a blue 1x1 pixel texture. You can set another default by calling `twgl.setDefaults`
 *     or you can set an individual texture's initial color by setting this property. Example: `[1, .5, .5, 1]` = pink
 * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {boolean} [auto] If `undefined` or `true`, in WebGL1, texture filtering is set automatically for non-power of 2 images and
 *    mips are generated for power of 2 images. In WebGL2 mips are generated if they can be. Note: if `level` is set above
 *    then then `auto` is assumed to be `false` unless explicity set to `true`.
 * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is
 *
 *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
 *
 * @property {(number[]|ArrayBufferView|TexImageSource|TexImageSource[]|string|string[]|module:twgl.TextureFunc)} [src] source for texture
 *
 *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable
 *    1x1 pixel texture will be returned immediately. The texture will be updated once the image has downloaded.
 *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.
 *    The pieces will be uploaded in `cubeFaceOrder`
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_CUBE_MAP` then it must have 6 entries, one for each face of a cube map.
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_2D_ARRAY` then each entry is a slice of the a 2d array texture
 *    and will be scaled to the specified width and height OR to the size of the first image that loads.
 *
 *    If `TexImageSource` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,
 *    `HTMLCanvasElement`, `HTMLVideoElement`.
 *
 *    If `number[]` or `ArrayBufferView` it's assumed to be data for a texture. If `width` or `height` is
 *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponents`
 *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided
 *    by 6. Then
 *
 *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height
 *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.
 *
 *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.
 *
 * If `number[]` will be converted to `type`.
 *
 * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.
 * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`
 * an array etc...
 *
 * If `src` is undefined then an empty texture will be created of size `width` by `height`.
 *
 * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.
 *    default: undefined. Also see {@link module:twgl.setDefaults}.
 *
 * @memberOf module:twgl
 */

/**
 * Sets any packing state that will be set based on the options.
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */
function setPackState(gl, options) {
  if (options.colorspaceConversion !== undefined) {
    gl.pixelStorei(UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);
  }
  if (options.premultiplyAlpha !== undefined) {
    gl.pixelStorei(UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);
  }
  if (options.flipY !== undefined) {
    gl.pixelStorei(UNPACK_FLIP_Y_WEBGL, options.flipY);
  }
}

/**
 * Set skip state to defaults
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */
function setSkipStateToDefault(gl) {
  gl.pixelStorei(UNPACK_ALIGNMENT, 4);
  if (isWebGL2(gl)) {
    gl.pixelStorei(UNPACK_ROW_LENGTH, 0);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_PIXELS, 0);
    gl.pixelStorei(UNPACK_SKIP_ROWS, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
  }
}

/**
 * Sets the parameters of a texture or sampler
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number|WebGLSampler} target texture target or sampler
 * @param {function()} parameteriFn texParameteri or samplerParameteri fn
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @private
 */
function setTextureSamplerParameters(gl, target, parameteriFn, options) {
  if (options.minMag) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.minMag);
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.minMag);
  }
  if (options.min) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.min);
  }
  if (options.mag) {
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.mag);
  }
  if (options.wrap) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrap);
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrap);
    if (target === TEXTURE_3D$1 || isSampler(gl, target)) {
      parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrap);
    }
  }
  if (options.wrapR) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrapR);
  }
  if (options.wrapS) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrapS);
  }
  if (options.wrapT) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrapT);
  }
  if (options.minLod !== undefined) {
    parameteriFn.call(gl, target, TEXTURE_MIN_LOD, options.minLod);
  }
  if (options.maxLod !== undefined) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LOD, options.maxLod);
  }
  if (options.baseLevel !== undefined) {
    parameteriFn.call(gl, target, TEXTURE_BASE_LEVEL, options.baseLevel);
  }
  if (options.maxLevel !== undefined) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LEVEL, options.maxLevel);
  }
  if (options.compareFunc !== undefined) {
    parameteriFn.call(gl, target, TEXTURE_COMPARE_FUNC, options.compareFunc);
  }
  if (options.compareMode !== undefined) {
    parameteriFn.call(gl, target, TEXTURE_COMPARE_MODE, options.compareMode);
  }
}

/**
 * Sets the texture parameters of a texture.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */
function setTextureParameters(gl, tex, options) {
  const target = options.target || TEXTURE_2D$2;
  gl.bindTexture(target, tex);
  setTextureSamplerParameters(gl, target, gl.texParameteri, options);
}

/**
 * Sets the sampler parameters of a sampler.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLSampler} sampler the WebGLSampler to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */
function setSamplerParameters(gl, sampler, options) {
  setTextureSamplerParameters(gl, sampler, gl.samplerParameteri, options);
}

/**
 * Creates a new sampler object and sets parameters.
 *
 * Example:
 *
 *      const sampler = twgl.createSampler(gl, {
 *        minMag: gl.NEAREST,         // sets both TEXTURE_MIN_FILTER and TEXTURE_MAG_FILTER
 *        wrap: gl.CLAMP_TO_NEAREST,  // sets both TEXTURE_WRAP_S and TEXTURE_WRAP_T and TEXTURE_WRAP_R
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per sampler.
 * @return {Object.<string,WebGLSampler>} the created samplers by name
 * @private
 */
function createSampler(gl, options) {
  const sampler = gl.createSampler();
  setSamplerParameters(gl, sampler, options);
  return sampler;
}

/**
 * Creates a multiple sampler objects and sets parameters on each.
 *
 * Example:
 *
 *      const samplers = twgl.createSamplers(gl, {
 *        nearest: {
 *          minMag: gl.NEAREST,
 *        },
 *        nearestClampS: {
 *          minMag: gl.NEAREST,
 *          wrapS: gl.CLAMP_TO_NEAREST,
 *        },
 *        linear: {
 *          minMag: gl.LINEAR,
 *        },
 *        nearestClamp: {
 *          minMag: gl.NEAREST,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClamp: {
 *          minMag: gl.LINEAR,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClampT: {
 *          minMag: gl.LINEAR,
 *          wrapT: gl.CLAMP_TO_EDGE,
 *        },
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set on the sampler
 * @private
 */
function createSamplers(gl, samplerOptions) {
  const samplers = {};
  Object.keys(samplerOptions).forEach(function(name) {
    samplers[name] = createSampler(gl, samplerOptions[name]);
  });
  return samplers;
}

/**
 * Makes a 1x1 pixel
 * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.
 * @param {(number[]|ArrayBufferView)} [color] The color using 0-1 values
 * @return {Uint8Array} Unit8Array with color.
 * @private
 */
function make1Pixel(color) {
  color = color || defaults$1.textureColor;
  if (isArrayBuffer(color)) {
    return color;
  }
  return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}

/**
 * Sets filtering or generates mips for texture based on width or height
 * If width or height is not passed in uses `options.width` and//or `options.height`
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @param {number} [width] width of texture
 * @param {number} [height] height of texture
 * @param {number} [internalFormat] The internalFormat parameter from texImage2D etc..
 * @memberOf module:twgl/textures
 */
function setTextureFilteringForSize(gl, tex, options, width, height, internalFormat) {
  options = options || defaults$1.textureOptions;
  internalFormat = internalFormat || RGBA$1;
  const target = options.target || TEXTURE_2D$2;
  width = width || options.width;
  height = height || options.height;
  gl.bindTexture(target, tex);
  if (canGenerateMipmap(gl, width, height, internalFormat)) {
    gl.generateMipmap(target);
  } else {
    const filtering = canFilter(internalFormat) ? LINEAR$1 : NEAREST;
    gl.texParameteri(target, TEXTURE_MIN_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_MAG_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE$1);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE$1);
  }
}

function shouldAutomaticallySetTextureFilteringForSize(options) {
  return options.auto === true || (options.auto === undefined && options.level === undefined);
}

/**
 * Gets an array of cubemap face enums
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @return {number[]} cubemap face enums
 * @private
 */
function getCubeFaceOrder(gl, options) {
  options = options || {};
  return options.cubeFaceOrder || [
      TEXTURE_CUBE_MAP_POSITIVE_X,
      TEXTURE_CUBE_MAP_NEGATIVE_X,
      TEXTURE_CUBE_MAP_POSITIVE_Y,
      TEXTURE_CUBE_MAP_NEGATIVE_Y,
      TEXTURE_CUBE_MAP_POSITIVE_Z,
      TEXTURE_CUBE_MAP_NEGATIVE_Z,
    ];
}

/**
 * @typedef {Object} FaceInfo
 * @property {number} face gl enum for texImage2D
 * @property {number} ndx face index (0 - 5) into source data
 * @ignore
 */

/**
 * Gets an array of FaceInfos
 * There's a bug in some NVidia drivers that will crash the driver if
 * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take
 * the user's desired order from his faces to WebGL and make sure we
 * do the faces in WebGL order
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundant but
 *    it's needed internally to sort the array of `ndx` properties by `face`.
 * @private
 */
function getCubeFacesWithNdx(gl, options) {
  const faces = getCubeFaceOrder(gl, options);
  // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(
  const facesWithNdx = faces.map(function(face, ndx) {
    return { face: face, ndx: ndx };
  });
  facesWithNdx.sort(function(a, b) {
    return a.face - b.face;
  });
  return facesWithNdx;
}

/**
 * Set a texture from the contents of an element. Will also set
 * texture filtering or generate mips based on the dimensions of the element
 * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will
 * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {HTMLElement} element a canvas, img, or video element.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 * @kind function
 */
function setTextureFromElement(gl, tex, element, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D$2;
  const level = options.level || 0;
  let width = element.width;
  let height = element.height;
  const internalFormat = options.internalFormat || options.format || RGBA$1;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || formatType.type;
  setPackState(gl, options);
  gl.bindTexture(target, tex);
  if (target === TEXTURE_CUBE_MAP$1) {
    // guess the parts
    const imgWidth  = element.width;
    const imgHeight = element.height;
    let size;
    let slices;
    if (imgWidth / 6 === imgHeight) {
      // It's 6x1
      size = imgHeight;
      slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];
    } else if (imgHeight / 6 === imgWidth) {
      // It's 1x6
      size = imgWidth;
      slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];
    } else if (imgWidth / 3 === imgHeight / 2) {
      // It's 3x2
      size = imgWidth / 3;
      slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];
    } else if (imgWidth / 2 === imgHeight / 3) {
      // It's 2x3
      size = imgWidth / 2;
      slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];
    } else {
      throw "can't figure out cube map from element: " + (element.src ? element.src : element.nodeName);
    }
    const ctx = getShared2DContext();
    if (ctx) {
      ctx.canvas.width = size;
      ctx.canvas.height = size;
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function(f) {
        const xOffset = slices[f.ndx * 2 + 0] * size;
        const yOffset = slices[f.ndx * 2 + 1] * size;
        ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);
        gl.texImage2D(f.face, level, internalFormat, format, type, ctx.canvas);
      });
      // Free up the canvas memory
      ctx.canvas.width = 1;
      ctx.canvas.height = 1;
    } else if (typeof createImageBitmap !== 'undefined') {
      // NOTE: It seems like we should prefer ImageBitmap because unlike canvas it's
      // note lossy? (alpha is not premultiplied? although I'm not sure what
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function(f) {
        const xOffset = slices[f.ndx * 2 + 0] * size;
        const yOffset = slices[f.ndx * 2 + 1] * size;
        // We can't easily use a default texture color here as it would have to match
        // the type across all faces where as with a 2D one there's only one face
        // so we're replacing everything all at once. It also has to be the correct size.
        // On the other hand we need all faces to be the same size so as one face loads
        // the rest match else the texture will be un-renderable.
        gl.texImage2D(f.face, level, internalFormat, size, size, 0, format, type, null);
        createImageBitmap(element, xOffset, yOffset, size, size, {
          premultiplyAlpha: 'none',
          colorSpaceConversion: 'none',
        })
        .then(function(imageBitmap) {
          setPackState(gl, options);
          gl.bindTexture(target, tex);
          gl.texImage2D(f.face, level, internalFormat, format, type, imageBitmap);
          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
          }
        });
      });
    }
  } else if (target === TEXTURE_3D$1 || target === TEXTURE_2D_ARRAY$1) {
    const smallest = Math.min(element.width, element.height);
    const largest = Math.max(element.width, element.height);
    const depth = largest / smallest;
    if (depth % 1 !== 0) {
      throw "can not compute 3D dimensions of element";
    }
    const xMult = element.width  === largest ? 1 : 0;
    const yMult = element.height === largest ? 1 : 0;
    gl.pixelStorei(UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(UNPACK_ROW_LENGTH, element.width);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
    gl.texImage3D(target, level, internalFormat, smallest, smallest, smallest, 0, format, type, null);
    for (let d = 0; d < depth; ++d) {
      const srcX = d * smallest * xMult;
      const srcY = d * smallest * yMult;
      gl.pixelStorei(UNPACK_SKIP_PIXELS, srcX);
      gl.pixelStorei(UNPACK_SKIP_ROWS, srcY);
      gl.texSubImage3D(target, level, 0, 0, d, smallest, smallest, 1, format, type, element);
    }
    setSkipStateToDefault(gl);
  } else {
    gl.texImage2D(target, level, internalFormat, format, type, element);
  }
  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }
  setTextureParameters(gl, tex, options);
}

function noop() {
}

/**
 * Checks whether the url's origin is the same so that we can set the `crossOrigin`
 * @param {string} url url to image
 * @returns {boolean} true if the window's origin is the same as image's url
 * @private
 */
function urlIsSameOrigin(url) {
  if (typeof document !== 'undefined') {
    // for IE really
    const a = document.createElement('a');
    a.href = url;
    return a.hostname === location.hostname &&
           a.port     === location.port &&
           a.protocol === location.protocol;
  } else {
    const localOrigin = (new URL(location.href)).origin;
    const urlOrigin = (new URL(url, location.href)).origin;
    return urlOrigin === localOrigin;
  }
}

function setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin) {
  return crossOrigin === undefined && !urlIsSameOrigin(url)
     ? 'anonymous'
     : crossOrigin;
}

/**
 * Loads an image
 * @param {string} url url to image
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @return {HTMLImageElement} the image being loaded.
 * @private
 */
function loadImage(url, crossOrigin, callback) {
  callback = callback || noop;
  let img;
  crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults$1.crossOrigin;
  crossOrigin = setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin);
  if (typeof Image !== 'undefined') {
    img = new Image();
    if (crossOrigin !== undefined) {
      img.crossOrigin = crossOrigin;
    }

    const clearEventHandlers = function clearEventHandlers() {
      img.removeEventListener('error', onError);  // eslint-disable-line
      img.removeEventListener('load', onLoad);  // eslint-disable-line
      img = null;
    };

    const onError = function onError() {
      const msg = "couldn't load image: " + url;
      error$1(msg);
      callback(msg, img);
      clearEventHandlers();
    };

    const onLoad = function onLoad() {
      callback(null, img);
      clearEventHandlers();
    };

    img.addEventListener('error', onError);
    img.addEventListener('load', onLoad);
    img.src = url;
    return img;
  } else if (typeof ImageBitmap !== 'undefined') {
    let err;
    let bm;
    const cb = function cb() {
      callback(err, bm);
    };

    const options = {};
    if (crossOrigin) {
      options.mode = 'cors'; // TODO: not sure how to translate image.crossOrigin
    }
    fetch(url, options).then(function(response) {
      if (!response.ok) {
        throw response;
      }
      return response.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, {
        premultiplyAlpha: 'none',
        colorSpaceConversion: 'none',
      });
    }).then(function(bitmap) {
      // not sure if this works. We don't want
      // to catch the user's error. So, call
      // the callback in a timeout so we're
      // not in this scope inside the promise.
      bm = bitmap;
      setTimeout(cb);
    }).catch(function(e) {
      err = e;
      setTimeout(cb);
    });
    img = null;
  }
  return img;
}

/**
 * check if object is a TexImageSource
 *
 * @param {Object} obj Object to test
 * @return {boolean} true if object is a TexImageSource
 * @private
 */
function isTexImageSource(obj) {
  return (typeof ImageBitmap !== 'undefined' && obj instanceof ImageBitmap) ||
         (typeof ImageData !== 'undefined'  && obj instanceof ImageData) ||
         (typeof HTMLElement !== 'undefined'  && obj instanceof HTMLElement);
}

/**
 * if obj is an TexImageSource then just
 * uses it otherwise if obj is a string
 * then load it first.
 *
 * @param {string|TexImageSource} obj
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @private
 */
function loadAndUseImage(obj, crossOrigin, callback) {
  if (isTexImageSource(obj)) {
    setTimeout(function() {
      callback(null, obj);
    });
    return obj;
  }

  return loadImage(obj, crossOrigin, callback);
}

/**
 * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set
 * the default texture color is used which can be set by calling `setDefaultTextureColor`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 * @private
 */
function setTextureTo1PixelColor(gl, tex, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D$2;
  gl.bindTexture(target, tex);
  if (options.color === false) {
    return;
  }
  // Assume it's a URL
  // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.
  const color = make1Pixel(options.color);
  if (target === TEXTURE_CUBE_MAP$1) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, RGBA$1, 1, 1, 0, RGBA$1, UNSIGNED_BYTE$1, color);
    }
  } else if (target === TEXTURE_3D$1 || target === TEXTURE_2D_ARRAY$1) {
    gl.texImage3D(target, 0, RGBA$1, 1, 1, 1, 0, RGBA$1, UNSIGNED_BYTE$1, color);
  } else {
    gl.texImage2D(target, 0, RGBA$1, 1, 1, 0, RGBA$1, UNSIGNED_BYTE$1, color);
  }
}

/**
 * The src image(s) used to create a texture.
 *
 * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}
 * you can pass in urls for images to load into the textures. If it's a single url
 * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap
 * this will be a corresponding array of images for the cubemap.
 *
 * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback TextureReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} texture the texture.
 * @param {module:twgl.TextureSrc} source image(s) used to as the src for the texture
 * @memberOf module:twgl
 */

/**
 * A callback for when all images have finished downloading and been uploaded into their respective textures
 * @callback TexturesReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.
 * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback CubemapReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each face.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback ThreeDReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each slice.
 * @memberOf module:twgl
 */

/**
 * Loads a texture from an image from a Url as specified in `options.src`
 * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is
 * immediately useable. It will be updated with the contents of the image once the image has finished
 * downloading. Filtering options will be set as appropriate for image unless `options.auto === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will
 *    be non null if there was an error.
 * @return {HTMLImageElement} the image being downloaded.
 * @memberOf module:twgl/textures
 */
function loadTextureFromUrl(gl, tex, options, callback) {
  callback = callback || noop;
  options = options || defaults$1.textureOptions;
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  const img = loadAndUseImage(options.src, options.crossOrigin, function(err, img) {
    if (err) {
      callback(err, tex, img);
    } else {
      setTextureFromElement(gl, tex, img, options);
      callback(null, tex, img);
    }
  });
  return img;
}

/**
 * Loads a cubemap from 6 urls or TexImageSources as specified in `options.src`. Will set the cubemap to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 * @private
 */
function loadCubemapFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  const urls = options.src;
  if (urls.length !== 6) {
    throw "there must be 6 urls for a cubemap";
  }
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA$1;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || UNSIGNED_BYTE$1;
  const target = options.target || TEXTURE_2D$2;
  if (target !== TEXTURE_CUBE_MAP$1) {
    throw "target must be TEXTURE_CUBE_MAP";
  }
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  let numToLoad = 6;
  const errors = [];
  const faces = getCubeFaceOrder(gl, options);
  let imgs;  // eslint-disable-line

  function uploadImg(faceTarget) {
    return function(err, img) {
      --numToLoad;
      if (err) {
        errors.push(err);
      } else {
        if (img.width !== img.height) {
          errors.push("cubemap face img is not a square: " + img.src);
        } else {
          setPackState(gl, options);
          gl.bindTexture(target, tex);

          // So assuming this is the first image we now have one face that's img sized
          // and 5 faces that are 1x1 pixel so size the other faces
          if (numToLoad === 5) {
            // use the default order
            getCubeFaceOrder().forEach(function(otherTarget) {
              // Should we re-use the same face or a color?
              gl.texImage2D(otherTarget, level, internalFormat, format, type, img);
            });
          } else {
            gl.texImage2D(faceTarget, level, internalFormat, format, type, img);
          }

          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            gl.generateMipmap(target);
          }
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function(url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(faces[ndx]));
  });
}

/**
 * Loads a 2d array or 3d texture from urls OR TexImageSources as specified in `options.src`.
 * Will set the texture to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 *
 * If the width and height is not specified the width and height of the first
 * image loaded will be used. Note that since images are loaded async
 * which image downloads first is unknown.
 *
 * If an image is not the same size as the width and height it will be scaled
 * to that width and height.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.ThreeDReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 * @private
 */
function loadSlicesFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  const urls = options.src;
  const internalFormat = options.internalFormat || options.format || RGBA$1;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || UNSIGNED_BYTE$1;
  const target = options.target || TEXTURE_2D_ARRAY$1;
  if (target !== TEXTURE_3D$1 && target !== TEXTURE_2D_ARRAY$1) {
    throw "target must be TEXTURE_3D or TEXTURE_2D_ARRAY";
  }
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  let numToLoad = urls.length;
  const errors = [];
  let imgs;  // eslint-disable-line
  const level = options.level || 0;
  let width = options.width;
  let height = options.height;
  const depth = urls.length;
  let firstImage = true;

  function uploadImg(slice) {
    return function(err, img) {
      --numToLoad;
      if (err) {
        errors.push(err);
      } else {
        setPackState(gl, options);
        gl.bindTexture(target, tex);

        if (firstImage) {
          firstImage = false;
          width = options.width || img.width;
          height = options.height || img.height;
          gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null);

          // put it in every slice otherwise some slices will be 0,0,0,0
          for (let s = 0; s < depth; ++s) {
            gl.texSubImage3D(target, level, 0, 0, s, width, height, 1, format, type, img);
          }
        } else {
          let src = img;
          let ctx;
          if (img.width !== width || img.height !== height) {
            // Size the image to fix
            ctx = getShared2DContext();
            src = ctx.canvas;
            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
          }

          gl.texSubImage3D(target, level, 0, 0, slice, width, height, 1, format, type, src);

          // free the canvas memory
          if (ctx && src === ctx.canvas) {
            ctx.canvas.width = 0;
            ctx.canvas.height = 0;
          }
        }

        if (shouldAutomaticallySetTextureFilteringForSize(options)) {
          gl.generateMipmap(target);
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function(url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(ndx));
  });
}

/**
 * Sets a texture from an array or typed array. If the width or height is not provided will attempt to
 * guess the size. See {@link module:twgl.TextureOptions}.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {(number[]|ArrayBufferView)} src An array or typed arry with texture data.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */
function setTextureFromArray(gl, tex, src, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D$2;
  gl.bindTexture(target, tex);
  let width = options.width;
  let height = options.height;
  let depth = options.depth;
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA$1;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  if (!isArrayBuffer(src)) {
    const Type = getTypedArrayTypeForGLType(type);
    src = new Type(src);
  } else if (src instanceof Uint8ClampedArray) {
    src = new Uint8Array(src.buffer);
  }

  const bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
  const numElements = src.byteLength / bytesPerElement;  // TODO: check UNPACK_ALIGNMENT?
  if (numElements % 1) {
    throw "length wrong size for format: " + glEnumToString(gl, format);
  }
  let dimensions;
  if (target === TEXTURE_3D$1 || target === TEXTURE_2D_ARRAY$1) {
    if (!width && !height && !depth) {
      const size = Math.cbrt(numElements);
      if (size % 1 !== 0) {
        throw "can't guess cube size of array of numElements: " + numElements;
      }
      width = size;
      height = size;
      depth = size;
    } else if (width && (!height || !depth)) {
      dimensions = guessDimensions(gl, target, height, depth, numElements / width);
      height = dimensions.width;
      depth = dimensions.height;
    } else if (height && (!width || !depth)) {
      dimensions = guessDimensions(gl, target, width, depth, numElements / height);
      width = dimensions.width;
      depth = dimensions.height;
    } else {
      dimensions = guessDimensions(gl, target, width, height, numElements / depth);
      width = dimensions.width;
      height = dimensions.height;
    }
  } else {
    dimensions = guessDimensions(gl, target, width, height, numElements);
    width = dimensions.width;
    height = dimensions.height;
  }
  setSkipStateToDefault(gl);
  gl.pixelStorei(UNPACK_ALIGNMENT, options.unpackAlignment || 1);
  setPackState(gl, options);
  if (target === TEXTURE_CUBE_MAP$1) {
    const elementsPerElement = bytesPerElement / src.BYTES_PER_ELEMENT;
    const faceSize = numElements / 6 * elementsPerElement;

    getCubeFacesWithNdx(gl, options).forEach(f => {
      const offset = faceSize * f.ndx;
      const data = src.subarray(offset, offset + faceSize);
      gl.texImage2D(f.face, level, internalFormat, width, height, 0, format, type, data);
    });
  } else if (target === TEXTURE_3D$1 || target === TEXTURE_2D_ARRAY$1) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, src);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, src);
  }
  return {
    width: width,
    height: height,
    depth: depth,
    type: type,
  };
}

/**
 * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.
 * You must set `options.width` and `options.height`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */
function setEmptyTexture(gl, tex, options) {
  const target = options.target || TEXTURE_2D$2;
  gl.bindTexture(target, tex);
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA$1;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || formatType.type;
  setPackState(gl, options);
  if (target === TEXTURE_CUBE_MAP$1) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, options.width, options.height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D$1 || target === TEXTURE_2D_ARRAY$1) {
    gl.texImage3D(target, level, internalFormat, options.width, options.height, options.depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, options.width, options.height, 0, format, type, null);
  }
}

/**
 * Creates a texture based on the options passed in.
 *
 * Note: may reset UNPACK_ALIGNMENT, UNPACK_ROW_LENGTH, UNPACK_IMAGE_HEIGHT, UNPACK_SKIP_IMAGES
 * UNPACK_SKIP_PIXELS, and UNPACK_SKIP_ROWS
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.
 * @return {WebGLTexture} the created texture.
 * @memberOf module:twgl/textures
 */
function createTexture(gl, options, callback) {
  callback = callback || noop;
  options = options || defaults$1.textureOptions;
  const tex = gl.createTexture();
  const target = options.target || TEXTURE_2D$2;
  let width  = options.width  || 1;
  let height = options.height || 1;
  const internalFormat = options.internalFormat || RGBA$1;
  gl.bindTexture(target, tex);
  if (target === TEXTURE_CUBE_MAP$1) {
    // this should have been the default for cubemaps :(
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE$1);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE$1);
  }
  let src = options.src;
  if (src) {
    if (typeof src === "function") {
      src = src(gl, options);
    }
    if (typeof (src) === "string") {
      loadTextureFromUrl(gl, tex, options, callback);
    } else if (isArrayBuffer(src) ||
               (Array.isArray(src) && (
                    typeof src[0] === 'number' ||
                    Array.isArray(src[0]) ||
                    isArrayBuffer(src[0]))
               )
              ) {
      const dimensions = setTextureFromArray(gl, tex, src, options);
      width  = dimensions.width;
      height = dimensions.height;
    } else if (Array.isArray(src) && (typeof (src[0]) === 'string' || isTexImageSource(src[0]))) {
      if (target === TEXTURE_CUBE_MAP$1) {
        loadCubemapFromUrls(gl, tex, options, callback);
      } else {
        loadSlicesFromUrls(gl, tex, options, callback);
      }
    } else { // if (isTexImageSource(src))
      setTextureFromElement(gl, tex, src, options);
      width  = src.width;
      height = src.height;
    }
  } else {
    setEmptyTexture(gl, tex, options);
  }
  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }
  setTextureParameters(gl, tex, options);
  return tex;
}

/**
 * Resizes a texture based on the options passed in.
 *
 * Note: This is not a generic resize anything function.
 * It's mostly used by {@link module:twgl.resizeFramebufferInfo}
 * It will use `options.src` if it exists to try to determine a `type`
 * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided
 * for the texture. Texture parameters will be set accordingly
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the texture to resize
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {number} [width] the new width. If not passed in will use `options.width`
 * @param {number} [height] the new height. If not passed in will use `options.height`
 * @param {number} [depth] the new depth. If not passed in will use `options.depth`
 * @memberOf module:twgl/textures
 */
function resizeTexture(gl, tex, options, width, height, depth) {
  width = width || options.width;
  height = height || options.height;
  depth = depth || options.depth;
  const target = options.target || TEXTURE_2D$2;
  gl.bindTexture(target, tex);
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA$1;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  let type;
  const src = options.src;
  if (!src) {
    type = options.type || formatType.type;
  } else if (isArrayBuffer(src) || (Array.isArray(src) && typeof (src[0]) === 'number')) {
    type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  } else {
    type = options.type || formatType.type;
  }
  if (target === TEXTURE_CUBE_MAP$1) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, width, height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D$1 || target === TEXTURE_2D_ARRAY$1) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);
  }
}

/**
 * Check if a src is an async request.
 * if src is a string we're going to download an image
 * if src is an array of strings we're going to download cubemap images
 * @param {*} src The src from a TextureOptions
 * @returns {bool} true if src is async.
 * @private
 */
function isAsyncSrc(src) {
  return typeof src === 'string' ||
         (Array.isArray(src) && typeof src[0] === 'string');
}

/**
 * Creates a bunch of textures based on the passed in options.
 *
 * Example:
 *
 *     const textures = twgl.createTextures(gl, {
 *       // a power of 2 image
 *       hftIcon: { src: "images/hft-icon-16.png", mag: gl.NEAREST },
 *       // a non-power of 2 image
 *       clover: { src: "images/clover.jpg" },
 *       // From a canvas
 *       fromCanvas: { src: ctx.canvas },
 *       // A cubemap from 6 images
 *       yokohama: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: [
 *           'images/yokohama/posx.jpg',
 *           'images/yokohama/negx.jpg',
 *           'images/yokohama/posy.jpg',
 *           'images/yokohama/negy.jpg',
 *           'images/yokohama/posz.jpg',
 *           'images/yokohama/negz.jpg',
 *         ],
 *       },
 *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)
 *       goldengate: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: 'images/goldengate.jpg',
 *       },
 *       // A 2x2 pixel texture from a JavaScript array
 *       checker: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         src: [
 *           255,255,255,255,
 *           192,192,192,255,
 *           192,192,192,255,
 *           255,255,255,255,
 *         ],
 *       },
 *       // a 1x2 pixel texture from a typed array.
 *       stripe: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         format: gl.LUMINANCE,
 *         src: new Uint8Array([
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *         ]),
 *         width: 1,
 *       },
 *     });
 *
 * Now
 *
 * *   `textures.hftIcon` will be a 2d texture
 * *   `textures.clover` will be a 2d texture
 * *   `textures.fromCanvas` will be a 2d texture
 * *   `textures.yohohama` will be a cubemap texture
 * *   `textures.goldengate` will be a cubemap texture
 * *   `textures.checker` will be a 2d texture
 * *   `textures.stripe` will be a 2d texture
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.
 * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.
 * @return {Object.<string,WebGLTexture>} the created textures by name
 * @memberOf module:twgl/textures
 */
function createTextures(gl, textureOptions, callback) {
  callback = callback || noop;
  let numDownloading = 0;
  const errors = [];
  const textures = {};
  const images = {};

  function callCallbackIfReady() {
    if (numDownloading === 0) {
      setTimeout(function() {
        callback(errors.length ? errors : undefined, textures, images);
      }, 0);
    }
  }

  Object.keys(textureOptions).forEach(function(name) {
    const options = textureOptions[name];
    let onLoadFn;
    if (isAsyncSrc(options.src)) {
      onLoadFn = function(err, tex, img) {
        images[name] = img;
        --numDownloading;
        if (err) {
          errors.push(err);
        }
        callCallbackIfReady();
      };
      ++numDownloading;
    }
    textures[name] = createTexture(gl, options, onLoadFn);
  });

  // queue the callback if there are no images to download.
  // We do this because if your code is structured to wait for
  // images to download but then you comment out all the async
  // images your code would break.
  callCallbackIfReady();

  return textures;
}

var textures = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setTextureDefaults_: setDefaults$1,
  createSampler: createSampler,
  createSamplers: createSamplers,
  setSamplerParameters: setSamplerParameters,
  createTexture: createTexture,
  setEmptyTexture: setEmptyTexture,
  setTextureFromArray: setTextureFromArray,
  loadTextureFromUrl: loadTextureFromUrl,
  setTextureFromElement: setTextureFromElement,
  setTextureFilteringForSize: setTextureFilteringForSize,
  setTextureParameters: setTextureParameters,
  setDefaultTextureColor: setDefaultTextureColor,
  createTextures: createTextures,
  resizeTexture: resizeTexture,
  canGenerateMipmap: canGenerateMipmap,
  canFilter: canFilter,
  getNumComponentsForFormat: getNumComponentsForFormat,
  getBytesPerElementForInternalFormat: getBytesPerElementForInternalFormat,
  getFormatAndTypeForInternalFormat: getFormatAndTypeForInternalFormat
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Low level shader program related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.programs` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/programs
 */

const error = error$1;
const warn = warn$1;
function getElementById(id) {
  return (typeof document !== 'undefined' && document.getElementById)
      ? document.getElementById(id)
      : null;
}

const TEXTURE0                       = 0x84c0;
const DYNAMIC_DRAW                   = 0x88e8;

const ARRAY_BUFFER                   = 0x8892;
const ELEMENT_ARRAY_BUFFER$1           = 0x8893;
const UNIFORM_BUFFER                 = 0x8a11;
const TRANSFORM_FEEDBACK_BUFFER      = 0x8c8e;

const TRANSFORM_FEEDBACK             = 0x8e22;

const COMPILE_STATUS                 = 0x8b81;
const LINK_STATUS                    = 0x8b82;
const FRAGMENT_SHADER                = 0x8b30;
const VERTEX_SHADER                  = 0x8b31;
const SEPARATE_ATTRIBS               = 0x8c8d;

const ACTIVE_UNIFORMS                = 0x8b86;
const ACTIVE_ATTRIBUTES              = 0x8b89;
const TRANSFORM_FEEDBACK_VARYINGS    = 0x8c83;
const ACTIVE_UNIFORM_BLOCKS          = 0x8a36;
const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER   = 0x8a44;
const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8a46;
const UNIFORM_BLOCK_DATA_SIZE                     = 0x8a40;
const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES        = 0x8a43;

const FLOAT                         = 0x1406;
const FLOAT_VEC2                    = 0x8B50;
const FLOAT_VEC3                    = 0x8B51;
const FLOAT_VEC4                    = 0x8B52;
const INT                           = 0x1404;
const INT_VEC2                      = 0x8B53;
const INT_VEC3                      = 0x8B54;
const INT_VEC4                      = 0x8B55;
const BOOL                          = 0x8B56;
const BOOL_VEC2                     = 0x8B57;
const BOOL_VEC3                     = 0x8B58;
const BOOL_VEC4                     = 0x8B59;
const FLOAT_MAT2                    = 0x8B5A;
const FLOAT_MAT3                    = 0x8B5B;
const FLOAT_MAT4                    = 0x8B5C;
const SAMPLER_2D                    = 0x8B5E;
const SAMPLER_CUBE                  = 0x8B60;
const SAMPLER_3D                    = 0x8B5F;
const SAMPLER_2D_SHADOW             = 0x8B62;
const FLOAT_MAT2x3                  = 0x8B65;
const FLOAT_MAT2x4                  = 0x8B66;
const FLOAT_MAT3x2                  = 0x8B67;
const FLOAT_MAT3x4                  = 0x8B68;
const FLOAT_MAT4x2                  = 0x8B69;
const FLOAT_MAT4x3                  = 0x8B6A;
const SAMPLER_2D_ARRAY              = 0x8DC1;
const SAMPLER_2D_ARRAY_SHADOW       = 0x8DC4;
const SAMPLER_CUBE_SHADOW           = 0x8DC5;
const UNSIGNED_INT                  = 0x1405;
const UNSIGNED_INT_VEC2             = 0x8DC6;
const UNSIGNED_INT_VEC3             = 0x8DC7;
const UNSIGNED_INT_VEC4             = 0x8DC8;
const INT_SAMPLER_2D                = 0x8DCA;
const INT_SAMPLER_3D                = 0x8DCB;
const INT_SAMPLER_CUBE              = 0x8DCC;
const INT_SAMPLER_2D_ARRAY          = 0x8DCF;
const UNSIGNED_INT_SAMPLER_2D       = 0x8DD2;
const UNSIGNED_INT_SAMPLER_3D       = 0x8DD3;
const UNSIGNED_INT_SAMPLER_CUBE     = 0x8DD4;
const UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;

const TEXTURE_2D$1                    = 0x0DE1;
const TEXTURE_CUBE_MAP              = 0x8513;
const TEXTURE_3D                    = 0x806F;
const TEXTURE_2D_ARRAY              = 0x8C1A;

const typeMap = {};

/**
 * Returns the corresponding bind point for a given sampler type
 * @private
 */
function getBindPointForSamplerType(gl, type) {
  return typeMap[type].bindPoint;
}

// This kind of sucks! If you could compose functions as in `var fn = gl[name];`
// this code could be a lot smaller but that is sadly really slow (T_T)

function floatSetter(gl, location) {
  return function(v) {
    gl.uniform1f(location, v);
  };
}

function floatArraySetter(gl, location) {
  return function(v) {
    gl.uniform1fv(location, v);
  };
}

function floatVec2Setter(gl, location) {
  return function(v) {
    gl.uniform2fv(location, v);
  };
}

function floatVec3Setter(gl, location) {
  return function(v) {
    gl.uniform3fv(location, v);
  };
}

function floatVec4Setter(gl, location) {
  return function(v) {
    gl.uniform4fv(location, v);
  };
}

function intSetter(gl, location) {
  return function(v) {
    gl.uniform1i(location, v);
  };
}

function intArraySetter(gl, location) {
  return function(v) {
    gl.uniform1iv(location, v);
  };
}

function intVec2Setter(gl, location) {
  return function(v) {
    gl.uniform2iv(location, v);
  };
}

function intVec3Setter(gl, location) {
  return function(v) {
    gl.uniform3iv(location, v);
  };
}

function intVec4Setter(gl, location) {
  return function(v) {
    gl.uniform4iv(location, v);
  };
}

function uintSetter(gl, location) {
  return function(v) {
    gl.uniform1ui(location, v);
  };
}

function uintArraySetter(gl, location) {
  return function(v) {
    gl.uniform1uiv(location, v);
  };
}

function uintVec2Setter(gl, location) {
  return function(v) {
    gl.uniform2uiv(location, v);
  };
}

function uintVec3Setter(gl, location) {
  return function(v) {
    gl.uniform3uiv(location, v);
  };
}

function uintVec4Setter(gl, location) {
  return function(v) {
    gl.uniform4uiv(location, v);
  };
}

function floatMat2Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix2fv(location, false, v);
  };
}

function floatMat3Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix3fv(location, false, v);
  };
}

function floatMat4Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix4fv(location, false, v);
  };
}

function floatMat23Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix2x3fv(location, false, v);
  };
}

function floatMat32Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix3x2fv(location, false, v);
  };
}

function floatMat24Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix2x4fv(location, false, v);
  };
}

function floatMat42Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix4x2fv(location, false, v);
  };
}

function floatMat34Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix3x4fv(location, false, v);
  };
}

function floatMat43Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix4x3fv(location, false, v);
  };
}

function samplerSetter(gl, type, unit, location) {
  const bindPoint = getBindPointForSamplerType(gl, type);
  return isWebGL2(gl) ? function(textureOrPair) {
    let texture;
    let sampler;
    if (!textureOrPair || isTexture(gl, textureOrPair)) {
      texture = textureOrPair;
      sampler = null;
    } else {
      texture = textureOrPair.texture;
      sampler = textureOrPair.sampler;
    }
    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
    gl.bindSampler(unit, sampler);
  } : function(texture) {
    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
  };
}

function samplerArraySetter(gl, type, unit, location, size) {
  const bindPoint = getBindPointForSamplerType(gl, type);
  const units = new Int32Array(size);
  for (let ii = 0; ii < size; ++ii) {
    units[ii] = unit + ii;
  }

  return isWebGL2(gl) ? function(textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function(textureOrPair, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      let texture;
      let sampler;
      if (!textureOrPair || isTexture(gl, textureOrPair)) {
        texture = textureOrPair;
        sampler = null;
      } else {
        texture = textureOrPair.texture;
        sampler = textureOrPair.sampler;
      }
      gl.bindSampler(unit, sampler);
      gl.bindTexture(bindPoint, texture);
    });
  } : function(textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function(texture, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      gl.bindTexture(bindPoint, texture);
    });
  };
}

typeMap[FLOAT]                         = { Type: Float32Array, size:  4, setter: floatSetter,      arraySetter: floatArraySetter, };
typeMap[FLOAT_VEC2]                    = { Type: Float32Array, size:  8, setter: floatVec2Setter,  cols: 2, };
typeMap[FLOAT_VEC3]                    = { Type: Float32Array, size: 12, setter: floatVec3Setter,  cols: 3, };
typeMap[FLOAT_VEC4]                    = { Type: Float32Array, size: 16, setter: floatVec4Setter,  cols: 4, };
typeMap[INT]                           = { Type: Int32Array,   size:  4, setter: intSetter,        arraySetter: intArraySetter, };
typeMap[INT_VEC2]                      = { Type: Int32Array,   size:  8, setter: intVec2Setter,    cols: 2, };
typeMap[INT_VEC3]                      = { Type: Int32Array,   size: 12, setter: intVec3Setter,    cols: 3, };
typeMap[INT_VEC4]                      = { Type: Int32Array,   size: 16, setter: intVec4Setter,    cols: 4, };
typeMap[UNSIGNED_INT]                  = { Type: Uint32Array,  size:  4, setter: uintSetter,       arraySetter: uintArraySetter, };
typeMap[UNSIGNED_INT_VEC2]             = { Type: Uint32Array,  size:  8, setter: uintVec2Setter,   cols: 2, };
typeMap[UNSIGNED_INT_VEC3]             = { Type: Uint32Array,  size: 12, setter: uintVec3Setter,   cols: 3, };
typeMap[UNSIGNED_INT_VEC4]             = { Type: Uint32Array,  size: 16, setter: uintVec4Setter,   cols: 4, };
typeMap[BOOL]                          = { Type: Uint32Array,  size:  4, setter: intSetter,        arraySetter: intArraySetter, };
typeMap[BOOL_VEC2]                     = { Type: Uint32Array,  size:  8, setter: intVec2Setter,    cols: 2, };
typeMap[BOOL_VEC3]                     = { Type: Uint32Array,  size: 12, setter: intVec3Setter,    cols: 3, };
typeMap[BOOL_VEC4]                     = { Type: Uint32Array,  size: 16, setter: intVec4Setter,    cols: 4, };
typeMap[FLOAT_MAT2]                    = { Type: Float32Array, size: 32, setter: floatMat2Setter,  rows: 2, cols: 2, };
typeMap[FLOAT_MAT3]                    = { Type: Float32Array, size: 48, setter: floatMat3Setter,  rows: 3, cols: 3, };
typeMap[FLOAT_MAT4]                    = { Type: Float32Array, size: 64, setter: floatMat4Setter,  rows: 4, cols: 4, };
typeMap[FLOAT_MAT2x3]                  = { Type: Float32Array, size: 32, setter: floatMat23Setter, rows: 2, cols: 3, };
typeMap[FLOAT_MAT2x4]                  = { Type: Float32Array, size: 32, setter: floatMat24Setter, rows: 2, cols: 4, };
typeMap[FLOAT_MAT3x2]                  = { Type: Float32Array, size: 48, setter: floatMat32Setter, rows: 3, cols: 2, };
typeMap[FLOAT_MAT3x4]                  = { Type: Float32Array, size: 48, setter: floatMat34Setter, rows: 3, cols: 4, };
typeMap[FLOAT_MAT4x2]                  = { Type: Float32Array, size: 64, setter: floatMat42Setter, rows: 4, cols: 2, };
typeMap[FLOAT_MAT4x3]                  = { Type: Float32Array, size: 64, setter: floatMat43Setter, rows: 4, cols: 3, };
typeMap[SAMPLER_2D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D$1,       };
typeMap[SAMPLER_CUBE]                  = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };
typeMap[SAMPLER_3D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };
typeMap[SAMPLER_2D_SHADOW]             = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D$1,       };
typeMap[SAMPLER_2D_ARRAY]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };
typeMap[SAMPLER_2D_ARRAY_SHADOW]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };
typeMap[SAMPLER_CUBE_SHADOW]           = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };
typeMap[INT_SAMPLER_2D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D$1,       };
typeMap[INT_SAMPLER_3D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };
typeMap[INT_SAMPLER_CUBE]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };
typeMap[INT_SAMPLER_2D_ARRAY]          = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };
typeMap[UNSIGNED_INT_SAMPLER_2D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D$1,       };
typeMap[UNSIGNED_INT_SAMPLER_3D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };
typeMap[UNSIGNED_INT_SAMPLER_CUBE]     = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };
typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };

function floatAttribSetter(gl, index) {
  return function(b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      switch (b.value.length) {
        case 4:
          gl.vertexAttrib4fv(index, b.value);
          break;
        case 3:
          gl.vertexAttrib3fv(index, b.value);
          break;
        case 2:
          gl.vertexAttrib2fv(index, b.value);
          break;
        case 1:
          gl.vertexAttrib1fv(index, b.value);
          break;
        default:
          throw new Error('the length of a float constant value must be between 1 and 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribPointer(
          index, b.numComponents || b.size, b.type || FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);
      if (gl.vertexAttribDivisor) {
        gl.vertexAttribDivisor(index, b.divisor || 0);
      }
    }
  };
}

function intAttribSetter(gl, index) {
  return function(b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      if (b.value.length === 4) {
        gl.vertexAttrib4iv(index, b.value);
      } else {
        throw new Error('The length of an integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(
          index, b.numComponents || b.size, b.type || INT, b.stride || 0, b.offset || 0);
      if (gl.vertexAttribDivisor) {
        gl.vertexAttribDivisor(index, b.divisor || 0);
      }
    }
  };
}

function uintAttribSetter(gl, index) {
  return function(b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      if (b.value.length === 4) {
        gl.vertexAttrib4uiv(index, b.value);
      } else {
        throw new Error('The length of an unsigned integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(
          index, b.numComponents || b.size, b.type || UNSIGNED_INT, b.stride || 0, b.offset || 0);
      if (gl.vertexAttribDivisor) {
        gl.vertexAttribDivisor(index, b.divisor || 0);
      }
    }
  };
}

function matAttribSetter(gl, index, typeInfo) {
  const defaultSize = typeInfo.size;
  const count = typeInfo.count;

  return function(b) {
    gl.bindBuffer(ARRAY_BUFFER, b.buffer);
    const numComponents = b.size || b.numComponents || defaultSize;
    const size = numComponents / count;
    const type = b.type || FLOAT;
    const typeInfo = typeMap[type];
    const stride = typeInfo.size * numComponents;
    const normalize = b.normalize || false;
    const offset = b.offset || 0;
    const rowOffset = stride / count;
    for (let i = 0; i < count; ++i) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(
          index + i, size, type, normalize, stride, offset + rowOffset * i);
      if (gl.vertexAttribDivisor) {
        gl.vertexAttribDivisor(index + i, b.divisor || 0);
      }
    }
  };
}



const attrTypeMap = {};
attrTypeMap[FLOAT]             = { size:  4, setter: floatAttribSetter, };
attrTypeMap[FLOAT_VEC2]        = { size:  8, setter: floatAttribSetter, };
attrTypeMap[FLOAT_VEC3]        = { size: 12, setter: floatAttribSetter, };
attrTypeMap[FLOAT_VEC4]        = { size: 16, setter: floatAttribSetter, };
attrTypeMap[INT]               = { size:  4, setter: intAttribSetter,   };
attrTypeMap[INT_VEC2]          = { size:  8, setter: intAttribSetter,   };
attrTypeMap[INT_VEC3]          = { size: 12, setter: intAttribSetter,   };
attrTypeMap[INT_VEC4]          = { size: 16, setter: intAttribSetter,   };
attrTypeMap[UNSIGNED_INT]      = { size:  4, setter: uintAttribSetter,  };
attrTypeMap[UNSIGNED_INT_VEC2] = { size:  8, setter: uintAttribSetter,  };
attrTypeMap[UNSIGNED_INT_VEC3] = { size: 12, setter: uintAttribSetter,  };
attrTypeMap[UNSIGNED_INT_VEC4] = { size: 16, setter: uintAttribSetter,  };
attrTypeMap[BOOL]              = { size:  4, setter: intAttribSetter,   };
attrTypeMap[BOOL_VEC2]         = { size:  8, setter: intAttribSetter,   };
attrTypeMap[BOOL_VEC3]         = { size: 12, setter: intAttribSetter,   };
attrTypeMap[BOOL_VEC4]         = { size: 16, setter: intAttribSetter,   };
attrTypeMap[FLOAT_MAT2]        = { size:  4, setter: matAttribSetter,   count: 2, };
attrTypeMap[FLOAT_MAT3]        = { size:  9, setter: matAttribSetter,   count: 3, };
attrTypeMap[FLOAT_MAT4]        = { size: 16, setter: matAttribSetter,   count: 4, };

const errorRE = /ERROR:\s*\d+:(\d+)/gi;
function addLineNumbersWithError(src, log = '', lineOffset = 0) {
  // Note: Error message formats are not defined by any spec so this may or may not work.
  const matches = [...log.matchAll(errorRE)];
  const lineNoToErrorMap = new Map(matches.map((m, ndx) => {
    const lineNo = parseInt(m[1]);
    const next = matches[ndx + 1];
    const end = next ? next.index : log.length;
    const msg = log.substring(m.index, end);
    return [lineNo - 1, msg];
  }));
  return src.split('\n').map((line, lineNo) => {
    const err = lineNoToErrorMap.get(lineNo);
    return `${lineNo + 1 + lineOffset}: ${line}${err ? `\n\n^^^ ${err}` : ''}`;
  }).join('\n');
}

/**
 * Error Callback
 * @callback ErrorCallback
 * @param {string} msg error message.
 * @param {number} [lineOffset] amount to add to line number
 * @memberOf module:twgl
 */

/**
 * Program Callback
 * @callback ProgramCallback
 * @param {string} [err] error message, falsy if no error
 * @param {WebGLProgram|module:twgl.ProgramInfo} [result] the program or programInfo
 */

const spaceRE = /^[ \t]*\n/;

/**
 * Remove the first end of line because WebGL 2.0 requires
 * #version 300 es
 * as the first line. No whitespace allowed before that line
 * so
 *
 * <script>
 * #version 300 es
 * </script>
 *
 * Has one line before it which is invalid according to GLSL ES 3.00
 *
 * @param {string} shaderSource The source of the shader
 * @returns {{shaderSource: string, lineOffset: number}}
 * @private
 */
function prepShaderSource(shaderSource) {
  let lineOffset = 0;
  if (spaceRE.test(shaderSource)) {
    lineOffset = 1;
    shaderSource = shaderSource.replace(spaceRE, '');
  }
  return {lineOffset, shaderSource};
}

/**
 * @param {module:twgl.ProgramOptions} progOptions
 * @param {string} msg
 * @return null
 * @private
 */
function reportError(progOptions, msg) {
  progOptions.errorCallback(msg);
  if (progOptions.callback) {
    setTimeout(() => {
      progOptions.callback(`${msg}\n${progOptions.errors.join('\n')}`);
    });
  }
  return null;
}

/**
 * Check Shader status
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {number} shaderType The shader type
 * @param {WebGLShader} shader The shader
 * @param {ErrorCallback} [errFn] function to receive error message.
 * @return {string} errors or empty string
 * @private
 */
function checkShaderStatus(gl, shaderType, shader, errFn) {
  errFn = errFn || error;
  // Check the compile status
  const compiled = gl.getShaderParameter(shader, COMPILE_STATUS);
  if (!compiled) {
    // Something went wrong during compilation; get the error
    const lastError = gl.getShaderInfoLog(shader);
    const {lineOffset, shaderSource} = prepShaderSource(gl.getShaderSource(shader));
    const error = `${addLineNumbersWithError(shaderSource, lastError, lineOffset)}\nError compiling ${glEnumToString(gl, shaderType)}: ${lastError}`;
    errFn(error);
    return error;
  }
  return '';
}

/**
 * @typedef {Object} FullProgramSpec
 * @property {string[]} shaders the shader source or element ids.
 * @property {function(string)} [errorCallback] callback for errors
 * @property {Object.<string,number>|string[]} [attribLocations] a attribute name to location map, or array of attribute names where index = location.
 * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed
 *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise
 *   you can pass an array of names.
 * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.
 * @property {ProgramCallback} [callback] callback for async program compilation.
 * @memberOf module:twgl
 */

/**
 * @typedef {string[]|module:twgl.FullProgramSpec} ProgramSpec
 * @memberOf module:twgl
 */

/**
 * @typedef {Object} ProgramOptions
 * @property {function(string)} [errorCallback] callback for errors
 * @property {Object.<string,number>|string[]} [attribLocations] a attribute name to location map, or array of attribute names where index = location.
 * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed
 *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise
 *   you can pass an array of names.
 * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.
 * @property {ProgramCallback} [callback] callback for async program compilation.
 * @memberOf module:twgl
 */

/**
 * Gets the program options based on all these optional arguments
 * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramOptions} an instance of ProgramOptions based on the arguments passed in
 * @private
 */
function getProgramOptions(opt_attribs, opt_locations, opt_errorCallback) {
  let transformFeedbackVaryings;
  let transformFeedbackMode;
  let callback;
  if (typeof opt_locations === 'function') {
    opt_errorCallback = opt_locations;
    opt_locations = undefined;
  }
  if (typeof opt_attribs === 'function') {
    opt_errorCallback = opt_attribs;
    opt_attribs = undefined;
  } else if (opt_attribs && !Array.isArray(opt_attribs)) {
    const opt = opt_attribs;
    opt_errorCallback = opt.errorCallback;
    opt_attribs = opt.attribLocations;
    transformFeedbackVaryings = opt.transformFeedbackVaryings;
    transformFeedbackMode = opt.transformFeedbackMode;
    callback = opt.callback;
  }

  const errorCallback = opt_errorCallback || error;
  const errors = [];
  const options = {
    errorCallback(msg, ...args) {
      errors.push(msg);
      errorCallback(msg, ...args);
    },
    transformFeedbackVaryings,
    transformFeedbackMode,
    callback,
    errors,
  };

  {
    let attribLocations = {};
    if (Array.isArray(opt_attribs)) {
      opt_attribs.forEach(function(attrib,  ndx) {
        attribLocations[attrib] = opt_locations ? opt_locations[ndx] : ndx;
      });
    } else {
      attribLocations = opt_attribs || {};
    }
    options.attribLocations = attribLocations;
  }

  return options;
}

const defaultShaderType = [
  "VERTEX_SHADER",
  "FRAGMENT_SHADER",
];

function getShaderTypeFromScriptType(gl, scriptType) {
  if (scriptType.indexOf("frag") >= 0) {
    return FRAGMENT_SHADER;
  } else if (scriptType.indexOf("vert") >= 0) {
    return VERTEX_SHADER;
  }
  return undefined;
}

function deleteProgramAndShaders(gl, program, notThese) {
  const shaders = gl.getAttachedShaders(program);
  for (const shader of shaders) {
    if (notThese.has(shader)) {
      gl.deleteShader(shader);
    }
  }
  gl.deleteProgram(program);
}

const wait = (ms = 0) => new Promise(resolve => setTimeout(resolve, ms));

function createProgramNoCheck(gl, shaders, programOptions) {
  const program = gl.createProgram();
  const {
    attribLocations,
    transformFeedbackVaryings,
    transformFeedbackMode,
  } = getProgramOptions(programOptions);

  for (let ndx = 0; ndx < shaders.length; ++ndx) {
    let shader = shaders[ndx];
    if (typeof shader === 'string') {
      const elem = getElementById(shader);
      const src = elem ? elem.text : shader;
      let type = gl[defaultShaderType[ndx]];
      if (elem && elem.type) {
        type = getShaderTypeFromScriptType(gl, elem.type) || type;
      }
      shader = gl.createShader(type);
      gl.shaderSource(shader, prepShaderSource(src).shaderSource);
      gl.compileShader(shader);
      gl.attachShader(program, shader);
    }
  }

  Object.entries(attribLocations).forEach(([attrib, loc]) => gl.bindAttribLocation(program, loc, attrib));

  {
    let varyings = transformFeedbackVaryings;
    if (varyings) {
      if (varyings.attribs) {
        varyings = varyings.attribs;
      }
      if (!Array.isArray(varyings)) {
        varyings = Object.keys(varyings);
      }
      gl.transformFeedbackVaryings(program, varyings, transformFeedbackMode || SEPARATE_ATTRIBS);
    }
  }

  gl.linkProgram(program);
  return program;
}

/**
 * Creates a program, attaches (and/or compiles) shaders, binds attrib locations, links the
 * program.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgram(gl, [vs, fs], options);
 *     twgl.createProgram(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]|module:twgl.ErrorCallback} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error of a callback was provided.
 * @memberOf module:twgl/programs
 */
function createProgram(
    gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
  // This code is really convoluted, because it may or may not be async
  // Maybe it would be better to have a separate function
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const shaderSet = new Set(shaders);
  const program = createProgramNoCheck(gl, shaders, progOptions);

  function hasErrors(gl, program) {
    const errors = getProgramErrors(gl, program, progOptions.errorCallback);
    if (errors) {
      deleteProgramAndShaders(gl, program, shaderSet);
    }
    return errors;
  }

  if (progOptions.callback) {
    waitForProgramLinkCompletionAsync(gl, program).then(() => {
      const errors = hasErrors(gl, program);
      progOptions.callback(errors, errors ? undefined : program);
    });
    return undefined;
  }

  return hasErrors(gl, program) ? undefined : program;
}

/**
 * This only works because the functions it wraps the first 2 arguments
 * are gl and any, followed by things that become programOptions
 * @private
 */
function wrapCallbackFnToAsyncFn(fn) {
  return function(gl, arg1, ...args) {
    return new Promise((resolve, reject) => {
      const programOptions = getProgramOptions(...args);
      programOptions.callback = (err, program) => {
        if (err) {
          reject(err);
        } else {
          resolve(program);
        }
      };
      fn(gl, arg1, programOptions);
    });
  };
}

/**
 * Same as createProgram but returns a promise
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramAsync(gl, [vs, fs], options);
 *     twgl.createProgramAsync(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramAsync(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramAsync(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @function
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]|module:twgl.ErrorCallback} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {Promise<WebGLProgram>} The created program
 * @memberOf module:twgl/programs
 */
const createProgramAsync = wrapCallbackFnToAsyncFn(createProgram);

/**
 * Same as createProgramInfo but returns a promise
 * @function
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders or ids. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]|module:twgl.ErrorCallback} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {Promise<module:twgl.ProgramInfo>} The created ProgramInfo
 * @memberOf module:twgl/programs
 */
const createProgramInfoAsync = wrapCallbackFnToAsyncFn(createProgramInfo);

async function waitForProgramLinkCompletionAsync(gl, program) {
  const ext = gl.getExtension('KHR_parallel_shader_compile');
  const checkFn = ext
      ? (gl, program) => gl.getProgramParameter(program, ext.COMPLETION_STATUS_KHR)
      : () => true;

  let waitTime = 0;
  do {
    await wait(waitTime);  // must wait at least once
    waitTime = 1000 / 60;
  } while (!checkFn(gl, program));
}

async function waitForAllProgramsLinkCompletionAsync(gl, programs) {
  for (const program of Object.values(programs)) {
    await waitForProgramLinkCompletionAsync(gl, program);
  }
}

/**
 * Check a program's link status
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program Program to check
 * @param {ErrorCallback} [errFn] func for errors
 * @return {string?} errors if program is failed, else undefined
 * @private
 */
function getProgramErrors(gl, program, errFn) {
  errFn = errFn || error;
  // Check the link status
  const linked = gl.getProgramParameter(program, LINK_STATUS);
  if (!linked) {
    // something went wrong with the link
    const lastError = gl.getProgramInfoLog(program);
    errFn(`Error in program linking: ${lastError}`);
    // print any errors from these shaders
    const shaders = gl.getAttachedShaders(program);
    const errors = shaders.map(shader => checkShaderStatus(gl, gl.getShaderParameter(shader, gl.SHADER_TYPE), shader, errFn));
    return `${lastError}\n${errors.filter(_ => _).join('\n')}`;
  }
  return undefined;
}

/**
 * Creates a program from 2 script tags.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderScriptIds Array of ids of the script
 *        tags for the shaders. The first is assumed to be the
 *        vertex shader, the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]|module:twgl.ErrorCallback} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error or a callback was provided.
 * @memberOf module:twgl/programs
 */
function createProgramFromScripts(
    gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const shaders = [];
  for (const scriptId of shaderScriptIds) {
    const shaderScript = getElementById(scriptId);
    if (!shaderScript) {
      return reportError(progOptions, `unknown script element: ${scriptId}`);
    }
    shaders.push(shaderScript.text);
  }
  return createProgram(gl, shaders, progOptions);
}

/**
 * Creates a program from 2 sources.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]|module:twgl.ErrorCallback} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error or a callback was provided.
 * @memberOf module:twgl/programs
 */
function createProgramFromSources(
    gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  return createProgram(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);
}

/**
 * Returns true if attribute/uniform is a reserved/built in
 *
 * It makes no sense to me why GL returns these because it's
 * illegal to call `gl.getUniformLocation` and `gl.getAttribLocation`
 * with names that start with `gl_` (and `webgl_` in WebGL)
 *
 * I can only assume they are there because they might count
 * when computing the number of uniforms/attributes used when you want to
 * know if you are near the limit. That doesn't really make sense
 * to me but the fact that these get returned are in the spec.
 *
 * @param {WebGLActiveInfo} info As returned from `gl.getActiveUniform` or
 *    `gl.getActiveAttrib`.
 * @return {bool} true if it's reserved
 * @private
 */
function isBuiltIn(info) {
  const name = info.name;
  return name.startsWith("gl_") || name.startsWith("webgl_");
}

const tokenRE = /(\.|\[|]|\w+)/g;
const isDigit = s => s >= '0' && s <= '9';
function addSetterToUniformTree(fullPath, setter, node, uniformSetters) {
  const tokens = fullPath.split(tokenRE).filter(s => s !== '');
  let tokenNdx = 0;
  let path = '';

  for (;;) {
    const token = tokens[tokenNdx++];  // has to be name or number
    path += token;
    const isArrayIndex = isDigit(token[0]);
    const accessor = isArrayIndex
        ? parseInt(token)
        : token;
    if (isArrayIndex) {
      path += tokens[tokenNdx++];  // skip ']'
    }
    const isLastToken = tokenNdx === tokens.length;
    if (isLastToken) {
      node[accessor] = setter;
      break;
    } else {
      const token = tokens[tokenNdx++];  // has to be . or [
      const isArray = token === '[';
      const child = node[accessor] || (isArray ? [] : {});
      node[accessor] = child;
      node = child;
      uniformSetters[path] = uniformSetters[path] || function(node) {
        return function(value) {
          setUniformTree(node, value);
        };
      }(child);
      path += token;
    }
  }
}

/**
 * Creates setter functions for all uniforms of a shader
 * program.
 *
 * @see {@link module:twgl.setUniforms}
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @returns {Object.<string, function>} an object with a setter by name for each uniform
 * @memberOf module:twgl/programs
 */
function createUniformSetters(gl, program) {
  let textureUnit = 0;

  /**
   * Creates a setter for a uniform of the given program with it's
   * location embedded in the setter.
   * @param {WebGLProgram} program
   * @param {WebGLUniformInfo} uniformInfo
   * @returns {function} the created setter.
   */
  function createUniformSetter(program, uniformInfo, location) {
    const isArray = uniformInfo.name.endsWith("[0]");
    const type = uniformInfo.type;
    const typeInfo = typeMap[type];
    if (!typeInfo) {
      throw new Error(`unknown type: 0x${type.toString(16)}`); // we should never get here.
    }
    let setter;
    if (typeInfo.bindPoint) {
      // it's a sampler
      const unit = textureUnit;
      textureUnit += uniformInfo.size;
      if (isArray) {
        setter = typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);
      } else {
        setter = typeInfo.setter(gl, type, unit, location, uniformInfo.size);
      }
    } else {
      if (typeInfo.arraySetter && isArray) {
        setter = typeInfo.arraySetter(gl, location);
      } else {
        setter = typeInfo.setter(gl, location);
      }
    }
    setter.location = location;
    return setter;
  }

  const uniformSetters = {};
  const uniformTree = {};
  const numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);

  for (let ii = 0; ii < numUniforms; ++ii) {
    const uniformInfo = gl.getActiveUniform(program, ii);
    if (isBuiltIn(uniformInfo)) {
      continue;
    }
    let name = uniformInfo.name;
    // remove the array suffix.
    if (name.endsWith("[0]")) {
      name = name.substr(0, name.length - 3);
    }
    const location = gl.getUniformLocation(program, uniformInfo.name);
    // the uniform will have no location if it's in a uniform block
    if (location) {
      const setter = createUniformSetter(program, uniformInfo, location);
      uniformSetters[name] = setter;
      addSetterToUniformTree(name, setter, uniformTree, uniformSetters);
    }
  }

  return uniformSetters;
}

/**
 * @typedef {Object} TransformFeedbackInfo
 * @property {number} index index of transform feedback
 * @property {number} type GL type
 * @property {number} size 1 - 4
 * @memberOf module:twgl
 */

/**
 * Create TransformFeedbackInfo for passing to bindTransformFeedbackInfo.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {Object<string, module:twgl.TransformFeedbackInfo>}
 * @memberOf module:twgl
 */
function createTransformFeedbackInfo(gl, program) {
  const info = {};
  const numVaryings = gl.getProgramParameter(program, TRANSFORM_FEEDBACK_VARYINGS);
  for (let ii = 0; ii < numVaryings; ++ii) {
    const varying = gl.getTransformFeedbackVarying(program, ii);
    info[varying.name] = {
      index: ii,
      type: varying.type,
      size: varying.size,
    };
  }
  return info;
}

/**
 * Binds buffers for transform feedback.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @memberOf module:twgl
 */
function bindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {
  if (transformFeedbackInfo.transformFeedbackInfo) {
    transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;
  }
  if (bufferInfo.attribs) {
    bufferInfo = bufferInfo.attribs;
  }
  for (const name in bufferInfo) {
    const varying = transformFeedbackInfo[name];
    if (varying) {
      const buf = bufferInfo[name];
      if (buf.offset) {
        gl.bindBufferRange(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer, buf.offset, buf.size);
      } else {
        gl.bindBufferBase(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer);
      }
    }
  }
}

/**
 * Creates a transform feedback and sets the buffers
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @return {WebGLTransformFeedback} the created transform feedback
 * @memberOf module:twgl
 */
function createTransformFeedback(gl, programInfo, bufferInfo) {
  const tf = gl.createTransformFeedback();
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, tf);
  gl.useProgram(programInfo.program);
  bindTransformFeedbackInfo(gl, programInfo, bufferInfo);
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, null);
  return tf;
}

/**
 * @typedef {Object} UniformData
 * @property {string} name The name of the uniform
 * @property {number} type The WebGL type enum for this uniform
 * @property {number} size The number of elements for this uniform
 * @property {number} blockNdx The block index this uniform appears in
 * @property {number} offset The byte offset in the block for this uniform's value
 * @memberOf module:twgl
 */

/**
 * The specification for one UniformBlockObject
 *
 * @typedef {Object} BlockSpec
 * @property {number} index The index of the block.
 * @property {number} size The size in bytes needed for the block
 * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices
 *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.
 * @property {bool} usedByVertexShader Self explanatory
 * @property {bool} usedByFragmentShader Self explanatory
 * @property {bool} used Self explanatory
 * @memberOf module:twgl
 */

/**
 * A `UniformBlockSpec` represents the data needed to create and bind
 * UniformBlockObjects for a given program
 *
 * @typedef {Object} UniformBlockSpec
 * @property {Object.<string, module:twgl.BlockSpec>} blockSpecs The BlockSpec for each block by block name
 * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.
 * @memberOf module:twgl
 */

/**
 * Creates a UniformBlockSpec for the given program.
 *
 * A UniformBlockSpec represents the data needed to create and bind
 * UniformBlockObjects
 *
 * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context
 * @param {WebGLProgram} program A WebGLProgram for a successfully linked program
 * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec
 * @memberOf module:twgl/programs
 */
function createUniformBlockSpecFromProgram(gl, program) {
  const numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);
  const uniformData = [];
  const uniformIndices = [];

  for (let ii = 0; ii < numUniforms; ++ii) {
    uniformIndices.push(ii);
    uniformData.push({});
    const uniformInfo = gl.getActiveUniform(program, ii);
    uniformData[ii].name = uniformInfo.name;
  }

  [
    [ "UNIFORM_TYPE", "type" ],
    [ "UNIFORM_SIZE", "size" ],  // num elements
    [ "UNIFORM_BLOCK_INDEX", "blockNdx" ],
    [ "UNIFORM_OFFSET", "offset", ],
  ].forEach(function(pair) {
    const pname = pair[0];
    const key = pair[1];
    gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function(value, ndx) {
      uniformData[ndx][key] = value;
    });
  });

  const blockSpecs = {};

  const numUniformBlocks = gl.getProgramParameter(program, ACTIVE_UNIFORM_BLOCKS);
  for (let ii = 0; ii < numUniformBlocks; ++ii) {
    const name = gl.getActiveUniformBlockName(program, ii);
    const blockSpec = {
      index: gl.getUniformBlockIndex(program, name),
      usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
      usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
      size: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_DATA_SIZE),
      uniformIndices: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),
    };
    blockSpec.used = blockSpec.usedByVertexShader || blockSpec.usedByFragmentShader;
    blockSpecs[name] = blockSpec;
  }

  return {
    blockSpecs: blockSpecs,
    uniformData: uniformData,
  };
}

const arraySuffixRE = /\[\d+\]\.$/;  // better way to check?

const pad = (v, padding) => ((v + (padding - 1)) / padding | 0) * padding;

function createUniformBlockUniformSetter(view, isArray, rows, cols) {
  if (isArray || rows) {
    cols = cols || 1;
    const numElements = view.length;
    const totalRows = numElements / 4;
    return function(value) {
      let dst = 0;
      let src = 0;
      for (let row = 0; row < totalRows; ++row) {
        for (let col = 0; col < cols; ++col) {
          view[dst++] = value[src++];
        }
        dst += 4 - cols;
      }
    };
  } else {
    return function(value) {
      if (value.length) {
        view.set(value);
      } else {
        view[0] = value;
      }
    };
  }
}

/**
 * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values
 * and a corresponding WebGLBuffer to hold those values on the GPU
 *
 * @typedef {Object} UniformBlockInfo
 * @property {string} name The name of the block
 * @property {ArrayBuffer} array The array buffer that contains the uniform values
 * @property {Float32Array} asFloat A float view on the array buffer. This is useful
 *    inspecting the contents of the buffer in the debugger.
 * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.
 * @property {number} [offset] offset into buffer
 * @property {Object<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.
 *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset
 *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`
 *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an
 *   `Int32Array` view, etc.
 * @property {Object<string, function>} setters A setter for this uniform.
 *   The reason to use setters is elements of arrays are padded to vec4 sizes which
 *   means if you want to set an array of 4 floats you'd need to set 16 values
 *   (or set elements 0, 4, 8, 12). In other words
 *   `someBlockInfo.uniforms.some4FloatArrayUniform.set([0, , , , 1, , , , 2, , , , 3])`
 *   where as the setter handles just passing in [0, 1, 2, 3] either directly as in
 *   `someBlockInfo.setter.some4FloatArrayUniform.set([0, 1, 2, 3])` (not recommended)
 *   or via {@link module:twgl.setBlockUniforms}
 * @memberOf module:twgl
 */

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {WebGLProgram} program A WebGLProgram
 * @param {module:twgl.UniformBlockSpec} uniformBlockSpec. A UniformBlockSpec as returned
 *     from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */
function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {
  const blockSpecs = uniformBlockSpec.blockSpecs;
  const uniformData = uniformBlockSpec.uniformData;
  const blockSpec = blockSpecs[blockName];
  if (!blockSpec) {
    warn("no uniform block object named:", blockName);
    return {
      name: blockName,
      uniforms: {},
    };
  }
  const array = new ArrayBuffer(blockSpec.size);
  const buffer = gl.createBuffer();
  const uniformBufferIndex = blockSpec.index;
  gl.bindBuffer(UNIFORM_BUFFER, buffer);
  gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);

  let prefix = blockName + ".";
  if (arraySuffixRE.test(prefix)) {
    prefix = prefix.replace(arraySuffixRE, ".");
  }
  const uniforms = {};
  const setters = {};
  const setterTree = {};
  blockSpec.uniformIndices.forEach(function(uniformNdx) {
    const data = uniformData[uniformNdx];
    let name = data.name;
    if (name.startsWith(prefix)) {
      name = name.substr(prefix.length);
    }
    const isArray = name.endsWith('[0]');
    if (isArray) {
      name = name.substr(0, name.length - 3);
    }
    const typeInfo = typeMap[data.type];
    const Type = typeInfo.Type;
    const byteLength = isArray
        ? pad(typeInfo.size, 16) * data.size
        : typeInfo.size * data.size;
    const uniformView = new Type(array, data.offset, byteLength / Type.BYTES_PER_ELEMENT);
    uniforms[name] = uniformView;
    // Note: I'm not sure what to do here. The original
    // idea was to create TypedArray views into each part
    // of the block. This is useful, for example if you have
    // a block with { mat4: model; mat4 view; mat4 projection; }
    // you'll get a Float32Array for each one suitable for
    // passing to most JS math libraries including twgl's and glMatrix.js.
    //
    // But, if you have a an array of structures, especially if that
    // array is large, you get a whole bunch of TypedArray views.
    // Every one of them has overhead and switching between them all
    // is probably a cache miss. In that case it would really be better
    // to just have one view (asFloat) and have all the setters
    // just reference the correct portion. But, then you can't easily
    // treat a matrix, or a vec4, as a standalone thing like you can
    // with all the views.
    //
    // Another problem with the views is they are not shared. With
    // uniforms you have one set of setters. With UniformBlockInfo
    // you have a set of setters *pre block instance*. That's because
    // TypedArray views can't be mapped to different buffers.
    //
    // My gut right now is if you really want the speed and compactness
    // then you should probably roll your own solution. TWGL's goal
    // here is ease of use as AFAICT there is no simple generic efficient
    // solution.
    const setter = createUniformBlockUniformSetter(uniformView, isArray, typeInfo.rows, typeInfo.cols);
    setters[name] = setter;
    addSetterToUniformTree(name, setter, setterTree, setters);
  });
  return {
    name: blockName,
    array,
    asFloat: new Float32Array(array),  // for debugging
    buffer,
    uniforms,
    setters,
  };
}

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo}
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */
function createUniformBlockInfo(gl, programInfo, blockName) {
  return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);
}

/**
 * Binds a uniform block to the matching uniform block point.
 * Matches by blocks by name so blocks must have the same name not just the same
 * structure.
 *
 * If you have changed any values and you upload the values into the corresponding WebGLBuffer
 * call {@link module:twgl.setUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name
 *     no buffer is bound.
 * @memberOf module:twgl/programs
 */
function bindUniformBlock(gl, programInfo, uniformBlockInfo) {
  const uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;
  const blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];
  if (blockSpec) {
    const bufferBindIndex = blockSpec.index;
    gl.bindBufferRange(UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);
    return true;
  }
  return false;
}

/**
 * Uploads the current uniform values to the corresponding WebGLBuffer
 * and binds that buffer to the program's corresponding bind point for the uniform block object.
 *
 * If you haven't changed any values and you only need to bind the uniform block object
 * call {@link module:twgl.bindUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @memberOf module:twgl/programs
 */
function setUniformBlock(gl, programInfo, uniformBlockInfo) {
  if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {
    gl.bufferData(UNIFORM_BUFFER, uniformBlockInfo.array, DYNAMIC_DRAW);
  }
}

/**
 * Sets values of a uniform block object
 *
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.
 * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given
 *    type of uniform. So for example given a block like
 *
 *       uniform SomeBlock {
 *         float someFloat;
 *         vec2 someVec2;
 *         vec3 someVec3Array[2];
 *         int someInt;
 *       }
 *
 *  You can set the values of the uniform block with
 *
 *       twgl.setBlockUniforms(someBlockInfo, {
 *          someFloat: 12.3,
 *          someVec2: [1, 2],
 *          someVec3Array: [1, 2, 3, 4, 5, 6],
 *          someInt: 5,
 *       }
 *
 *  Arrays can be JavaScript arrays or typed arrays
 *
 *  You can also fill out structure and array values either via
 *  shortcut. Example
 *
 *     // -- in shader --
 *     struct Light {
 *       float intensity;
 *       vec4 color;
 *       float nearFar[2];
 *     };
 *     uniform Lights {
 *       Light lights[2];
 *     };
 *
 *     // in JavaScript
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       lights: [
 *         { intensity: 5.0, color: [1, 0, 0, 1], nearFar[0.1, 10] },
 *         { intensity: 2.0, color: [0, 0, 1, 1], nearFar[0.2, 15] },
 *       ],
 *     });
 *
 *   or the more traditional way
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       "lights[0].intensity": 5.0,
 *       "lights[0].color": [1, 0, 0, 1],
 *       "lights[0].nearFar": [0.1, 10],
 *       "lights[1].intensity": 2.0,
 *       "lights[1].color": [0, 0, 1, 1],
 *       "lights[1].nearFar": [0.2, 15],
 *     });
 *
 *   You can also specify partial paths
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       'lights[1]': { intensity: 5.0, color: [1, 0, 0, 1], nearFar[0.2, 15] },
 *     });
 *
 *   But you can not specify leaf array indices.
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       'lights[1].nearFar[1]': 15,     // BAD! nearFar is a leaf
 *       'lights[1].nearFar': [0.2, 15], // GOOD
 *     });
 *
 *  **IMPORTANT!**, packing in a UniformBlock is unintuitive.
 *  For example the actual layout of `someVec3Array` above in memory
 *  is `1, 2, 3, unused, 4, 5, 6, unused`. twgl takes in 6 values
 *  as shown about and copies them, skipping the padding. This might
 *  be confusing if you're already familiar with Uniform blocks.
 *
 *  If you want to deal with the padding yourself you can access the array
 *  buffer views directly. eg:
 *
 *      someBlockInfo.someVec3Array.set([1, 2, 3, 0, 4, 5, 6, 0]);
 *
 *  Any name that doesn't match will be ignored
 * @memberOf module:twgl/programs
 */
function setBlockUniforms(uniformBlockInfo, values) {
  const setters = uniformBlockInfo.setters;
  for (const name in values) {
    const setter = setters[name];
    if (setter) {
      const value = values[name];
      setter(value);
    }
  }
}

function setUniformTree(tree, values) {
  for (const name in values) {
    const prop = tree[name];
    if (typeof prop === 'function') {
      prop(values[name]);
    } else {
      setUniformTree(tree[name], values[name]);
    }
  }
}

/**
 * Set uniforms and binds related textures.
 *
 * example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs"]);
 *
 *     const tex1 = gl.createTexture();
 *     const tex2 = gl.createTexture();
 *
 *     ... assume we setup the textures with data ...
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     gl.useProgram(programInfo.program);
 *
 * This will automatically bind the textures AND set the
 * uniforms.
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *
 * For the example above it is equivalent to
 *
 *     let texUnit = 0;
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex1);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex2);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
 *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
 *     gl.uniformMatrix4fv(u_someMatrix, false, [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ]);
 *
 * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *     };
 *
 *     const moreUniforms {
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *     twgl.setUniforms(programInfo, moreUniforms);
 *
 * You can also add WebGLSamplers to uniform samplers as in
 *
 *     const uniforms = {
 *       u_someSampler: {
 *         texture: someWebGLTexture,
 *         sampler: someWebGLSampler,
 *       },
 *     };
 *
 * In which case both the sampler and texture will be bound to the
 * same unit.
 *
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 *        uniforms.
 *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example
 *
 *     const sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     const localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, sharedUniforms);
 *     twgl.setUniforms(programInfo, localUniforms};
 *
 *   You can also fill out structure and array values either via
 *   shortcut. Example
 *
 *     // -- in shader --
 *     struct Light {
 *       float intensity;
 *       vec4 color;
 *       float nearFar[2];
 *     };
 *     uniform Light lights[2];
 *
 *     // in JavaScript
 *
 *     twgl.setUniforms(programInfo, {
 *       lights: [
 *         { intensity: 5.0, color: [1, 0, 0, 1], nearFar[0.1, 10] },
 *         { intensity: 2.0, color: [0, 0, 1, 1], nearFar[0.2, 15] },
 *       ],
 *     });
 *
 *   or the more traditional way
 *
 *     twgl.setUniforms(programInfo, {
 *       "lights[0].intensity": 5.0,
 *       "lights[0].color": [1, 0, 0, 1],
 *       "lights[0].nearFar": [0.1, 10],
 *       "lights[1].intensity": 2.0,
 *       "lights[1].color": [0, 0, 1, 1],
 *       "lights[1].nearFar": [0.2, 15],
 *     });
 *
 *   You can also specify partial paths
 *
 *     twgl.setUniforms(programInfo, {
 *       'lights[1]': { intensity: 5.0, color: [1, 0, 0, 1], nearFar[0.2, 15] },
 *     });
 *
 *   But you can not specify leaf array indices
 *
 *     twgl.setUniforms(programInfo, {
 *       'lights[1].nearFar[1]': 15,     // BAD! nearFar is a leaf
 *       'lights[1].nearFar': [0.2, 15], // GOOD
 *     });
 *
 * @memberOf module:twgl/programs
 */
function setUniforms(setters, ...args) {  // eslint-disable-line
  const actualSetters = setters.uniformSetters || setters;
  const numArgs = args.length;
  for (let aNdx = 0; aNdx < numArgs; ++aNdx) {
    const values = args[aNdx];
    if (Array.isArray(values)) {
      const numValues = values.length;
      for (let ii = 0; ii < numValues; ++ii) {
        setUniforms(actualSetters, values[ii]);
      }
    } else {
      for (const name in values) {
        const setter = actualSetters[name];
        if (setter) {
          setter(values[name]);
        }
      }
    }
  }
}

/**
 * Alias for `setUniforms`
 * @function
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 * @memberOf module:twgl/programs
 */
const setUniformsAndBindTextures = setUniforms;

/**
 * Creates setter functions for all attributes of a shader
 * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.
 *
 * @see {@link module:twgl.setAttributes} for example
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @return {Object.<string, function>} an object with a setter for each attribute by name.
 * @memberOf module:twgl/programs
 */
function createAttributeSetters(gl, program) {
  const attribSetters = {
  };

  const numAttribs = gl.getProgramParameter(program, ACTIVE_ATTRIBUTES);
  for (let ii = 0; ii < numAttribs; ++ii) {
    const attribInfo = gl.getActiveAttrib(program, ii);
    if (isBuiltIn(attribInfo)) {
      continue;
    }
    const index = gl.getAttribLocation(program, attribInfo.name);
    const typeInfo = attrTypeMap[attribInfo.type];
    const setter = typeInfo.setter(gl, index, typeInfo);
    setter.location = index;
    attribSetters[attribInfo.name] = setter;
  }

  return attribSetters;
}

/**
 * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})
 *
 * Example:
 *
 *     const program = createProgramFromScripts(
 *         gl, ["some-vs", "some-fs");
 *
 *     const attribSetters = createAttributeSetters(program);
 *
 *     const positionBuffer = gl.createBuffer();
 *     const texcoordBuffer = gl.createBuffer();
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setAttributes(attribSetters, attribs);
 *
 * Properties of attribs. For each attrib you can add
 * properties:
 *
 * *   type: the type of data in the buffer. Default = gl.FLOAT
 * *   normalize: whether or not to normalize the data. Default = false
 * *   stride: the stride. Default = 0
 * *   offset: offset into the buffer. Default = 0
 * *   divisor: the divisor for instances. Default = undefined
 *
 * For example if you had 3 value float positions, 2 value
 * float texcoord and 4 value uint8 colors you'd setup your
 * attribs like this
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *       a_color: {
 *         buffer: colorBuffer,
 *         numComponents: 4,
 *         type: gl.UNSIGNED_BYTE,
 *         normalize: true,
 *       },
 *     };
 *
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.
 * @memberOf module:twgl/programs
 * @deprecated use {@link module:twgl.setBuffersAndAttributes}
 * @private
 */
function setAttributes(setters, buffers) {
  for (const name in buffers) {
    const setter = setters[name];
    if (setter) {
      setter(buffers[name]);
    }
  }
}

/**
 * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate
 *
 * Example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs");
 *
 *     const arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *     };
 *
 *     const bufferInfo = createBufferInfoFromArrays(gl, arrays);
 *
 *     gl.useProgram(programInfo.program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setBuffersAndAttributes(gl, programInfo, bufferInfo);
 *
 * For the example above it is equivalent to
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
 *     gl.enableVertexAttribArray(a_positionLocation);
 *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
 *     gl.enableVertexAttribArray(a_texcoordLocation);
 *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgramInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.
 *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}
 * @memberOf module:twgl/programs
 */
function setBuffersAndAttributes(gl, programInfo, buffers) {
  if (buffers.vertexArrayObject) {
    gl.bindVertexArray(buffers.vertexArrayObject);
  } else {
    setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);
    if (buffers.indices) {
      gl.bindBuffer(ELEMENT_ARRAY_BUFFER$1, buffers.indices);
    }
  }
}

/**
 * @typedef {Object} ProgramInfo
 * @property {WebGLProgram} program A shader program
 * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,
 * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,
 * @property {module:twgl.UniformBlockSpec} [uniformBlockSpec] a uniform block spec for making UniformBlockInfos with createUniformBlockInfo etc..
 * @property {Object<string, module:twgl.TransformFeedbackInfo>} [transformFeedbackInfo] info for transform feedbacks
 * @memberOf module:twgl
 */

/**
 * Creates a ProgramInfo from an existing program.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {module:twgl.ProgramInfo} The created ProgramInfo.
 * @memberOf module:twgl/programs
 */
function createProgramInfoFromProgram(gl, program) {
  const uniformSetters = createUniformSetters(gl, program);
  const attribSetters = createAttributeSetters(gl, program);
  const programInfo = {
    program,
    uniformSetters,
    attribSetters,
  };

  if (isWebGL2(gl)) {
    programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);
    programInfo.transformFeedbackInfo = createTransformFeedbackInfo(gl, program);
  }

  return programInfo;
}

const notIdRE = /\s|{|}|;/;

/**
 * Creates a ProgramInfo from 2 sources.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramInfo(gl, [vs, fs], options);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders or ids. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]|module:twgl.ErrorCallback} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile
 * @memberOf module:twgl/programs
 */
function createProgramInfo(
    gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const errors = [];
  shaderSources = shaderSources.map(function(source) {
    // Lets assume if there is no \n it's an id
    if (!notIdRE.test(source)) {
      const script = getElementById(source);
      if (!script) {
        const err = `no element with id: ${source}`;
        progOptions.errorCallback(err);
        errors.push(err);
      } else {
        source = script.text;
      }
    }
    return source;
  });

  if (errors.length) {
    return reportError(progOptions, '');
  }

  const origCallback = progOptions.callback;
  if (origCallback) {
    progOptions.callback = (err, program) => {
      origCallback(err, err ? undefined : createProgramInfoFromProgram(gl, program));
    };
  }

  const program = createProgramFromSources(gl, shaderSources, progOptions);
  if (!program) {
    return null;
  }

  return createProgramInfoFromProgram(gl, program);
}

function checkAllPrograms(gl, programs, programSpecs, noDeleteShadersSet, programOptions) {
  // check errors for everything.
  for (const [name, program] of Object.entries(programs)) {
    const options = {...programOptions};
    const spec = programSpecs[name];
    if (!Array.isArray(spec)) {
      Object.assign(options, spec);
    }
    const errors = getProgramErrors(gl, program, options.errorCallback);
    if (errors) {
      // delete everything we created
      for (const program of Object.values(programs)) {
        const shaders = gl.getAttachedShaders(program);
        gl.deleteProgram(program);
        for (const shader of shaders) {
          // Don't delete it if we didn't create it.
          if (!noDeleteShadersSet.has(shader)) {
            gl.deleteShader(shader);
          }
        }
      }
      return errors;
    }
  }

  return undefined;
}

/**
 * Creates multiple programs
 *
 * Note: the reason this function exists is because the fastest way to create multiple
 * programs in WebGL is to create and compile all shaders and link all programs and only
 * afterwards check if they succeeded. In that way, giving all your shaders
 *
 * @see {@link module:twgl.createProgram}
 *
 * Example:
 *
 *     const programs = twgl.createPrograms(gl, {
 *       lambert: [lambertVS, lambertFS],
 *       phong: [phongVS, phoneFS],
 *       particles: {
 *         shaders: [particlesVS, particlesFS],
 *         transformFeedbackVaryings: ['position', 'velocity'],
 *       },
 *     });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string, module:twgl.ProgramSpec>} programSpecs An object of ProgramSpecs, one per program.
 * @param {module:twgl.ProgramOptions} [programOptions] options to apply to all programs
 * @return {Object.<string, WebGLProgram>?} the created programInfos by name
 */
function createPrograms(gl, programSpecs, programOptions = {}) {
  // Remember existing shaders so that if there is an error we don't delete them
  const noDeleteShadersSet = new Set();

  // compile and link everything
  const programs = Object.fromEntries(Object.entries(programSpecs).map(([name, spec]) => {
    const options = {...programOptions};
    const shaders = Array.isArray(spec) ? spec : spec.shaders;
    if (!Array.isArray(spec)) {
      Object.assign(options, spec);
    }
    shaders.forEach(noDeleteShadersSet.add, noDeleteShadersSet);
    return [name, createProgramNoCheck(gl, shaders, options)];
  }));

  if (programOptions.callback) {
    waitForAllProgramsLinkCompletionAsync(gl, programs).then(() => {
      const errors = checkAllPrograms(gl, programs, programSpecs, noDeleteShadersSet, programOptions);
      programOptions.callback(errors, errors ? undefined : programs);
    });
    return undefined;
  }

  const errors = checkAllPrograms(gl, programs, programSpecs, noDeleteShadersSet, programOptions);
  return errors ? undefined : programs;
}

/**
 * Creates multiple programInfos
 *
 * Note: the reason this function exists is because the fastest way to create multiple
 * programs in WebGL is to create and compile all shaders and link all programs and only
 * afterwards check if they succeeded. In that way, giving all your shaders
 *
 * @see {@link module:twgl.createProgramInfo}
 *
 * Examples:
 *
 *     const programInfos = twgl.createProgramInfos(gl, {
 *       lambert: [lambertVS, lambertFS],
 *       phong: [phongVS, phoneFS],
 *       particles: {
 *         shaders: [particlesVS, particlesFS],
 *         transformFeedbackVaryings: ['position', 'velocity'],
 *       },
 *     });
 *
 * or
 *
 *     const {lambert, phong, particles} = twgl.createProgramInfos(gl, {
 *       lambert: [lambertVS, lambertFS],
 *       phong: [phongVS, phoneFS],
 *       particles: {
 *         shaders: [particlesVS, particlesFS],
 *         transformFeedbackVaryings: ['position', 'velocity'],
 *       },
 *     });
 *
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string, module:twgl.ProgramSpec>} programSpecs An object of ProgramSpecs, one per program.
 * @param {module:twgl.ProgramOptions} [programOptions] options to apply to all programs
 * @return {Object.<string, module:twgl.ProgramInfo>?} the created programInfos by name
 */
function createProgramInfos(gl, programSpecs, programOptions) {
  programOptions = getProgramOptions(programOptions);

  function createProgramInfosForPrograms(gl, programs) {
    return Object.fromEntries(Object.entries(programs).map(([name, program]) =>
      [name, createProgramInfoFromProgram(gl, program)]
    ));
  }

  const origCallback = programOptions.callback;
  if (origCallback) {
    programOptions.callback = (err, programs) => {
      origCallback(err, err ? undefined : createProgramInfosForPrograms(gl, programs));
    };
  }

  const programs = createPrograms(gl, programSpecs, programOptions);
  if (origCallback || !programs) {
    return undefined;
  }

  return createProgramInfosForPrograms(gl, programs);
}

/**
 * Creates multiple programs asynchronously
 *
 * @see {@link module:twgl.createProgramAsync}
 *
 * Example:
 *
 *     const programs = await twgl.createProgramsAsync(gl, {
 *       lambert: [lambertVS, lambertFS],
 *       phong: [phongVS, phoneFS],
 *       particles: {
 *         shaders: [particlesVS, particlesFS],
 *         transformFeedbackVaryings: ['position', 'velocity'],
 *       },
 *     });
 *
 * @function
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string, module:twgl.ProgramSpec>} programSpecs An object of ProgramSpecs, one per program.
 * @param {module:twgl.ProgramOptions} [programOptions] options to apply to all programs
 * @return {Object.<string, WebGLProgram>?} the created programInfos by name
 */
const createProgramsAsync = wrapCallbackFnToAsyncFn(createPrograms);

/**
 * Creates multiple programInfos asynchronously
 *
 * @see {@link module:twgl.createProgramInfoAsync}
 *
 * Example:
 *
 *     const programInfos = await twgl.createProgramInfosAsync(gl, {
 *       lambert: [lambertVS, lambertFS],
 *       phong: [phongVS, phoneFS],
 *       particles: {
 *         shaders: [particlesVS, particlesFS],
 *         transformFeedbackVaryings: ['position', 'velocity'],
 *       },
 *     });
 *
 * @function
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string, module:twgl.ProgramSpec>} programSpecs An object of ProgramSpecs, one per program.
 * @param {module:twgl.ProgramOptions} [programOptions] options to apply to all programs
 * @return {Promise<Object.<string, module:twgl.ProgramInfo>>} the created programInfos by name
 */
const createProgramInfosAsync = wrapCallbackFnToAsyncFn(createProgramInfos);

var programs = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createAttributeSetters: createAttributeSetters,
  createProgram: createProgram,
  createProgramAsync: createProgramAsync,
  createPrograms: createPrograms,
  createProgramsAsync: createProgramsAsync,
  createProgramFromScripts: createProgramFromScripts,
  createProgramFromSources: createProgramFromSources,
  createProgramInfo: createProgramInfo,
  createProgramInfoAsync: createProgramInfoAsync,
  createProgramInfos: createProgramInfos,
  createProgramInfosAsync: createProgramInfosAsync,
  createProgramInfoFromProgram: createProgramInfoFromProgram,
  createUniformSetters: createUniformSetters,
  createUniformBlockSpecFromProgram: createUniformBlockSpecFromProgram,
  createUniformBlockInfoFromProgram: createUniformBlockInfoFromProgram,
  createUniformBlockInfo: createUniformBlockInfo,
  createTransformFeedback: createTransformFeedback,
  createTransformFeedbackInfo: createTransformFeedbackInfo,
  bindTransformFeedbackInfo: bindTransformFeedbackInfo,
  setAttributes: setAttributes,
  setBuffersAndAttributes: setBuffersAndAttributes,
  setUniforms: setUniforms,
  setUniformsAndBindTextures: setUniformsAndBindTextures,
  setUniformBlock: setUniformBlock,
  setBlockUniforms: setBlockUniforms,
  bindUniformBlock: bindUniformBlock
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const TRIANGLES                      = 0x0004;
const UNSIGNED_SHORT                 = 0x1403;

/**
 * Drawing related functions
 *
 * For backward compatibility they are available at both `twgl.draw` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/draw
 */

/**
 * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate
 *
 * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself
 * but calling this means if you switch from indexed data to non-indexed
 * data you don't have to remember to update your draw call.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or
 *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @param {number} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`
 * @param {number} [count] An optional count. Defaults to bufferInfo.numElements
 * @param {number} [offset] An optional offset. Defaults to 0.
 * @param {number} [instanceCount] An optional instanceCount. if set then `drawArraysInstanced` or `drawElementsInstanced` will be called
 * @memberOf module:twgl/draw
 */
function drawBufferInfo(gl, bufferInfo, type, count, offset, instanceCount) {
  type = type === undefined ? TRIANGLES : type;
  const indices = bufferInfo.indices;
  const elementType = bufferInfo.elementType;
  const numElements = count === undefined ? bufferInfo.numElements : count;
  offset = offset === undefined ? 0 : offset;
  if (elementType || indices) {
    if (instanceCount !== undefined) {
      gl.drawElementsInstanced(type, numElements, elementType === undefined ? UNSIGNED_SHORT : bufferInfo.elementType, offset, instanceCount);
    } else {
      gl.drawElements(type, numElements, elementType === undefined ? UNSIGNED_SHORT : bufferInfo.elementType, offset);
    }
  } else {
    if (instanceCount !== undefined) {
      gl.drawArraysInstanced(type, offset, numElements, instanceCount);
    } else {
      gl.drawArrays(type, offset, numElements);
    }
  }
}

/**
 * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.
 *
 * You need either a `BufferInfo` or a `VertexArrayInfo`.
 *
 * @typedef {Object} DrawObject
 * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In other words `undefined` = `true`
 * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...
 * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}
 * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @property {Object<string, ?>} uniforms The values for the uniforms.
 *   You can pass multiple objects by putting them in an array. For example
 *
 *     var sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     var localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     var drawObj = {
 *       ...
 *       uniforms: [sharedUniforms, localUniforms],
 *     };
 *
 * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.
 * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to bufferInfo.numElements.
 * @property {number} [instanceCount] the number of instances. Defaults to undefined.
 * @memberOf module:twgl
 */

/**
 * Draws a list of objects
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {DrawObject[]} objectsToDraw an array of objects to draw.
 * @memberOf module:twgl/draw
 */
function drawObjectList(gl, objectsToDraw) {
  let lastUsedProgramInfo = null;
  let lastUsedBufferInfo = null;

  objectsToDraw.forEach(function(object) {
    if (object.active === false) {
      return;
    }

    const programInfo = object.programInfo;
    const bufferInfo = object.vertexArrayInfo || object.bufferInfo;
    let bindBuffers = false;
    const type = object.type === undefined ? TRIANGLES : object.type;

    if (programInfo !== lastUsedProgramInfo) {
      lastUsedProgramInfo = programInfo;
      gl.useProgram(programInfo.program);

      // We have to rebind buffers when changing programs because we
      // only bind buffers the program uses. So if 2 programs use the same
      // bufferInfo but the 1st one uses only positions the when the
      // we switch to the 2nd one some of the attributes will not be on.
      bindBuffers = true;
    }

    // Setup all the needed attributes.
    if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
      if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {
        gl.bindVertexArray(null);
      }
      lastUsedBufferInfo = bufferInfo;
      setBuffersAndAttributes(gl, programInfo, bufferInfo);
    }

    // Set the uniforms.
    setUniforms(programInfo, object.uniforms);

    // Draw
    drawBufferInfo(gl, bufferInfo, type, object.count, object.offset, object.instanceCount);
  });

  if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject) {
    gl.bindVertexArray(null);
  }
}

var draw = /*#__PURE__*/Object.freeze({
  __proto__: null,
  drawBufferInfo: drawBufferInfo,
  drawObjectList: drawObjectList
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const FRAMEBUFFER                    = 0x8d40;
const RENDERBUFFER                   = 0x8d41;
const TEXTURE_2D                     = 0x0de1;

const UNSIGNED_BYTE                  = 0x1401;

/* PixelFormat */
const DEPTH_COMPONENT                = 0x1902;
const RGBA                           = 0x1908;
const DEPTH_COMPONENT24              = 0x81a6;
const DEPTH_COMPONENT32F             = 0x8cac;
const DEPTH24_STENCIL8               = 0x88f0;
const DEPTH32F_STENCIL8              = 0x8cad;

/* Framebuffer Object. */
const RGBA4                          = 0x8056;
const RGB5_A1                        = 0x8057;
const RGB565                         = 0x8D62;
const DEPTH_COMPONENT16              = 0x81A5;
const STENCIL_INDEX                  = 0x1901;
const STENCIL_INDEX8                 = 0x8D48;
const DEPTH_STENCIL                  = 0x84F9;
const COLOR_ATTACHMENT0              = 0x8CE0;
const DEPTH_ATTACHMENT               = 0x8D00;
const STENCIL_ATTACHMENT             = 0x8D20;
const DEPTH_STENCIL_ATTACHMENT       = 0x821A;

/* TextureWrapMode */
const CLAMP_TO_EDGE                  = 0x812F;

/* TextureMagFilter */
const LINEAR                         = 0x2601;

/**
 * The options for a framebuffer attachment.
 *
 * Note: For a `format` that is a texture include all the texture
 * options from {@link module:twgl.TextureOptions} for example
 * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}
 * `auto` defaults to `false` for attachment textures but `min` and `mag` default
 * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`
 *
 * @typedef {Object} AttachmentOptions
 * @property {number} [attachmentPoint] The attachment point. Defaults
 *   to `gl.COLOR_ATTACHMENT0 + ndx` unless type is a depth or stencil type
 *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending
 *   on the format or attachment type.
 * @property {number} [format] The format. If one of `gl.RGBA4`,
 *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,
 *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a
 *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`
 * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.
 * @property {number} [target] The texture target for `gl.framebufferTexture2D`.
 *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.
 * @property {number} [samples] The number of samples. Default = 1
 * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.
 * @property {number} [layer] layer for `gl.framebufferTextureLayer`. Defaults to undefined.
 *   If set then `gl.framebufferTextureLayer` is called, if not then `gl.framebufferTexture2D`
 * @property {(WebGLRenderbuffer | WebGLTexture)} [attachment] An existing renderbuffer or texture.
 *    If provided will attach this Object. This allows you to share
 *    attachments across framebuffers.
 * @memberOf module:twgl
 * @mixes module:twgl.TextureOptions
 */

const defaultAttachments = [
  { format: RGBA, type: UNSIGNED_BYTE, min: LINEAR, wrap: CLAMP_TO_EDGE, },
  { format: DEPTH_STENCIL, },
];

const attachmentsByFormat = {};
attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT24] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT32F] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH24_STENCIL8] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH32F_STENCIL8] = DEPTH_STENCIL_ATTACHMENT;

function getAttachmentPointForFormat(format, internalFormat) {
  return attachmentsByFormat[format] || attachmentsByFormat[internalFormat];
}

const renderbufferFormats = {};
renderbufferFormats[RGBA4] = true;
renderbufferFormats[RGB5_A1] = true;
renderbufferFormats[RGB565] = true;
renderbufferFormats[DEPTH_STENCIL] = true;
renderbufferFormats[DEPTH_COMPONENT16] = true;
renderbufferFormats[STENCIL_INDEX] = true;
renderbufferFormats[STENCIL_INDEX8] = true;

function isRenderbufferFormat(format) {
  return renderbufferFormats[format];
}

const MAX_COLOR_ATTACHMENT_POINTS = 32;  // even an 3090 only supports 8 but WebGL/OpenGL ES define constants for 32

function isColorAttachmentPoint(attachmentPoint) {
  return attachmentPoint >= COLOR_ATTACHMENT0 && attachmentPoint < COLOR_ATTACHMENT0 + MAX_COLOR_ATTACHMENT_POINTS;
}

/**
 * @typedef {Object} FramebufferInfo
 * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo
 * @property {Array.<(WebGLRenderbuffer | WebGLTexture)>} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.
 * @property {number} width The width of the framebuffer and its attachments
 * @property {number} height The width of the framebuffer and its attachments
 * @memberOf module:twgl
 */

/**
 * Creates a framebuffer and attachments.
 *
 * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.
 * It also leaves the framebuffer it just created as the currently bound `FRAMEBUFFER`.
 * Note: If this is WebGL2 or if you called {@link module:twgl.addExtensionsToContext} then it will set the drawBuffers
 * to `[COLOR_ATTACHMENT0, COLOR_ATTACHMENT1, ...]` for how ever many color attachments were created.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 * Passing in a specific size
 *
 *     const width = 256;
 *     const height = 256;
 *     const fbi = twgl.createFramebufferInfo(gl, attachments, width, height);
 *
 * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.
 * [WebGL1 only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an
 *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.
 * @memberOf module:twgl/framebuffers
 */
function createFramebufferInfo(gl, attachments, width, height) {
  const target = FRAMEBUFFER;
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(target, fb);
  width  = width  || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  attachments = attachments || defaultAttachments;
  const usedColorAttachmentsPoints = [];
  const framebufferInfo = {
    framebuffer: fb,
    attachments: [],
    width: width,
    height: height,
  };

  attachments.forEach(function(attachmentOptions, i) {
    let attachment = attachmentOptions.attachment;
    const samples = attachmentOptions.samples;
    const format = attachmentOptions.format;
    let attachmentPoint = attachmentOptions.attachmentPoint || getAttachmentPointForFormat(format, attachmentOptions.internalFormat);
    if (!attachmentPoint) {
      attachmentPoint = COLOR_ATTACHMENT0 + i;
    }
    if (isColorAttachmentPoint(attachmentPoint)) {
      usedColorAttachmentsPoints.push(attachmentPoint);
    }
    if (!attachment) {
      if (samples !== undefined || isRenderbufferFormat(format)) {
        attachment = gl.createRenderbuffer();
        gl.bindRenderbuffer(RENDERBUFFER, attachment);
        if (samples > 1) {
          gl.renderbufferStorageMultisample(RENDERBUFFER, samples, format, width, height);
        } else {
          gl.renderbufferStorage(RENDERBUFFER, format, width, height);
        }
      } else {
        const textureOptions = Object.assign({}, attachmentOptions);
        textureOptions.width = width;
        textureOptions.height = height;
        if (textureOptions.auto === undefined) {
          textureOptions.auto = false;
          textureOptions.min = textureOptions.min || textureOptions.minMag || LINEAR;
          textureOptions.mag = textureOptions.mag || textureOptions.minMag || LINEAR;
          textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || CLAMP_TO_EDGE;
          textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || CLAMP_TO_EDGE;
        }
        attachment = createTexture(gl, textureOptions);
      }
    }
    if (isRenderbuffer(gl, attachment)) {
      gl.framebufferRenderbuffer(target, attachmentPoint, RENDERBUFFER, attachment);
    } else if (isTexture(gl, attachment)) {
      if (attachmentOptions.layer !== undefined) {
        gl.framebufferTextureLayer(
          target,
          attachmentPoint,
          attachment,
          attachmentOptions.level || 0,
          attachmentOptions.layer);
      } else {
        gl.framebufferTexture2D(
            target,
            attachmentPoint,
            attachmentOptions.target || TEXTURE_2D,
            attachment,
            attachmentOptions.level || 0);
      }
    } else {
      throw new Error('unknown attachment type');
    }
    framebufferInfo.attachments.push(attachment);
  });
  if (gl.drawBuffers) {
    gl.drawBuffers(usedColorAttachmentsPoints);
  }
  return framebufferInfo;
}

/**
 * Resizes the attachments of a framebuffer.
 *
 * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebufferInfo}
 * because TWGL has no idea the format/type of each attachment.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments
 *         twgl.resizeFramebufferInfo(gl, fbi);
 *       }
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments to match
 *         twgl.resizeFramebufferInfo(gl, fbi, attachments);
 *       }
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebufferInfo}.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @memberOf module:twgl/framebuffers
 */
function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {
  width  = width  || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  framebufferInfo.width = width;
  framebufferInfo.height = height;
  attachments = attachments || defaultAttachments;
  attachments.forEach(function(attachmentOptions, ndx) {
    const attachment = framebufferInfo.attachments[ndx];
    const format = attachmentOptions.format;
    const samples = attachmentOptions.samples;
    if (samples !== undefined || isRenderbuffer(gl, attachment)) {
      gl.bindRenderbuffer(RENDERBUFFER, attachment);
      if (samples > 1) {
        gl.renderbufferStorageMultisample(RENDERBUFFER, samples, format, width, height);
      } else {
        gl.renderbufferStorage(RENDERBUFFER, format, width, height);
      }
    } else if (isTexture(gl, attachment)) {
      resizeTexture(gl, attachment, attachmentOptions, width, height);
    } else {
      throw new Error('unknown attachment type');
    }
  });
}

/**
 * Binds a framebuffer
 *
 * This function pretty much solely exists because I spent hours
 * trying to figure out why something I wrote wasn't working only
 * to realize I forget to set the viewport dimensions.
 * My hope is this function will fix that.
 *
 * It is effectively the same as
 *
 *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);
 *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo|null} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 *   If falsy will bind the canvas.
 * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.
 * @memberOf module:twgl/framebuffers
 */

function bindFramebufferInfo(gl, framebufferInfo, target) {
  target = target || FRAMEBUFFER;
  if (framebufferInfo) {
    gl.bindFramebuffer(target, framebufferInfo.framebuffer);
    gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);
  } else {
    gl.bindFramebuffer(target, null);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
}

var framebuffers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bindFramebufferInfo: bindFramebufferInfo,
  createFramebufferInfo: createFramebufferInfo,
  resizeFramebufferInfo: resizeFramebufferInfo
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * vertex array object related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/vertexArrays
 */

const ELEMENT_ARRAY_BUFFER           = 0x8893;

/**
 * @typedef {Object} VertexArrayInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLVertexArrayObject} [vertexArrayObject] a vertex array object
 * @memberOf module:twgl
 */

/**
 * Creates a VertexArrayInfo from a BufferInfo and one or more ProgramInfos
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects
 *   assign buffers to specific attributes at creation time. That means they can only be used with programs
 *   who's attributes use the same attribute locations for the same purposes.
 *
 * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}
 *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.
 *
 * also
 *
 * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object
 *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**
 *   will affect the Vertex Array Object state.
 *
 * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 *
 *    You need to make sure every attribute that will be used is bound. So for example assume shader 1
 *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo
 *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't
 *    now attribute D's location.
 *
 *    So, you can pass in both shader 1 and shader 2's programInfo
 *
 * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo
 *
 * @memberOf module:twgl/vertexArrays
 */
function createVertexArrayInfo(gl, programInfos, bufferInfo) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  if (!programInfos.length) {
    programInfos = [programInfos];
  }
  programInfos.forEach(function(programInfo) {
    setBuffersAndAttributes(gl, programInfo, bufferInfo);
  });
  gl.bindVertexArray(null);
  return {
    numElements: bufferInfo.numElements,
    elementType: bufferInfo.elementType,
    vertexArrayObject: vao,
  };
}

/**
 * Creates a vertex array object and then sets the attributes on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} attribs AttribInfos mapped by attribute name.
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 *
 * @return {WebGLVertexArrayObject|null} The created WebGLVertexArrayObject
 *
 * @memberOf module:twgl/vertexArrays
 */
function createVAOAndSetAttributes(gl, setters, attribs, indices) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  setAttributes(setters, attribs);
  if (indices) {
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER, indices);
  }
  // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER
  // like when creating buffers for other stuff will mess up this VAO's binding
  gl.bindVertexArray(null);
  return vao;
}

/**
 * Creates a vertex array object and then sets the attributes
 * on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {Object.<string, function>| module:twgl.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 *
 * @return {WebGLVertexArrayObject|null} The created WebGLVertexArrayObject
 *
 * @memberOf module:twgl/vertexArrays
 */
function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {
  return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);
}

var vertexArrays = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createVertexArrayInfo: createVertexArrayInfo,
  createVAOAndSetAttributes: createVAOAndSetAttributes,
  createVAOFromBufferInfo: createVAOFromBufferInfo
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
const defaults = {
  addExtensionsToContext: true,
};

/**
 * Various default settings for twgl.
 *
 * Note: You can call this any number of times. Example:
 *
 *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });
 *     twgl.setDefaults({ attribPrefix: 'a_' });
 *
 * is equivalent to
 *
 *     twgl.setDefaults({
 *       textureColor: [1, 0, 0, 1],
 *       attribPrefix: 'a_',
 *     });
 *
 * @typedef {Object} Defaults
 * @property {string} [attribPrefix] The prefix to stick on attributes
 *
 *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 *   as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 *   In other words I'll create arrays of geometry like this
 *
 *       const arrays = {
 *         position: ...
 *         normal: ...
 *         texcoord: ...
 *       };
 *
 *   But need those mapped to attributes and my attributes start with `a_`.
 *
 *   Default: `""`
 *
 * @property {number[]} [textureColor] Array of 4 values in the range 0 to 1
 *
 *   The default texture color is used when loading textures from
 *   urls. Because the URL will be loaded async we'd like to be
 *   able to use the texture immediately. By putting a 1x1 pixel
 *   color in the texture we can start using the texture before
 *   the URL has loaded.
 *
 *   Default: `[0.5, 0.75, 1, 1]`
 *
 * @property {string} [crossOrigin]
 *
 *   If not undefined sets the crossOrigin attribute on images
 *   that twgl creates when downloading images for textures.
 *
 *   Also see {@link module:twgl.TextureOptions}.
 *
 * @property {bool} [addExtensionsToContext]
 *
 *   If true, then, when twgl will try to add any supported WebGL extensions
 *   directly to the context under their normal GL names. For example
 *   if ANGLE_instances_arrays exists then twgl would enable it,
 *   add the functions `vertexAttribDivisor`, `drawArraysInstanced`,
 *   `drawElementsInstanced`, and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR`
 *   to the `WebGLRenderingContext`.
 *
 * @memberOf module:twgl
 */

/**
 * Sets various defaults for twgl.
 *
 * In the interest of terseness which is kind of the point
 * of twgl I've integrated a few of the older functions here
 *
 * @param {module:twgl.Defaults} newDefaults The default settings.
 * @memberOf module:twgl
 */
function setDefaults(newDefaults) {
  copyExistingProperties(newDefaults, defaults);
  setDefaults$2(newDefaults);  // eslint-disable-line
  setDefaults$1(newDefaults);  // eslint-disable-line
}

const prefixRE = /^(.*?)_/;
function addExtensionToContext(gl, extensionName) {
  glEnumToString(gl, 0);
  const ext = gl.getExtension(extensionName);
  if (ext) {
    const enums = {};
    const fnSuffix = prefixRE.exec(extensionName)[1];
    const enumSuffix = '_' + fnSuffix;
    for (const key in ext) {
      const value = ext[key];
      const isFunc = typeof (value) === 'function';
      const suffix = isFunc ? fnSuffix : enumSuffix;
      let name = key;
      // examples of where this is not true are WEBGL_compressed_texture_s3tc
      // and WEBGL_compressed_texture_pvrtc
      if (key.endsWith(suffix)) {
        name = key.substring(0, key.length - suffix.length);
      }
      if (gl[name] !== undefined) {
        if (!isFunc && gl[name] !== value) {
          warn$1(name, gl[name], value, key);
        }
      } else {
        if (isFunc) {
          gl[name] = function(origFn) {
            return function() {
              return origFn.apply(ext, arguments);
            };
          }(value);
        } else {
          gl[name] = value;
          enums[name] = value;
        }
      }
    }
    // pass the modified enums to glEnumToString
    enums.constructor = {
      name: ext.constructor.name,
    };
    glEnumToString(enums, 0);
  }
  return ext;
}

/*
 * If you're wondering why the code doesn't just iterate
 * over all extensions using `gl.getExtensions` is that it's possible
 * some future extension is incompatible with this code. Rather than
 * have thing suddenly break it seems better to manually add to this
 * list.
 *
 */
const supportedExtensions = [
  'ANGLE_instanced_arrays',
  'EXT_blend_minmax',
  'EXT_color_buffer_float',
  'EXT_color_buffer_half_float',
  'EXT_disjoint_timer_query',
  'EXT_disjoint_timer_query_webgl2',
  'EXT_frag_depth',
  'EXT_sRGB',
  'EXT_shader_texture_lod',
  'EXT_texture_filter_anisotropic',
  'OES_element_index_uint',
  'OES_standard_derivatives',
  'OES_texture_float',
  'OES_texture_float_linear',
  'OES_texture_half_float',
  'OES_texture_half_float_linear',
  'OES_vertex_array_object',
  'WEBGL_color_buffer_float',
  'WEBGL_compressed_texture_atc',
  'WEBGL_compressed_texture_etc1',
  'WEBGL_compressed_texture_pvrtc',
  'WEBGL_compressed_texture_s3tc',
  'WEBGL_compressed_texture_s3tc_srgb',
  'WEBGL_depth_texture',
  'WEBGL_draw_buffers',
];

/**
 * Attempts to enable all of the following extensions
 * and add their functions and constants to the
 * `WebGLRenderingContext` using their normal non-extension like names.
 *
 *      ANGLE_instanced_arrays
 *      EXT_blend_minmax
 *      EXT_color_buffer_float
 *      EXT_color_buffer_half_float
 *      EXT_disjoint_timer_query
 *      EXT_disjoint_timer_query_webgl2
 *      EXT_frag_depth
 *      EXT_sRGB
 *      EXT_shader_texture_lod
 *      EXT_texture_filter_anisotropic
 *      OES_element_index_uint
 *      OES_standard_derivatives
 *      OES_texture_float
 *      OES_texture_float_linear
 *      OES_texture_half_float
 *      OES_texture_half_float_linear
 *      OES_vertex_array_object
 *      WEBGL_color_buffer_float
 *      WEBGL_compressed_texture_atc
 *      WEBGL_compressed_texture_etc1
 *      WEBGL_compressed_texture_pvrtc
 *      WEBGL_compressed_texture_s3tc
 *      WEBGL_compressed_texture_s3tc_srgb
 *      WEBGL_depth_texture
 *      WEBGL_draw_buffers
 *
 * For example if `ANGLE_instanced_arrays` exists then the functions
 * `drawArraysInstanced`, `drawElementsInstanced`, `vertexAttribDivisor`
 * and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR` are added to the
 * `WebGLRenderingContext`.
 *
 * Note that if you want to know if the extension exists you should
 * probably call `gl.getExtension` for each extension. Alternatively
 * you can check for the existence of the functions or constants that
 * are expected to be added. For example
 *
 *    if (gl.drawBuffers) {
 *      // Either WEBGL_draw_buffers was enabled OR you're running in WebGL2
 *      ....
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @memberOf module:twgl
 */
function addExtensionsToContext(gl) {
  for (let ii = 0; ii < supportedExtensions.length; ++ii) {
    addExtensionToContext(gl, supportedExtensions[ii]);
  }
}

/**
 * Creates a webgl context.
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 * @private
 */
function create3DContext(canvas, opt_attribs) {
  const names = ["webgl", "experimental-webgl"];
  let context = null;
  for (let ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);
    if (context) {
      if (defaults.addExtensionsToContext) {
        addExtensionsToContext(context);
      }
      break;
    }
  }
  return context;
}

/**
 * Gets a WebGL1 context.
 *
 * Note: Will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 * @deprecated
 * @private
 */
function getWebGLContext(canvas, opt_attribs) {
  const gl = create3DContext(canvas, opt_attribs);
  return gl;
}

/**
 * Creates a webgl context.
 *
 * Will return a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *     twgl.isWebGL2(gl);
 *
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 */
function createContext(canvas, opt_attribs) {
  const names = ["webgl2", "webgl", "experimental-webgl"];
  let context = null;
  for (let ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);
    if (context) {
      if (defaults.addExtensionsToContext) {
        addExtensionsToContext(context);
      }
      break;
    }
  }
  return context;
}

/**
 * Gets a WebGL context.  Will create a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *    function isWebGL2(gl) {
 *      return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0 ") == 0;
 *    }
 *
 * Note: For a WebGL1 context will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */
function getContext(canvas, opt_attribs) {
  const gl = createContext(canvas, opt_attribs);
  return gl;
}

/**
 * Resize a canvas to match the size it's displayed.
 * @param {HTMLCanvasElement} canvas The canvas to resize.
 * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` or other scale value if you want to.
 * @return {boolean} true if the canvas was resized.
 * @memberOf module:twgl
 */
function resizeCanvasToDisplaySize(canvas, multiplier) {
  multiplier = multiplier || 1;
  multiplier = Math.max(0, multiplier);
  const width  = canvas.clientWidth  * multiplier | 0;
  const height = canvas.clientHeight * multiplier | 0;
  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    return true;
  }
  return false;
}




/***/ }),

/***/ "./src/ExampleShaderSketch.js":
/*!************************************!*\
  !*** ./src/ExampleShaderSketch.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ExampleShaderSketch)
/* harmony export */ });
/* harmony import */ var _ShaderSketchBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderSketchBase */ "./src/ShaderSketchBase.js");


class ExampleShaderSketch extends _ShaderSketchBase__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(canvas, fragmentShader, vertexShader) {
    super(canvas, fragmentShader, vertexShader);
  }

  update(time) {
    super.update(time);
  }
}

/***/ }),

/***/ "./src/ShaderSketchBase.js":
/*!*********************************!*\
  !*** ./src/ShaderSketchBase.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ShaderSketchBase)
/* harmony export */ });
/* harmony import */ var twgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/5.x/twgl-full.module.js");
/**
 * Represents a base class for shader sketches.
 * @class
 */


class ShaderSketchBase {
  /**
   * Constructs a new instance of ShaderSketchBase. Not intended to be called directly, and instead used as a base class.
   * @param {HTMLCanvasElement} canvas - The canvas element to render the shader sketch.
   * @param {string} fragmentShader - The fragment shader code.
   * @param {string} vertexShader - The vertex shader code.
   */
  constructor(canvas, fragmentShader, vertexShader) {
    this.canvas = canvas;
    this.gl = canvas.getContext('webgl2');
    this.fragmentShader = fragmentShader;
    this.vertexShader = vertexShader;
    this.animationFrameId = null;

    this.programInfo = (0,twgl_js__WEBPACK_IMPORTED_MODULE_0__.createProgramInfo)(this.gl, [this.vertexShader, this.fragmentShader]);
    this.bufferInfo = (0,twgl_js__WEBPACK_IMPORTED_MODULE_0__.createBufferInfoFromArrays)(this.gl, {
      position: {
        numComponents: 2,
        data: [
          -1, -1,
          1, -1,
          -1,  1,
          -1,  1,
          1, -1,
          1,  1,
        ],
      },
    });

    this.uniforms = {
      u_time: 0,
      u_resolution: [this.canvas.width, this.canvas.height],
      u_mouse: [0, 0],
    };

    this.canvas.addEventListener("mousemove", (event) => {
      this.uniforms.u_mouse = this.getNormalizedMousePosition(event);
    });
  }
  
  /**
   * Renders the shader sketch. Used through requestAnimationFrame looping.
   * 
   * @private
   * @param {number} time - The current time in milliseconds.
   */
  render(time) {
    (0,twgl_js__WEBPACK_IMPORTED_MODULE_0__.resizeCanvasToDisplaySize)(this.canvas);
    this.update(time);

    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    this.gl.useProgram(this.programInfo.program);
    (0,twgl_js__WEBPACK_IMPORTED_MODULE_0__.setBuffersAndAttributes)(this.gl, this.programInfo, this.bufferInfo);
    (0,twgl_js__WEBPACK_IMPORTED_MODULE_0__.setUniforms)(this.programInfo, this.uniforms);
    (0,twgl_js__WEBPACK_IMPORTED_MODULE_0__.drawBufferInfo)(this.gl, this.bufferInfo);

    this.animationFrameId = requestAnimationFrame(this.render.bind(this));
  }

  /**
   * Updates the shader sketch base. Intended to be overridden by subclasses. 
   * Call super.update(time) to update the default uniforms. Called before the sketch is rendered.
   * 
   * @param {number} time - The current time in milliseconds.
   */
  update(time) {
    Object.assign(this.uniforms, {
      u_time: time * 0.001,
      u_resolution: [this.canvas.width, this.canvas.height],
    });
  }

  /**
   * Starts the rendering process by requesting an animation frame.
   */
  start() {
    this.animationFrameId = requestAnimationFrame(this.render.bind(this));
  }

  /**
   * Stops the animation frame.
   */
  stop() {
    cancelAnimationFrame(this.animationFrameId);
  }


  /**
   * Calculates the mouse position normalized to a range of [0, 1]. Intended to be used in the mousemove event listener.
   * 
   * @private
   * @param {MouseEvent} event - The mouse event object.
   * @returns {number[]} - The normalized mouse position as an array of two values.
   */
  getNormalizedMousePosition(event) {
    return [
      event.offsetX / this.canvas.clientWidth,
      event.offsetY / this.canvas.clientHeight,
    ];
  }
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ExampleShaderSketch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExampleShaderSketch */ "./src/ExampleShaderSketch.js");
/* harmony import */ var _shaders_frag_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/frag.glsl */ "./src/shaders/frag.glsl");
/* harmony import */ var _shaders_frag_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shaders_frag_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shaders_vert_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders/vert.glsl */ "./src/shaders/vert.glsl");
/* harmony import */ var _shaders_vert_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_vert_glsl__WEBPACK_IMPORTED_MODULE_2__);




const canvas = document.querySelector("#canvas");
const sketch = new _ExampleShaderSketch__WEBPACK_IMPORTED_MODULE_0__["default"](canvas, (_shaders_frag_glsl__WEBPACK_IMPORTED_MODULE_1___default()), (_shaders_vert_glsl__WEBPACK_IMPORTED_MODULE_2___default()));
sketch.start();

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkIsWUFBWSxxQkFBcUI7QUFDakMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGOztBQUV4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQStFO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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aC1iYXNlLy4vc3JjL3NoYWRlcnMvZnJhZy5nbHNsIiwid2VicGFjazovL2x5Z2lhLXNrZXRjaC1iYXNlLy4vc3JjL3NoYWRlcnMvdmVydC5nbHNsIiwid2VicGFjazovL2x5Z2lhLXNrZXRjaC1iYXNlLy4vbm9kZV9tb2R1bGVzL3R3Z2wuanMvZGlzdC81LngvdHdnbC1mdWxsLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9seWdpYS1za2V0Y2gtYmFzZS8uL3NyYy9FeGFtcGxlU2hhZGVyU2tldGNoLmpzIiwid2VicGFjazovL2x5Z2lhLXNrZXRjaC1iYXNlLy4vc3JjL1NoYWRlclNrZXRjaEJhc2UuanMiLCJ3ZWJwYWNrOi8vbHlnaWEtc2tldGNoLWJhc2Uvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbHlnaWEtc2tldGNoLWJhc2Uvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vbHlnaWEtc2tldGNoLWJhc2Uvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2x5Z2lhLXNrZXRjaC1iYXNlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbHlnaWEtc2tldGNoLWJhc2Uvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9seWdpYS1za2V0Y2gtYmFzZS8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxyXFxuXFxyXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxyXFxuXFxyXFxuLypcXHJcXG5jb250cmlidXRvcnM6IFtTdGVmYW4gR3VzdGF2c29uLCBJYW4gTWNFd2FuXVxcclxcbmRlc2NyaXB0aW9uOiBtb2R1bHVzIG9mIDI4OVxcclxcbnVzZTogPGZsb2F0fHZlYzJ8dmVjM3x2ZWM0PiBtb2QyODkoPGZsb2F0fHZlYzJ8dmVjM3x2ZWM0PiB4KVxcclxcbiovXFxyXFxuXFxyXFxuI2lmbmRlZiBGTkNfTU9EMjg5XFxyXFxuI2RlZmluZSBGTkNfTU9EMjg5XFxyXFxuXFxyXFxuZmxvYXQgbW9kMjg5KGNvbnN0IGluIGZsb2F0IHgpIHsgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjsgfVxcclxcbnZlYzIgbW9kMjg5KGNvbnN0IGluIHZlYzIgeCkgeyByZXR1cm4geCAtIGZsb29yKHggKiAoMS4gLyAyODkuKSkgKiAyODkuOyB9XFxyXFxudmVjMyBtb2QyODkoY29uc3QgaW4gdmVjMyB4KSB7IHJldHVybiB4IC0gZmxvb3IoeCAqICgxLiAvIDI4OS4pKSAqIDI4OS47IH1cXHJcXG52ZWM0IG1vZDI4OShjb25zdCBpbiB2ZWM0IHgpIHsgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjsgfVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbi8qXFxyXFxuY29udHJpYnV0b3JzOiBbU3RlZmFuIEd1c3RhdnNvbiwgSWFuIE1jRXdhbl1cXHJcXG5kZXNjcmlwdGlvbjogbW9kdWx1cyBvZiAyODlcXHJcXG51c2U6IDxmbG9hdHx2ZWMyfHZlYzN8dmVjND4gbW9kMjg5KDxmbG9hdHx2ZWMyfHZlYzN8dmVjND4geClcXHJcXG4qL1xcclxcblxcclxcbiNpZm5kZWYgRk5DX01PRDI4OVxcclxcbiNkZWZpbmUgRk5DX01PRDI4OVxcclxcblxcclxcbmZsb2F0IG1vZDI4OShjb25zdCBpbiBmbG9hdCB4KSB7IHJldHVybiB4IC0gZmxvb3IoeCAqICgxLiAvIDI4OS4pKSAqIDI4OS47IH1cXHJcXG52ZWMyIG1vZDI4OShjb25zdCBpbiB2ZWMyIHgpIHsgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjsgfVxcclxcbnZlYzMgbW9kMjg5KGNvbnN0IGluIHZlYzMgeCkgeyByZXR1cm4geCAtIGZsb29yKHggKiAoMS4gLyAyODkuKSkgKiAyODkuOyB9XFxyXFxudmVjNCBtb2QyODkoY29uc3QgaW4gdmVjNCB4KSB7IHJldHVybiB4IC0gZmxvb3IoeCAqICgxLiAvIDI4OS4pKSAqIDI4OS47IH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG5cXHJcXG4vKlxcclxcbmNvbnRyaWJ1dG9yczogW1N0ZWZhbiBHdXN0YXZzb24sIElhbiBNY0V3YW5dXFxyXFxuZGVzY3JpcHRpb246IHBlcm11dGVcXHJcXG51c2U6IDxmbG9hdHx2ZWMyfHZlYzN8dmVjND4gcGVybXV0ZSg8ZmxvYXR8dmVjMnx2ZWMzfHZlYzQ+IHgpXFxyXFxuZXhhbXBsZXM6XFxyXFxuICAgIC0gaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3BhdHJpY2lvZ29uemFsZXp2aXZvL2x5Z2lhX2V4YW1wbGVzL21haW4vbWF0aF9mdW5jdGlvbnMuZnJhZ1xcclxcbiovXFxyXFxuXFxyXFxuI2lmbmRlZiBGTkNfUEVSTVVURVxcclxcbiNkZWZpbmUgRk5DX1BFUk1VVEVcXHJcXG5cXHJcXG5mbG9hdCBwZXJtdXRlKGNvbnN0IGluIGZsb2F0IHYpIHsgcmV0dXJuIG1vZDI4OSgoKHYgKiAzNC4wKSArIDEuMCkgKiB2KTsgfVxcclxcbnZlYzIgcGVybXV0ZShjb25zdCBpbiB2ZWMyIHYpIHsgcmV0dXJuIG1vZDI4OSgoKHYgKiAzNC4wKSArIDEuMCkgKiB2KTsgfVxcclxcbnZlYzMgcGVybXV0ZShjb25zdCBpbiB2ZWMzIHYpIHsgcmV0dXJuIG1vZDI4OSgoKHYgKiAzNC4wKSArIDEuMCkgKiB2KTsgfVxcclxcbnZlYzQgcGVybXV0ZShjb25zdCBpbiB2ZWM0IHYpIHsgcmV0dXJuIG1vZDI4OSgoKHYgKiAzNC4wKSArIDEuMCkgKiB2KTsgfVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbi8qXFxyXFxuY29udHJpYnV0b3JzOiBbU3RlZmFuIEd1c3RhdnNvbiwgSWFuIE1jRXdhbl1cXHJcXG5kZXNjcmlwdGlvbjogRmFzdCwgYWNjdXJhdGUgaW52ZXJzZSBzcXVhcmUgcm9vdC4gXFxyXFxudXNlOiA8ZmxvYXR8dmVjMnx2ZWMzfHZlYzQ+IHRheWxvckludlNxcnQoPGZsb2F0fHZlYzJ8dmVjM3x2ZWM0PiB4KVxcclxcbiovXFxyXFxuXFxyXFxuI2lmbmRlZiBGTkNfVEFZTE9SSU5WU1FSVFxcclxcbiNkZWZpbmUgRk5DX1RBWUxPUklOVlNRUlRcXHJcXG5mbG9hdCB0YXlsb3JJbnZTcXJ0KGluIGZsb2F0IHIpIHsgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjsgfVxcclxcbnZlYzIgdGF5bG9ySW52U3FydChpbiB2ZWMyIHIpIHsgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjsgfVxcclxcbnZlYzMgdGF5bG9ySW52U3FydChpbiB2ZWMzIHIpIHsgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjsgfVxcclxcbnZlYzQgdGF5bG9ySW52U3FydChpbiB2ZWM0IHIpIHsgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjsgfVxcclxcbiNlbmRpZlxcclxcbi8qXFxyXFxuY29udHJpYnV0b3JzOiBbU3RlZmFuIEd1c3RhdnNvbiwgSWFuIE1jRXdhbl1cXHJcXG5kZXNjcmlwdGlvbjogZ3JhZDQsIHVzZWQgZm9yIHNub2lzZSh2ZWM0IHYpXFxyXFxudXNlOiBncmFkNCg8ZmxvYXQ+IGosIDx2ZWM0PiBpcClcXHJcXG4qL1xcclxcblxcclxcbiNpZm5kZWYgRk5DX0dSQUQ0XFxyXFxuI2RlZmluZSBGTkNfR1JBRDRcXHJcXG52ZWM0IGdyYWQ0KGZsb2F0IGosIHZlYzQgaXApIHtcXHJcXG4gICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAtMS4wKTtcXHJcXG4gICAgdmVjNCBwLHM7XFxyXFxuICAgIHAueHl6ID0gZmxvb3IoIGZyYWN0ICh2ZWMzKGopICogaXAueHl6KSAqIDcuMCkgKiBpcC56IC0gMS4wO1xcclxcbiAgICBwLncgPSAxLjUgLSBkb3QoYWJzKHAueHl6KSwgb25lcy54eXopO1xcclxcbiAgICBzID0gdmVjNChsZXNzVGhhbihwLCB2ZWM0KDAuMCkpKTtcXHJcXG4gICAgcC54eXogPSBwLnh5eiArIChzLnh5eioyLjAgLSAxLjApICogcy53d3c7XFxyXFxuICAgIHJldHVybiBwO1xcclxcbn1cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG5cXHJcXG4vKlxcclxcbmNvbnRyaWJ1dG9yczogW1N0ZWZhbiBHdXN0YXZzb24sIElhbiBNY0V3YW5dXFxyXFxuZGVzY3JpcHRpb246IFNpbXBsZXggTm9pc2UgaHR0cHM6Ly9naXRodWIuY29tL3N0ZWd1L3dlYmdsLW5vaXNlXFxyXFxudXNlOiBzbm9pc2UoPHZlYzJ8dmVjM3x2ZWM0PiBwb3MpXFxyXFxubGljZW5zZTogfFxcclxcbiAgICBDb3B5cmlnaHQgMjAyMS0yMDIzIGJ5IFN0ZWZhbiBHdXN0YXZzb24gYW5kIElhbiBNY0V3YW4uXFxyXFxuICAgIFB1Ymxpc2hlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlOlxcclxcbiAgICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2UvbWl0L1xcclxcbmV4YW1wbGVzOlxcclxcbiAgICAtIC9zaGFkZXJzL2dlbmVyYXRpdmVfc25vaXNlLmZyYWdcXHJcXG4qL1xcclxcblxcclxcbiNpZm5kZWYgRk5DX1NOT0lTRVxcclxcbiNkZWZpbmUgRk5DX1NOT0lTRVxcclxcbmZsb2F0IHNub2lzZShpbiB2ZWMyIHYpIHtcXHJcXG4gICAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NywgIC8vICgzLjAtc3FydCgzLjApKS82LjBcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjM2NjAyNTQwMzc4NDQzOSwgIC8vIDAuNSooc3FydCgzLjApLTEuMClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAtMC41NzczNTAyNjkxODk2MjYsICAvLyAtMS4wICsgMi4wICogQy54XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4wMjQzOTAyNDM5MDI0MzkpOyAvLyAxLjAgLyA0MS4wXFxyXFxuICAgIC8vIEZpcnN0IGNvcm5lclxcclxcbiAgICB2ZWMyIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5KSApO1xcclxcbiAgICB2ZWMyIHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4KTtcXHJcXG5cXHJcXG4gICAgLy8gT3RoZXIgY29ybmVyc1xcclxcbiAgICB2ZWMyIGkxO1xcclxcbiAgICAvL2kxLnggPSBzdGVwKCB4MC55LCB4MC54ICk7IC8vIHgwLnggPiB4MC55ID8gMS4wIDogMC4wXFxyXFxuICAgIC8vaTEueSA9IDEuMCAtIGkxLng7XFxyXFxuICAgIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XFxyXFxuICAgIC8vIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4IDtcXHJcXG4gICAgLy8geDEgPSB4MCAtIGkxICsgMS4wICogQy54eCA7XFxyXFxuICAgIC8vIHgyID0geDAgLSAxLjAgKyAyLjAgKiBDLnh4IDtcXHJcXG4gICAgdmVjNCB4MTIgPSB4MC54eXh5ICsgQy54eHp6O1xcclxcbiAgICB4MTIueHkgLT0gaTE7XFxyXFxuXFxyXFxuICAgIC8vIFBlcm11dGF0aW9uc1xcclxcbiAgICBpID0gbW9kMjg5KGkpOyAvLyBBdm9pZCB0cnVuY2F0aW9uIGVmZmVjdHMgaW4gcGVybXV0YXRpb25cXHJcXG4gICAgdmVjMyBwID0gcGVybXV0ZSggcGVybXV0ZSggaS55ICsgdmVjMygwLjAsIGkxLnksIDEuMCApKVxcclxcbiAgICArIGkueCArIHZlYzMoMC4wLCBpMS54LCAxLjAgKSk7XFxyXFxuXFxyXFxuICAgIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MTIueHkseDEyLnh5KSwgZG90KHgxMi56dyx4MTIuencpKSwgMC4wKTtcXHJcXG4gICAgbSA9IG0qbSA7XFxyXFxuICAgIG0gPSBtKm0gO1xcclxcblxcclxcbiAgICAvLyBHcmFkaWVudHM6IDQxIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIGxpbmUsIG1hcHBlZCBvbnRvIGEgZGlhbW9uZC5cXHJcXG4gICAgLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQxICg0MSo3ID0gMjg3KVxcclxcblxcclxcbiAgICB2ZWMzIHggPSAyLjAgKiBmcmFjdChwICogQy53d3cpIC0gMS4wO1xcclxcbiAgICB2ZWMzIGggPSBhYnMoeCkgLSAwLjU7XFxyXFxuICAgIHZlYzMgb3ggPSBmbG9vcih4ICsgMC41KTtcXHJcXG4gICAgdmVjMyBhMCA9IHggLSBveDtcXHJcXG5cXHJcXG4gICAgLy8gTm9ybWFsaXNlIGdyYWRpZW50cyBpbXBsaWNpdGx5IGJ5IHNjYWxpbmcgbVxcclxcbiAgICAvLyBBcHByb3hpbWF0aW9uIG9mOiBtICo9IGludmVyc2VzcXJ0KCBhMCphMCArIGgqaCApO1xcclxcbiAgICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKCBhMCphMCArIGgqaCApO1xcclxcblxcclxcbiAgICAvLyBDb21wdXRlIGZpbmFsIG5vaXNlIHZhbHVlIGF0IFBcXHJcXG4gICAgdmVjMyBnO1xcclxcbiAgICBnLnggID0gYTAueCAgKiB4MC54ICArIGgueCAgKiB4MC55O1xcclxcbiAgICBnLnl6ID0gYTAueXogKiB4MTIueHogKyBoLnl6ICogeDEyLnl3O1xcclxcbiAgICByZXR1cm4gMTMwLjAgKiBkb3QobSwgZyk7XFxyXFxufVxcclxcblxcclxcblxcclxcbmZsb2F0IHNub2lzZShpbiB2ZWMzIHYpIHtcXHJcXG4gICAgY29uc3QgdmVjMiAgQyA9IHZlYzIoMS4wLzYuMCwgMS4wLzMuMCkgO1xcclxcbiAgICBjb25zdCB2ZWM0ICBEID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAyLjApO1xcclxcblxcclxcbiAgICAvLyBGaXJzdCBjb3JuZXJcXHJcXG4gICAgdmVjMyBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eXkpICk7XFxyXFxuICAgIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XFxyXFxuXFxyXFxuICAgIC8vIE90aGVyIGNvcm5lcnNcXHJcXG4gICAgdmVjMyBnID0gc3RlcCh4MC55engsIHgwLnh5eik7XFxyXFxuICAgIHZlYzMgbCA9IDEuMCAtIGc7XFxyXFxuICAgIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xcclxcbiAgICB2ZWMzIGkyID0gbWF4KCBnLnh5eiwgbC56eHkgKTtcXHJcXG5cXHJcXG4gICAgLy8gICB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eHg7XFxyXFxuICAgIC8vICAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4O1xcclxcbiAgICAvLyAgIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eDtcXHJcXG4gICAgLy8gICB4MyA9IHgwIC0gMS4wICsgMy4wICogQy54eHg7XFxyXFxuICAgIHZlYzMgeDEgPSB4MCAtIGkxICsgQy54eHg7XFxyXFxuICAgIHZlYzMgeDIgPSB4MCAtIGkyICsgQy55eXk7IC8vIDIuMCpDLnggPSAxLzMgPSBDLnlcXHJcXG4gICAgdmVjMyB4MyA9IHgwIC0gRC55eXk7ICAgICAgLy8gLTEuMCszLjAqQy54ID0gLTAuNSA9IC1ELnlcXHJcXG5cXHJcXG4gICAgLy8gUGVybXV0YXRpb25zXFxyXFxuICAgIGkgPSBtb2QyODkoaSk7XFxyXFxuICAgIHZlYzQgcCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoXFxyXFxuICAgICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcXHJcXG4gICAgICAgICAgICArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSlcXHJcXG4gICAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XFxyXFxuXFxyXFxuICAgIC8vIEdyYWRpZW50czogN3g3IHBvaW50cyBvdmVyIGEgc3F1YXJlLCBtYXBwZWQgb250byBhbiBvY3RhaGVkcm9uLlxcclxcbiAgICAvLyBUaGUgcmluZyBzaXplIDE3KjE3ID0gMjg5IGlzIGNsb3NlIHRvIGEgbXVsdGlwbGUgb2YgNDkgKDQ5KjYgPSAyOTQpXFxyXFxuICAgIGZsb2F0IG5fID0gMC4xNDI4NTcxNDI4NTc7IC8vIDEuMC83LjBcXHJcXG4gICAgdmVjMyAgbnMgPSBuXyAqIEQud3l6IC0gRC54eng7XFxyXFxuXFxyXFxuICAgIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKiBucy56KTsgIC8vICBtb2QocCw3KjcpXFxyXFxuXFxyXFxuICAgIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XFxyXFxuICAgIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8gKTsgICAgLy8gbW9kKGosTilcXHJcXG5cXHJcXG4gICAgdmVjNCB4ID0geF8gKm5zLnggKyBucy55eXl5O1xcclxcbiAgICB2ZWM0IHkgPSB5XyAqbnMueCArIG5zLnl5eXk7XFxyXFxuICAgIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcXHJcXG5cXHJcXG4gICAgdmVjNCBiMCA9IHZlYzQoIHgueHksIHkueHkgKTtcXHJcXG4gICAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcXHJcXG5cXHJcXG4gICAgLy92ZWM0IHMwID0gdmVjNChsZXNzVGhhbihiMCwwLjApKSoyLjAgLSAxLjA7XFxyXFxuICAgIC8vdmVjNCBzMSA9IHZlYzQobGVzc1RoYW4oYjEsMC4wKSkqMi4wIC0gMS4wO1xcclxcbiAgICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcXHJcXG4gICAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XFxyXFxuICAgIHZlYzQgc2ggPSAtc3RlcChoLCB2ZWM0KDAuMCkpO1xcclxcblxcclxcbiAgICB2ZWM0IGEwID0gYjAueHp5dyArIHMwLnh6eXcqc2gueHh5eSA7XFxyXFxuICAgIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcXHJcXG5cXHJcXG4gICAgdmVjMyBwMCA9IHZlYzMoYTAueHksaC54KTtcXHJcXG4gICAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcXHJcXG4gICAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcXHJcXG4gICAgdmVjMyBwMyA9IHZlYzMoYTEuencsaC53KTtcXHJcXG5cXHJcXG4gICAgLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXFxyXFxuICAgIHZlYzQgbm9ybSA9IHRheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xcclxcbiAgICBwMCAqPSBub3JtLng7XFxyXFxuICAgIHAxICo9IG5vcm0ueTtcXHJcXG4gICAgcDIgKj0gbm9ybS56O1xcclxcbiAgICBwMyAqPSBub3JtLnc7XFxyXFxuXFxyXFxuICAgIC8vIE1peCBmaW5hbCBub2lzZSB2YWx1ZVxcclxcbiAgICB2ZWM0IG0gPSBtYXgoMC42IC0gdmVjNChkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpLCBkb3QoeDMseDMpKSwgMC4wKTtcXHJcXG4gICAgbSA9IG0gKiBtO1xcclxcbiAgICByZXR1cm4gNDIuMCAqIGRvdCggbSptLCB2ZWM0KCBkb3QocDAseDApLCBkb3QocDEseDEpLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHAyLHgyKSwgZG90KHAzLHgzKSApICk7XFxyXFxufVxcclxcblxcclxcbmZsb2F0IHNub2lzZShpbiB2ZWM0IHYpIHtcXHJcXG4gICAgY29uc3QgdmVjNCAgQyA9IHZlYzQoIDAuMTM4MTk2NjAxMTI1MDExLCAgLy8gKDUgLSBzcXJ0KDUpKS8yMCAgRzRcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjI3NjM5MzIwMjI1MDAyMSwgIC8vIDIgKiBHNFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNDE0NTg5ODAzMzc1MDMyLCAgLy8gMyAqIEc0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgLTAuNDQ3MjEzNTk1NDk5OTU4KTsgLy8gLTEgKyA0ICogRzRcXHJcXG5cXHJcXG4gICAgLy8gRmlyc3QgY29ybmVyXFxyXFxuICAgIHZlYzQgaSAgPSBmbG9vcih2ICsgZG90KHYsIHZlYzQoLjMwOTAxNjk5NDM3NDk0NzQ1MSkpICk7IC8vIChzcXJ0KDUpIC0gMSkvNFxcclxcbiAgICB2ZWM0IHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4eHgpO1xcclxcblxcclxcbiAgICAvLyBPdGhlciBjb3JuZXJzXFxyXFxuXFxyXFxuICAgIC8vIFJhbmsgc29ydGluZyBvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5IEJpbGwgTGljZWEtS2FuZSwgQU1EIChmb3JtZXJseSBBVEkpXFxyXFxuICAgIHZlYzQgaTA7XFxyXFxuICAgIHZlYzMgaXNYID0gc3RlcCggeDAueXp3LCB4MC54eHggKTtcXHJcXG4gICAgdmVjMyBpc1laID0gc3RlcCggeDAuend3LCB4MC55eXogKTtcXHJcXG4gICAgLy8gIGkwLnggPSBkb3QoIGlzWCwgdmVjMyggMS4wICkgKTtcXHJcXG4gICAgaTAueCA9IGlzWC54ICsgaXNYLnkgKyBpc1guejtcXHJcXG4gICAgaTAueXp3ID0gMS4wIC0gaXNYO1xcclxcbiAgICAvLyAgaTAueSArPSBkb3QoIGlzWVoueHksIHZlYzIoIDEuMCApICk7XFxyXFxuICAgIGkwLnkgKz0gaXNZWi54ICsgaXNZWi55O1xcclxcbiAgICBpMC56dyArPSAxLjAgLSBpc1laLnh5O1xcclxcbiAgICBpMC56ICs9IGlzWVouejtcXHJcXG4gICAgaTAudyArPSAxLjAgLSBpc1laLno7XFxyXFxuXFxyXFxuICAgIC8vIGkwIG5vdyBjb250YWlucyB0aGUgdW5pcXVlIHZhbHVlcyAwLDEsMiwzIGluIGVhY2ggY2hhbm5lbFxcclxcbiAgICB2ZWM0IGkzID0gY2xhbXAoIGkwLCAwLjAsIDEuMCApO1xcclxcbiAgICB2ZWM0IGkyID0gY2xhbXAoIGkwLTEuMCwgMC4wLCAxLjAgKTtcXHJcXG4gICAgdmVjNCBpMSA9IGNsYW1wKCBpMC0yLjAsIDAuMCwgMS4wICk7XFxyXFxuXFxyXFxuICAgIC8vICB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eHh4XFxyXFxuICAgIC8vICB4MSA9IHgwIC0gaTEgICsgMS4wICogQy54eHh4XFxyXFxuICAgIC8vICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHh4XFxyXFxuICAgIC8vICB4MyA9IHgwIC0gaTMgICsgMy4wICogQy54eHh4XFxyXFxuICAgIC8vICB4NCA9IHgwIC0gMS4wICsgNC4wICogQy54eHh4XFxyXFxuICAgIHZlYzQgeDEgPSB4MCAtIGkxICsgQy54eHh4O1xcclxcbiAgICB2ZWM0IHgyID0geDAgLSBpMiArIEMueXl5eTtcXHJcXG4gICAgdmVjNCB4MyA9IHgwIC0gaTMgKyBDLnp6eno7XFxyXFxuICAgIHZlYzQgeDQgPSB4MCArIEMud3d3dztcXHJcXG5cXHJcXG4gICAgLy8gUGVybXV0YXRpb25zXFxyXFxuICAgIGkgPSBtb2QyODkoaSk7XFxyXFxuICAgIGZsb2F0IGowID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShpLncpICsgaS56KSArIGkueSkgKyBpLngpO1xcclxcbiAgICB2ZWM0IGoxID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSAoXFxyXFxuICAgICAgICAgICAgICAgIGkudyArIHZlYzQoaTEudywgaTIudywgaTMudywgMS4wICkpXFxyXFxuICAgICAgICAgICAgKyBpLnogKyB2ZWM0KGkxLnosIGkyLnosIGkzLnosIDEuMCApKVxcclxcbiAgICAgICAgICAgICsgaS55ICsgdmVjNChpMS55LCBpMi55LCBpMy55LCAxLjAgKSlcXHJcXG4gICAgICAgICAgICArIGkueCArIHZlYzQoaTEueCwgaTIueCwgaTMueCwgMS4wICkpO1xcclxcblxcclxcbiAgICAvLyBHcmFkaWVudHM6IDd4N3g2IHBvaW50cyBvdmVyIGEgY3ViZSwgbWFwcGVkIG9udG8gYSA0LWNyb3NzIHBvbHl0b3BlXFxyXFxuICAgIC8vIDcqNyo2ID0gMjk0LCB3aGljaCBpcyBjbG9zZSB0byB0aGUgcmluZyBzaXplIDE3KjE3ID0gMjg5LlxcclxcbiAgICB2ZWM0IGlwID0gdmVjNCgxLjAvMjk0LjAsIDEuMC80OS4wLCAxLjAvNy4wLCAwLjApIDtcXHJcXG5cXHJcXG4gICAgdmVjNCBwMCA9IGdyYWQ0KGowLCAgIGlwKTtcXHJcXG4gICAgdmVjNCBwMSA9IGdyYWQ0KGoxLngsIGlwKTtcXHJcXG4gICAgdmVjNCBwMiA9IGdyYWQ0KGoxLnksIGlwKTtcXHJcXG4gICAgdmVjNCBwMyA9IGdyYWQ0KGoxLnosIGlwKTtcXHJcXG4gICAgdmVjNCBwNCA9IGdyYWQ0KGoxLncsIGlwKTtcXHJcXG5cXHJcXG4gICAgLy8gTm9ybWFsaXNlIGdyYWRpZW50c1xcclxcbiAgICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXHJcXG4gICAgcDAgKj0gbm9ybS54O1xcclxcbiAgICBwMSAqPSBub3JtLnk7XFxyXFxuICAgIHAyICo9IG5vcm0uejtcXHJcXG4gICAgcDMgKj0gbm9ybS53O1xcclxcbiAgICBwNCAqPSB0YXlsb3JJbnZTcXJ0KGRvdChwNCxwNCkpO1xcclxcblxcclxcbiAgICAvLyBNaXggY29udHJpYnV0aW9ucyBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcXHJcXG4gICAgdmVjMyBtMCA9IG1heCgwLjYgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MikpLCAwLjApO1xcclxcbiAgICB2ZWMyIG0xID0gbWF4KDAuNiAtIHZlYzIoZG90KHgzLHgzKSwgZG90KHg0LHg0KSAgICAgICAgICAgICksIDAuMCk7XFxyXFxuICAgIG0wID0gbTAgKiBtMDtcXHJcXG4gICAgbTEgPSBtMSAqIG0xO1xcclxcbiAgICByZXR1cm4gNDkuMCAqICggZG90KG0wKm0wLCB2ZWMzKCBkb3QoIHAwLCB4MCApLCBkb3QoIHAxLCB4MSApLCBkb3QoIHAyLCB4MiApKSlcXHJcXG4gICAgICAgICAgICAgICAgKyBkb3QobTEqbTEsIHZlYzIoIGRvdCggcDMsIHgzICksIGRvdCggcDQsIHg0ICkgKSApICkgO1xcclxcbn1cXHJcXG5cXHJcXG52ZWMyIHNub2lzZTIoIHZlYzIgeCApe1xcclxcbiAgICBmbG9hdCBzICA9IHNub2lzZSh2ZWMyKCB4ICkpO1xcclxcbiAgICBmbG9hdCBzMSA9IHNub2lzZSh2ZWMyKCB4LnkgLSAxOS4xLCB4LnggKyA0Ny4yICkpO1xcclxcbiAgICByZXR1cm4gdmVjMiggcyAsIHMxICk7XFxyXFxufVxcclxcblxcclxcbnZlYzMgc25vaXNlMyggdmVjMyB4ICl7XFxyXFxuICAgIGZsb2F0IHMgID0gc25vaXNlKHZlYzMoIHggKSk7XFxyXFxuICAgIGZsb2F0IHMxID0gc25vaXNlKHZlYzMoIHgueSAtIDE5LjEgLCB4LnogKyAzMy40ICwgeC54ICsgNDcuMiApKTtcXHJcXG4gICAgZmxvYXQgczIgPSBzbm9pc2UodmVjMyggeC56ICsgNzQuMiAsIHgueCAtIDEyNC41ICwgeC55ICsgOTkuNCApKTtcXHJcXG4gICAgcmV0dXJuIHZlYzMoIHMgLCBzMSAsIHMyICk7XFxyXFxufVxcclxcblxcclxcbnZlYzMgc25vaXNlMyggdmVjNCB4ICl7XFxyXFxuICAgIGZsb2F0IHMgID0gc25vaXNlKHZlYzQoIHggKSk7XFxyXFxuICAgIGZsb2F0IHMxID0gc25vaXNlKHZlYzQoIHgueSAtIDE5LjEgLCB4LnogKyAzMy40ICwgeC54ICsgNDcuMiwgeC53ICkpO1xcclxcbiAgICBmbG9hdCBzMiA9IHNub2lzZSh2ZWM0KCB4LnogKyA3NC4yICwgeC54IC0gMTI0LjUgLCB4LnkgKyA5OS40LCB4LncgKSk7XFxyXFxuICAgIHJldHVybiB2ZWMzKCBzICwgczEgLCBzMiApO1xcclxcbn1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG5cXHJcXG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcclxcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xcclxcblxcclxcbmluIHZlYzIgZnJhZ1Bvc2l0aW9uO1xcclxcbm91dCB2ZWM0IGZyYWdDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICBmbG9hdCBuID0gc25vaXNlKHZlYzMoZnJhZ1Bvc2l0aW9uLCB1X3RpbWUpKTtcXHJcXG4gIGZyYWdDb2xvciA9IHZlYzQobiwgbiwgbiwgMS4wKTtcXHJcXG59XFxyXFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxyXFxuXFxyXFxuaW4gdmVjMiBwb3NpdGlvbjtcXHJcXG5vdXQgdmVjMiBmcmFnUG9zaXRpb247XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgZnJhZ1Bvc2l0aW9uID0gcG9zaXRpb247XFxyXFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcXHJcXG59XFxyXFxuXCIiLCIvKiBAbGljZW5zZSB0d2dsLmpzIDUuNS40IENvcHlyaWdodCAoYykgMjAxNSwgR3JlZ2cgVGF2YXJlcyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuQXZhaWxhYmxlIHZpYSB0aGUgTUlUIGxpY2Vuc2UuXG5zZWU6IGh0dHA6Ly9naXRodWIuY29tL2dyZWdnbWFuL3R3Z2wuanMgZm9yIGRldGFpbHMgKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKlxuICogVmVjMyBtYXRoIG1hdGggZnVuY3Rpb25zLlxuICpcbiAqIEFsbW9zdCBhbGwgZnVuY3Rpb25zIHRha2UgYW4gb3B0aW9uYWwgYGRzdGAgYXJndW1lbnQuIElmIGl0IGlzIG5vdCBwYXNzZWQgaW4gdGhlXG4gKiBmdW5jdGlvbnMgd2lsbCBjcmVhdGUgYSBuZXcgVmVjMy4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gKlxuICogICAgIHZhciB2ID0gdjMuY3Jvc3ModjEsIHYyKTsgIC8vIENyZWF0ZXMgYSBuZXcgVmVjMyB3aXRoIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIuXG4gKlxuICogb3JcbiAqXG4gKiAgICAgdmFyIHYgPSB2My5jcmVhdGUoKTtcbiAqICAgICB2My5jcm9zcyh2MSwgdjIsIHYpOyAgLy8gUHV0cyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2MSB4IHYyIGluIHZcbiAqXG4gKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gKiBhcyB0aGVyZSBpcyBhbG1vc3QgbmV2ZXIgYWxsb2NhdGlvbiB3aXRoIHRoZSBzZWNvbmQgc3R5bGUuXG4gKlxuICogSXQgaXMgYWx3YXlzIHNhdmUgdG8gcGFzcyBhbnkgdmVjdG9yIGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgdjMuY3Jvc3ModjEsIHYyLCB2MSk7ICAvLyBQdXRzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIgaW4gdjFcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvdjNcbiAqL1xuXG5sZXQgVmVjVHlwZSA9IEZsb2F0MzJBcnJheTtcblxuLyoqXG4gKiBBIEphdmFTY3JpcHQgYXJyYXkgd2l0aCAzIHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheSB3aXRoIDMgdmFsdWVzLlxuICogV2hlbiBjcmVhdGVkIGJ5IHRoZSBsaWJyYXJ5IHdpbGwgY3JlYXRlIHRoZSBkZWZhdWx0IHR5cGUgd2hpY2ggaXMgYEZsb2F0MzJBcnJheWBcbiAqIGJ1dCBjYW4gYmUgc2V0IGJ5IGNhbGxpbmcge0BsaW5rIG1vZHVsZTp0d2dsL3YzLnNldERlZmF1bHRUeXBlfS5cbiAqIEB0eXBlZGVmIHsobnVtYmVyW118RmxvYXQzMkFycmF5KX0gVmVjM1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIHRoaXMgbGlicmFyeSBjcmVhdGVzIGZvciBhIFZlYzNcbiAqIEBwYXJhbSB7Y29uc3RydWN0b3J9IGN0b3IgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZS4gRWl0aGVyIGBGbG9hdDMyQXJyYXlgIG9yIGBBcnJheWBcbiAqIEByZXR1cm4ge2NvbnN0cnVjdG9yfSBwcmV2aW91cyBjb25zdHJ1Y3RvciBmb3IgVmVjM1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRUeXBlJDEoY3Rvcikge1xuICBjb25zdCBvbGRUeXBlID0gVmVjVHlwZTtcbiAgVmVjVHlwZSA9IGN0b3I7XG4gIHJldHVybiBvbGRUeXBlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB2ZWMzOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3hdIEluaXRpYWwgeCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gSW5pdGlhbCB5IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt6XSBJbml0aWFsIHogdmFsdWUuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBjcmVhdGUkMSh4LCB5LCB6KSB7XG4gIGNvbnN0IGRzdCA9IG5ldyBWZWNUeXBlKDMpO1xuICBpZiAoeCkge1xuICAgIGRzdFswXSA9IHg7XG4gIH1cbiAgaWYgKHkpIHtcbiAgICBkc3RbMV0gPSB5O1xuICB9XG4gIGlmICh6KSB7XG4gICAgZHN0WzJdID0gejtcbiAgfVxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gQSB2ZWN0b3IgdGhhIHRpcyB0aGUgc3VtIG9mIGEgYW5kIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gYWRkKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgZHN0WzBdID0gYVswXSArIGJbMF07XG4gIGRzdFsxXSA9IGFbMV0gKyBiWzFdO1xuICBkc3RbMl0gPSBhWzJdICsgYlsyXTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgZHN0WzBdID0gYVswXSAtIGJbMF07XG4gIGRzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICBkc3RbMl0gPSBhWzJdIC0gYlsyXTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHQsIHJldHVybnNcbiAqIGEgKyB0ICogKGIgLSBhKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IEludGVycG9sYXRpb24gY29lZmZpY2llbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBsaW5lYXIgaW50ZXJwb2xhdGVkIHJlc3VsdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBsZXJwKGEsIGIsIHQsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgZHN0WzBdID0gYVswXSArIHQgKiAoYlswXSAtIGFbMF0pO1xuICBkc3RbMV0gPSBhWzFdICsgdCAqIChiWzFdIC0gYVsxXSk7XG4gIGRzdFsyXSA9IGFbMl0gKyB0ICogKGJbMl0gLSBhWzJdKTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHZlY3RvciB0LCByZXR1cm5zXG4gKiBhICsgdCAqIChiIC0gYSkuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHQgSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudHMgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSB0aGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gbGVycFYoYSwgYiwgdCwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSBhWzBdICsgdFswXSAqIChiWzBdIC0gYVswXSk7XG4gIGRzdFsxXSA9IGFbMV0gKyB0WzFdICogKGJbMV0gLSBhWzFdKTtcbiAgZHN0WzJdID0gYVsyXSArIHRbMl0gKiAoYlsyXSAtIGFbMl0pO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogUmV0dXJuIG1heCB2YWx1ZXMgb2YgdHdvIHZlY3RvcnMuXG4gKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgcmV0dXJuc1xuICogW21heChhWzBdLCBiWzBdKSwgbWF4KGFbMV0sIGJbMV0pLCBtYXgoYVsyXSwgYlsyXSldLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgbWF4IGNvbXBvbmVudHMgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIG1heChhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGRzdFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBkc3RbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgZHN0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gbWluIHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gKiBbbWluKGFbMF0sIGJbMF0pLCBtaW4oYVsxXSwgYlsxXSksIG1pbihhWzJdLCBiWzJdKV0uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBtaW4gY29tcG9uZW50cyB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gbWluKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgZHN0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIGRzdFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBkc3RbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBzY2FsYXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBzY2FsZWQgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIG11bFNjYWxhcih2LCBrLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGRzdFswXSA9IHZbMF0gKiBrO1xuICBkc3RbMV0gPSB2WzFdICogaztcbiAgZHN0WzJdID0gdlsyXSAqIGs7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gayBUaGUgc2NhbGFyLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgc2NhbGVkIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBkaXZTY2FsYXIodiwgaywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSB2WzBdIC8gaztcbiAgZHN0WzFdID0gdlsxXSAvIGs7XG4gIGRzdFsyXSA9IHZbMl0gLyBrO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYm90aCB2ZWN0b3JzIGhhdmVcbiAqIHRocmVlIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB2ZWN0b3Igb2YgYSBjcm9zcyBiLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGNyb3NzKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgY29uc3QgdDEgPSBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdO1xuICBjb25zdCB0MiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIGRzdFswXSA9IGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV07XG4gIGRzdFsxXSA9IHQxO1xuICBkc3RbMl0gPSB0MjtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yczsgYXNzdW1lcyBib3RoIHZlY3RvcnMgaGF2ZVxuICogdGhyZWUgZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEByZXR1cm4ge251bWJlcn0gZG90IHByb2R1Y3RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYlsxXSkgKyAoYVsyXSAqIGJbMl0pO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBsZW5ndGggb2YgdmVjdG9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBsZW5ndGggb2YgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aCQxKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdICsgdlsyXSAqIHZbMl0pO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBsZW5ndGhTcSh2KSB7XG4gIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdICsgdlsyXSAqIHZbMl07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gIGNvbnN0IGR6ID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIHZlY3Rvci5cbiAqIEByZXR1cm4ge251bWJlcn0gc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBkaXN0YW5jZVNxKGEsIGIpIHtcbiAgY29uc3QgZHggPSBhWzBdIC0gYlswXTtcbiAgY29uc3QgZHkgPSBhWzFdIC0gYlsxXTtcbiAgY29uc3QgZHogPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGl0cyBFdWNsaWRlYW4gbGVuZ3RoIGFuZCByZXR1cm5zIHRoZSBxdW90aWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgbm9ybWFsaXplZCB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGEsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgY29uc3QgbGVuU3EgPSBhWzBdICogYVswXSArIGFbMV0gKiBhWzFdICsgYVsyXSAqIGFbMl07XG4gIGNvbnN0IGxlbiA9IE1hdGguc3FydChsZW5TcSk7XG4gIGlmIChsZW4gPiAwLjAwMDAxKSB7XG4gICAgZHN0WzBdID0gYVswXSAvIGxlbjtcbiAgICBkc3RbMV0gPSBhWzFdIC8gbGVuO1xuICAgIGRzdFsyXSA9IGFbMl0gLyBsZW47XG4gIH0gZWxzZSB7XG4gICAgZHN0WzBdID0gMDtcbiAgICBkc3RbMV0gPSAwO1xuICAgIGRzdFsyXSA9IDA7XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIE5lZ2F0ZXMgYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gLXYuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gbmVnYXRlJDEodiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSAtdlswXTtcbiAgZHN0WzFdID0gLXZbMV07XG4gIGRzdFsyXSA9IC12WzJdO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ29waWVzIGEgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IEEgY29weSBvZiB2LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGNvcHkkMSh2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGRzdFswXSA9IHZbMF07XG4gIGRzdFsxXSA9IHZbMV07XG4gIGRzdFsyXSA9IHZbMl07XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZFxuICogICAgIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkkMShhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGRzdFswXSA9IGFbMF0gKiBiWzBdO1xuICBkc3RbMV0gPSBhWzFdICogYlsxXTtcbiAgZHN0WzJdID0gYVsyXSAqIGJbMl07XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB2ZWN0b3Igb2YgcXVvdGllbnRzIG9mIGVudHJpZXMgb2YgYSBhbmRcbiAqICAgICBiLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGRzdFswXSA9IGFbMF0gLyBiWzBdO1xuICBkc3RbMV0gPSBhWzFdIC8gYlsxXTtcbiAgZHN0WzJdID0gYVsyXSAvIGJbMl07XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxudmFyIHYzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFkZDogYWRkLFxuICBjb3B5OiBjb3B5JDEsXG4gIGNyZWF0ZTogY3JlYXRlJDEsXG4gIGNyb3NzOiBjcm9zcyxcbiAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICBkaXN0YW5jZVNxOiBkaXN0YW5jZVNxLFxuICBkaXZpZGU6IGRpdmlkZSxcbiAgZGl2U2NhbGFyOiBkaXZTY2FsYXIsXG4gIGRvdDogZG90LFxuICBsZXJwOiBsZXJwLFxuICBsZXJwVjogbGVycFYsXG4gIGxlbmd0aDogbGVuZ3RoJDEsXG4gIGxlbmd0aFNxOiBsZW5ndGhTcSxcbiAgbWF4OiBtYXgsXG4gIG1pbjogbWluLFxuICBtdWxTY2FsYXI6IG11bFNjYWxhcixcbiAgbXVsdGlwbHk6IG11bHRpcGx5JDEsXG4gIG5lZ2F0ZTogbmVnYXRlJDEsXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICBzZXREZWZhdWx0VHlwZTogc2V0RGVmYXVsdFR5cGUkMSxcbiAgc3VidHJhY3Q6IHN1YnRyYWN0XG59KTtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIDR4NCBNYXRyaXggbWF0aCBtYXRoIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbG1vc3QgYWxsIGZ1bmN0aW9ucyB0YWtlIGFuIG9wdGlvbmFsIGBkc3RgIGFyZ3VtZW50LiBJZiBpdCBpcyBub3QgcGFzc2VkIGluIHRoZVxuICogZnVuY3Rpb25zIHdpbGwgY3JlYXRlIGEgbmV3IG1hdHJpeC4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSk7ICAvLyBDcmVhdGVzIGEgbmV3IHRyYW5zbGF0aW9uIG1hdHJpeFxuICpcbiAqIG9yXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LmNyZWF0ZSgpO1xuICogICAgIG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSwgbWF0KTsgIC8vIFB1dHMgdHJhbnNsYXRpb24gbWF0cml4IGluIG1hdC5cbiAqXG4gKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gKiBhcyB0aGVyZSBpcyBhbG1vc3QgbmV2ZXIgYWxsb2NhdGlvbiB3aXRoIHRoZSBzZWNvbmQgc3R5bGUuXG4gKlxuICogSXQgaXMgYWx3YXlzIHNhdmUgdG8gcGFzcyBhbnkgbWF0cml4IGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgY29uc3QgbWF0ID0gbTQuaWRlbnRpdHkoKTtcbiAqICAgICBjb25zdCB0cmFucyA9IG00LnRyYW5zbGF0aW9uKFsxLCAyLCAzXSk7XG4gKiAgICAgbTQubXVsdGlwbHkobWF0LCB0cmFucywgbWF0KTsgIC8vIE11bHRpcGxpZXMgbWF0ICogdHJhbnMgYW5kIHB1dHMgcmVzdWx0IGluIG1hdC5cbiAqXG4gKiBAbW9kdWxlIHR3Z2wvbTRcbiAqL1xubGV0IE1hdFR5cGUgPSBGbG9hdDMyQXJyYXk7XG5cbi8qKlxuICogQSBKYXZhU2NyaXB0IGFycmF5IHdpdGggMTYgdmFsdWVzIG9yIGEgRmxvYXQzMkFycmF5IHdpdGggMTYgdmFsdWVzLlxuICogV2hlbiBjcmVhdGVkIGJ5IHRoZSBsaWJyYXJ5IHdpbGwgY3JlYXRlIHRoZSBkZWZhdWx0IHR5cGUgd2hpY2ggaXMgYEZsb2F0MzJBcnJheWBcbiAqIGJ1dCBjYW4gYmUgc2V0IGJ5IGNhbGxpbmcge0BsaW5rIG1vZHVsZTp0d2dsL200LnNldERlZmF1bHRUeXBlfS5cbiAqIEB0eXBlZGVmIHsobnVtYmVyW118RmxvYXQzMkFycmF5KX0gTWF0NFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIHRoaXMgbGlicmFyeSBjcmVhdGVzIGZvciBhIE1hdDRcbiAqIEBwYXJhbSB7Y29uc3RydWN0b3J9IGN0b3IgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZS4gRWl0aGVyIGBGbG9hdDMyQXJyYXlgIG9yIGBBcnJheWBcbiAqIEByZXR1cm4ge2NvbnN0cnVjdG9yfSBwcmV2aW91cyBjb25zdHJ1Y3RvciBmb3IgTWF0NFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRUeXBlKGN0b3IpIHtcbiAgY29uc3Qgb2xkVHlwZSA9IE1hdFR5cGU7XG4gIE1hdFR5cGUgPSBjdG9yO1xuICByZXR1cm4gb2xkVHlwZTtcbn1cblxuLyoqXG4gKiBOZWdhdGVzIGEgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IC1tLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShtLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBkc3RbIDBdID0gLW1bIDBdO1xuICBkc3RbIDFdID0gLW1bIDFdO1xuICBkc3RbIDJdID0gLW1bIDJdO1xuICBkc3RbIDNdID0gLW1bIDNdO1xuICBkc3RbIDRdID0gLW1bIDRdO1xuICBkc3RbIDVdID0gLW1bIDVdO1xuICBkc3RbIDZdID0gLW1bIDZdO1xuICBkc3RbIDddID0gLW1bIDddO1xuICBkc3RbIDhdID0gLW1bIDhdO1xuICBkc3RbIDldID0gLW1bIDldO1xuICBkc3RbMTBdID0gLW1bMTBdO1xuICBkc3RbMTFdID0gLW1bMTFdO1xuICBkc3RbMTJdID0gLW1bMTJdO1xuICBkc3RbMTNdID0gLW1bMTNdO1xuICBkc3RbMTRdID0gLW1bMTRdO1xuICBkc3RbMTVdID0gLW1bMTVdO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IEEgbmV3IG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHJldHVybiBuZXcgTWF0VHlwZSgxNikuZmlsbCgwKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgYSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gVGhlIG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IEEgY29weSBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIGNvcHkobSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgZHN0WyAwXSA9IG1bIDBdO1xuICBkc3RbIDFdID0gbVsgMV07XG4gIGRzdFsgMl0gPSBtWyAyXTtcbiAgZHN0WyAzXSA9IG1bIDNdO1xuICBkc3RbIDRdID0gbVsgNF07XG4gIGRzdFsgNV0gPSBtWyA1XTtcbiAgZHN0WyA2XSA9IG1bIDZdO1xuICBkc3RbIDddID0gbVsgN107XG4gIGRzdFsgOF0gPSBtWyA4XTtcbiAgZHN0WyA5XSA9IG1bIDldO1xuICBkc3RbMTBdID0gbVsxMF07XG4gIGRzdFsxMV0gPSBtWzExXTtcbiAgZHN0WzEyXSA9IG1bMTJdO1xuICBkc3RbMTNdID0gbVsxM107XG4gIGRzdFsxNF0gPSBtWzE0XTtcbiAgZHN0WzE1XSA9IG1bMTVdO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBuLWJ5LW4gaWRlbnRpdHkgbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gQW4gbi1ieS1uIGlkZW50aXR5IG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBpZGVudGl0eShkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBkc3RbIDBdID0gMTtcbiAgZHN0WyAxXSA9IDA7XG4gIGRzdFsgMl0gPSAwO1xuICBkc3RbIDNdID0gMDtcbiAgZHN0WyA0XSA9IDA7XG4gIGRzdFsgNV0gPSAxO1xuICBkc3RbIDZdID0gMDtcbiAgZHN0WyA3XSA9IDA7XG4gIGRzdFsgOF0gPSAwO1xuICBkc3RbIDldID0gMDtcbiAgZHN0WzEwXSA9IDE7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFRha2VzIHRoZSB0cmFuc3Bvc2Ugb2YgYSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHRyYW5zcG9zZSBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbiBmdW5jdGlvbiB0cmFuc3Bvc2UobSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG4gIGlmIChkc3QgPT09IG0pIHtcbiAgICBsZXQgdDtcblxuICAgIHQgPSBtWzFdO1xuICAgIG1bMV0gPSBtWzRdO1xuICAgIG1bNF0gPSB0O1xuXG4gICAgdCA9IG1bMl07XG4gICAgbVsyXSA9IG1bOF07XG4gICAgbVs4XSA9IHQ7XG5cbiAgICB0ID0gbVszXTtcbiAgICBtWzNdID0gbVsxMl07XG4gICAgbVsxMl0gPSB0O1xuXG4gICAgdCA9IG1bNl07XG4gICAgbVs2XSA9IG1bOV07XG4gICAgbVs5XSA9IHQ7XG5cbiAgICB0ID0gbVs3XTtcbiAgICBtWzddID0gbVsxM107XG4gICAgbVsxM10gPSB0O1xuXG4gICAgdCA9IG1bMTFdO1xuICAgIG1bMTFdID0gbVsxNF07XG4gICAgbVsxNF0gPSB0O1xuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICBjb25zdCBtMDMgPSBtWzAgKiA0ICsgM107XG4gIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gIGNvbnN0IG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgY29uc3QgbTIzID0gbVsyICogNCArIDNdO1xuICBjb25zdCBtMzAgPSBtWzMgKiA0ICsgMF07XG4gIGNvbnN0IG0zMSA9IG1bMyAqIDQgKyAxXTtcbiAgY29uc3QgbTMyID0gbVszICogNCArIDJdO1xuICBjb25zdCBtMzMgPSBtWzMgKiA0ICsgM107XG5cbiAgZHN0WyAwXSA9IG0wMDtcbiAgZHN0WyAxXSA9IG0xMDtcbiAgZHN0WyAyXSA9IG0yMDtcbiAgZHN0WyAzXSA9IG0zMDtcbiAgZHN0WyA0XSA9IG0wMTtcbiAgZHN0WyA1XSA9IG0xMTtcbiAgZHN0WyA2XSA9IG0yMTtcbiAgZHN0WyA3XSA9IG0zMTtcbiAgZHN0WyA4XSA9IG0wMjtcbiAgZHN0WyA5XSA9IG0xMjtcbiAgZHN0WzEwXSA9IG0yMjtcbiAgZHN0WzExXSA9IG0zMjtcbiAgZHN0WzEyXSA9IG0wMztcbiAgZHN0WzEzXSA9IG0xMztcbiAgZHN0WzE0XSA9IG0yMztcbiAgZHN0WzE1XSA9IG0zMztcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIGEgNC1ieS00IG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgaW52ZXJzZSBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIGludmVyc2UobSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgY29uc3QgbTAzID0gbVswICogNCArIDNdO1xuICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICBjb25zdCBtMTMgPSBtWzEgKiA0ICsgM107XG4gIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gIGNvbnN0IG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgY29uc3QgbTMwID0gbVszICogNCArIDBdO1xuICBjb25zdCBtMzEgPSBtWzMgKiA0ICsgMV07XG4gIGNvbnN0IG0zMiA9IG1bMyAqIDQgKyAyXTtcbiAgY29uc3QgbTMzID0gbVszICogNCArIDNdO1xuICBjb25zdCB0bXBfMCAgPSBtMjIgKiBtMzM7XG4gIGNvbnN0IHRtcF8xICA9IG0zMiAqIG0yMztcbiAgY29uc3QgdG1wXzIgID0gbTEyICogbTMzO1xuICBjb25zdCB0bXBfMyAgPSBtMzIgKiBtMTM7XG4gIGNvbnN0IHRtcF80ICA9IG0xMiAqIG0yMztcbiAgY29uc3QgdG1wXzUgID0gbTIyICogbTEzO1xuICBjb25zdCB0bXBfNiAgPSBtMDIgKiBtMzM7XG4gIGNvbnN0IHRtcF83ICA9IG0zMiAqIG0wMztcbiAgY29uc3QgdG1wXzggID0gbTAyICogbTIzO1xuICBjb25zdCB0bXBfOSAgPSBtMjIgKiBtMDM7XG4gIGNvbnN0IHRtcF8xMCA9IG0wMiAqIG0xMztcbiAgY29uc3QgdG1wXzExID0gbTEyICogbTAzO1xuICBjb25zdCB0bXBfMTIgPSBtMjAgKiBtMzE7XG4gIGNvbnN0IHRtcF8xMyA9IG0zMCAqIG0yMTtcbiAgY29uc3QgdG1wXzE0ID0gbTEwICogbTMxO1xuICBjb25zdCB0bXBfMTUgPSBtMzAgKiBtMTE7XG4gIGNvbnN0IHRtcF8xNiA9IG0xMCAqIG0yMTtcbiAgY29uc3QgdG1wXzE3ID0gbTIwICogbTExO1xuICBjb25zdCB0bXBfMTggPSBtMDAgKiBtMzE7XG4gIGNvbnN0IHRtcF8xOSA9IG0zMCAqIG0wMTtcbiAgY29uc3QgdG1wXzIwID0gbTAwICogbTIxO1xuICBjb25zdCB0bXBfMjEgPSBtMjAgKiBtMDE7XG4gIGNvbnN0IHRtcF8yMiA9IG0wMCAqIG0xMTtcbiAgY29uc3QgdG1wXzIzID0gbTEwICogbTAxO1xuXG4gIGNvbnN0IHQwID0gKHRtcF8wICogbTExICsgdG1wXzMgKiBtMjEgKyB0bXBfNCAqIG0zMSkgLVxuICAgICAgKHRtcF8xICogbTExICsgdG1wXzIgKiBtMjEgKyB0bXBfNSAqIG0zMSk7XG4gIGNvbnN0IHQxID0gKHRtcF8xICogbTAxICsgdG1wXzYgKiBtMjEgKyB0bXBfOSAqIG0zMSkgLVxuICAgICAgKHRtcF8wICogbTAxICsgdG1wXzcgKiBtMjEgKyB0bXBfOCAqIG0zMSk7XG4gIGNvbnN0IHQyID0gKHRtcF8yICogbTAxICsgdG1wXzcgKiBtMTEgKyB0bXBfMTAgKiBtMzEpIC1cbiAgICAgICh0bXBfMyAqIG0wMSArIHRtcF82ICogbTExICsgdG1wXzExICogbTMxKTtcbiAgY29uc3QgdDMgPSAodG1wXzUgKiBtMDEgKyB0bXBfOCAqIG0xMSArIHRtcF8xMSAqIG0yMSkgLVxuICAgICAgKHRtcF80ICogbTAxICsgdG1wXzkgKiBtMTEgKyB0bXBfMTAgKiBtMjEpO1xuXG4gIGNvbnN0IGQgPSAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xuXG4gIGRzdFsgMF0gPSBkICogdDA7XG4gIGRzdFsgMV0gPSBkICogdDE7XG4gIGRzdFsgMl0gPSBkICogdDI7XG4gIGRzdFsgM10gPSBkICogdDM7XG4gIGRzdFsgNF0gPSBkICogKCh0bXBfMSAqIG0xMCArIHRtcF8yICogbTIwICsgdG1wXzUgKiBtMzApIC1cbiAgICAgICAgICAodG1wXzAgKiBtMTAgKyB0bXBfMyAqIG0yMCArIHRtcF80ICogbTMwKSk7XG4gIGRzdFsgNV0gPSBkICogKCh0bXBfMCAqIG0wMCArIHRtcF83ICogbTIwICsgdG1wXzggKiBtMzApIC1cbiAgICAgICAgICAodG1wXzEgKiBtMDAgKyB0bXBfNiAqIG0yMCArIHRtcF85ICogbTMwKSk7XG4gIGRzdFsgNl0gPSBkICogKCh0bXBfMyAqIG0wMCArIHRtcF82ICogbTEwICsgdG1wXzExICogbTMwKSAtXG4gICAgICAgICAgKHRtcF8yICogbTAwICsgdG1wXzcgKiBtMTAgKyB0bXBfMTAgKiBtMzApKTtcbiAgZHN0WyA3XSA9IGQgKiAoKHRtcF80ICogbTAwICsgdG1wXzkgKiBtMTAgKyB0bXBfMTAgKiBtMjApIC1cbiAgICAgICAgICAodG1wXzUgKiBtMDAgKyB0bXBfOCAqIG0xMCArIHRtcF8xMSAqIG0yMCkpO1xuICBkc3RbIDhdID0gZCAqICgodG1wXzEyICogbTEzICsgdG1wXzE1ICogbTIzICsgdG1wXzE2ICogbTMzKSAtXG4gICAgICAgICAgKHRtcF8xMyAqIG0xMyArIHRtcF8xNCAqIG0yMyArIHRtcF8xNyAqIG0zMykpO1xuICBkc3RbIDldID0gZCAqICgodG1wXzEzICogbTAzICsgdG1wXzE4ICogbTIzICsgdG1wXzIxICogbTMzKSAtXG4gICAgICAgICAgKHRtcF8xMiAqIG0wMyArIHRtcF8xOSAqIG0yMyArIHRtcF8yMCAqIG0zMykpO1xuICBkc3RbMTBdID0gZCAqICgodG1wXzE0ICogbTAzICsgdG1wXzE5ICogbTEzICsgdG1wXzIyICogbTMzKSAtXG4gICAgICAgICAgKHRtcF8xNSAqIG0wMyArIHRtcF8xOCAqIG0xMyArIHRtcF8yMyAqIG0zMykpO1xuICBkc3RbMTFdID0gZCAqICgodG1wXzE3ICogbTAzICsgdG1wXzIwICogbTEzICsgdG1wXzIzICogbTIzKSAtXG4gICAgICAgICAgKHRtcF8xNiAqIG0wMyArIHRtcF8yMSAqIG0xMyArIHRtcF8yMiAqIG0yMykpO1xuICBkc3RbMTJdID0gZCAqICgodG1wXzE0ICogbTIyICsgdG1wXzE3ICogbTMyICsgdG1wXzEzICogbTEyKSAtXG4gICAgICAgICAgKHRtcF8xNiAqIG0zMiArIHRtcF8xMiAqIG0xMiArIHRtcF8xNSAqIG0yMikpO1xuICBkc3RbMTNdID0gZCAqICgodG1wXzIwICogbTMyICsgdG1wXzEyICogbTAyICsgdG1wXzE5ICogbTIyKSAtXG4gICAgICAgICAgKHRtcF8xOCAqIG0yMiArIHRtcF8yMSAqIG0zMiArIHRtcF8xMyAqIG0wMikpO1xuICBkc3RbMTRdID0gZCAqICgodG1wXzE4ICogbTEyICsgdG1wXzIzICogbTMyICsgdG1wXzE1ICogbTAyKSAtXG4gICAgICAgICAgKHRtcF8yMiAqIG0zMiArIHRtcF8xNCAqIG0wMiArIHRtcF8xOSAqIG0xMikpO1xuICBkc3RbMTVdID0gZCAqICgodG1wXzIyICogbTIyICsgdG1wXzE2ICogbTAyICsgdG1wXzIxICogbTEyKSAtXG4gICAgICAgICAgKHRtcF8yMCAqIG0xMiArIHRtcF8yMyAqIG0yMiArIHRtcF8xNyAqIG0wMikpO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gNC1ieS00IG1hdHJpY2VzIHdpdGggYSBvbiB0aGUgbGVmdCBhbmQgYiBvbiB0aGUgcmlnaHRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gYSBUaGUgbWF0cml4IG9uIHRoZSBsZWZ0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBiIFRoZSBtYXRyaXggb24gdGhlIHJpZ2h0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgbWF0cml4IHByb2R1Y3Qgb2YgYSBhbmQgYi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShhLCBiLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBjb25zdCBhMDAgPSBhWzBdO1xuICBjb25zdCBhMDEgPSBhWzFdO1xuICBjb25zdCBhMDIgPSBhWzJdO1xuICBjb25zdCBhMDMgPSBhWzNdO1xuICBjb25zdCBhMTAgPSBhWyA0ICsgMF07XG4gIGNvbnN0IGExMSA9IGFbIDQgKyAxXTtcbiAgY29uc3QgYTEyID0gYVsgNCArIDJdO1xuICBjb25zdCBhMTMgPSBhWyA0ICsgM107XG4gIGNvbnN0IGEyMCA9IGFbIDggKyAwXTtcbiAgY29uc3QgYTIxID0gYVsgOCArIDFdO1xuICBjb25zdCBhMjIgPSBhWyA4ICsgMl07XG4gIGNvbnN0IGEyMyA9IGFbIDggKyAzXTtcbiAgY29uc3QgYTMwID0gYVsxMiArIDBdO1xuICBjb25zdCBhMzEgPSBhWzEyICsgMV07XG4gIGNvbnN0IGEzMiA9IGFbMTIgKyAyXTtcbiAgY29uc3QgYTMzID0gYVsxMiArIDNdO1xuICBjb25zdCBiMDAgPSBiWzBdO1xuICBjb25zdCBiMDEgPSBiWzFdO1xuICBjb25zdCBiMDIgPSBiWzJdO1xuICBjb25zdCBiMDMgPSBiWzNdO1xuICBjb25zdCBiMTAgPSBiWyA0ICsgMF07XG4gIGNvbnN0IGIxMSA9IGJbIDQgKyAxXTtcbiAgY29uc3QgYjEyID0gYlsgNCArIDJdO1xuICBjb25zdCBiMTMgPSBiWyA0ICsgM107XG4gIGNvbnN0IGIyMCA9IGJbIDggKyAwXTtcbiAgY29uc3QgYjIxID0gYlsgOCArIDFdO1xuICBjb25zdCBiMjIgPSBiWyA4ICsgMl07XG4gIGNvbnN0IGIyMyA9IGJbIDggKyAzXTtcbiAgY29uc3QgYjMwID0gYlsxMiArIDBdO1xuICBjb25zdCBiMzEgPSBiWzEyICsgMV07XG4gIGNvbnN0IGIzMiA9IGJbMTIgKyAyXTtcbiAgY29uc3QgYjMzID0gYlsxMiArIDNdO1xuXG4gIGRzdFsgMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDIgKyBhMzAgKiBiMDM7XG4gIGRzdFsgMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDIgKyBhMzEgKiBiMDM7XG4gIGRzdFsgMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDIgKyBhMzIgKiBiMDM7XG4gIGRzdFsgM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDIgKyBhMzMgKiBiMDM7XG4gIGRzdFsgNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTIgKyBhMzAgKiBiMTM7XG4gIGRzdFsgNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTIgKyBhMzEgKiBiMTM7XG4gIGRzdFsgNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTIgKyBhMzIgKiBiMTM7XG4gIGRzdFsgN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTIgKyBhMzMgKiBiMTM7XG4gIGRzdFsgOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjIgKyBhMzAgKiBiMjM7XG4gIGRzdFsgOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjIgKyBhMzEgKiBiMjM7XG4gIGRzdFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjIgKyBhMzIgKiBiMjM7XG4gIGRzdFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjIgKyBhMzMgKiBiMjM7XG4gIGRzdFsxMl0gPSBhMDAgKiBiMzAgKyBhMTAgKiBiMzEgKyBhMjAgKiBiMzIgKyBhMzAgKiBiMzM7XG4gIGRzdFsxM10gPSBhMDEgKiBiMzAgKyBhMTEgKiBiMzEgKyBhMjEgKiBiMzIgKyBhMzEgKiBiMzM7XG4gIGRzdFsxNF0gPSBhMDIgKiBiMzAgKyBhMTIgKiBiMzEgKyBhMjIgKiBiMzIgKyBhMzIgKiBiMzM7XG4gIGRzdFsxNV0gPSBhMDMgKiBiMzAgKyBhMTMgKiBiMzEgKyBhMjMgKiBiMzIgKyBhMzMgKiBiMzM7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgYSA0LWJ5LTQgbWF0cml4IHRvIHRoZSBnaXZlblxuICogdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBhIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIG1hdHJpeCB3aXRoIHRyYW5zbGF0aW9uIHNldC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBzZXRUcmFuc2xhdGlvbihhLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IGlkZW50aXR5KCk7XG4gIGlmIChhICE9PSBkc3QpIHtcbiAgICBkc3RbIDBdID0gYVsgMF07XG4gICAgZHN0WyAxXSA9IGFbIDFdO1xuICAgIGRzdFsgMl0gPSBhWyAyXTtcbiAgICBkc3RbIDNdID0gYVsgM107XG4gICAgZHN0WyA0XSA9IGFbIDRdO1xuICAgIGRzdFsgNV0gPSBhWyA1XTtcbiAgICBkc3RbIDZdID0gYVsgNl07XG4gICAgZHN0WyA3XSA9IGFbIDddO1xuICAgIGRzdFsgOF0gPSBhWyA4XTtcbiAgICBkc3RbIDldID0gYVsgOV07XG4gICAgZHN0WzEwXSA9IGFbMTBdO1xuICAgIGRzdFsxMV0gPSBhWzExXTtcbiAgfVxuICBkc3RbMTJdID0gdlswXTtcbiAgZHN0WzEzXSA9IHZbMV07XG4gIGRzdFsxNF0gPSB2WzJdO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgYSA0LWJ5LTQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggM1xuICogZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBjcmVhdGUkMSgpO1xuICBkc3RbMF0gPSBtWzEyXTtcbiAgZHN0WzFdID0gbVsxM107XG4gIGRzdFsyXSA9IG1bMTRdO1xuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXhpcyBvZiBhIDR4NCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJ9IGF4aXMgVGhlIGF4aXMgMCA9IHgsIDEgPSB5LCAyID0gejtcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3Rvci5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBheGlzIGNvbXBvbmVudCBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIGdldEF4aXMobSwgYXhpcywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBjcmVhdGUkMSgpO1xuICBjb25zdCBvZmYgPSBheGlzICogNDtcbiAgZHN0WzBdID0gbVtvZmYgKyAwXTtcbiAgZHN0WzFdID0gbVtvZmYgKyAxXTtcbiAgZHN0WzJdID0gbVtvZmYgKyAyXTtcbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBTZXRzIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiB0aGUgYXhpcyB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzIFRoZSBheGlzICAwID0geCwgMSA9IHksIDIgPSB6O1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBUaGUgbWF0cml4IHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggd2l0aCBheGlzIHNldC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBzZXRBeGlzKGEsIHYsIGF4aXMsIGRzdCkge1xuICBpZiAoZHN0ICE9PSBhKSB7XG4gICAgZHN0ID0gY29weShhLCBkc3QpO1xuICB9XG4gIGNvbnN0IG9mZiA9IGF4aXMgKiA0O1xuICBkc3Rbb2ZmICsgMF0gPSB2WzBdO1xuICBkc3Rbb2ZmICsgMV0gPSB2WzFdO1xuICBkc3Rbb2ZmICsgMl0gPSB2WzJdO1xuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGEgNC1ieS00IHBlcnNwZWN0aXZlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBnaXZlbiB0aGUgYW5ndWxhciBoZWlnaHRcbiAqIG9mIHRoZSBmcnVzdHVtLCB0aGUgYXNwZWN0IHJhdGlvLCBhbmQgdGhlIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZXMuICBUaGVcbiAqIGFyZ3VtZW50cyBkZWZpbmUgYSBmcnVzdHVtIGV4dGVuZGluZyBpbiB0aGUgbmVnYXRpdmUgeiBkaXJlY3Rpb24uICBUaGUgZ2l2ZW5cbiAqIGFuZ2xlIGlzIHRoZSB2ZXJ0aWNhbCBhbmdsZSBvZiB0aGUgZnJ1c3R1bSwgYW5kIHRoZSBob3Jpem9udGFsIGFuZ2xlIGlzXG4gKiBkZXRlcm1pbmVkIHRvIHByb2R1Y2UgdGhlIGdpdmVuIGFzcGVjdCByYXRpby4gIFRoZSBhcmd1bWVudHMgbmVhciBhbmQgZmFyIGFyZVxuICogdGhlIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIE5vdGUgdGhhdCBuZWFyIGFuZCBmYXJcbiAqIGFyZSBub3QgeiBjb29yZGluYXRlcywgYnV0IHJhdGhlciB0aGV5IGFyZSBkaXN0YW5jZXMgYWxvbmcgdGhlIG5lZ2F0aXZlXG4gKiB6LWF4aXMuICBUaGUgbWF0cml4IGdlbmVyYXRlZCBzZW5kcyB0aGUgdmlld2luZyBmcnVzdHVtIHRvIHRoZSB1bml0IGJveC5cbiAqIFdlIGFzc3VtZSBhIHVuaXQgYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmRcbiAqIGZyb20gMCB0byAxIGluIHRoZSB6IGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZE9mVmlld1lJblJhZGlhbnMgVGhlIGNhbWVyYSBhbmdsZSBmcm9tIHRvcCB0byBib3R0b20gKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBUaGUgYXNwZWN0IHJhdGlvIHdpZHRoIC8gaGVpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ9IHpOZWFyIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICogICAgIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IHpGYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIGZhciBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHBlcnNwZWN0aXZlIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZShmaWVsZE9mVmlld1lJblJhZGlhbnMsIGFzcGVjdCwgek5lYXIsIHpGYXIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGNvbnN0IGYgPSBNYXRoLnRhbihNYXRoLlBJICogMC41IC0gMC41ICogZmllbGRPZlZpZXdZSW5SYWRpYW5zKTtcbiAgY29uc3QgcmFuZ2VJbnYgPSAxLjAgLyAoek5lYXIgLSB6RmFyKTtcblxuICBkc3RbMF0gID0gZiAvIGFzcGVjdDtcbiAgZHN0WzFdICA9IDA7XG4gIGRzdFsyXSAgPSAwO1xuICBkc3RbM10gID0gMDtcblxuICBkc3RbNF0gID0gMDtcbiAgZHN0WzVdICA9IGY7XG4gIGRzdFs2XSAgPSAwO1xuICBkc3RbN10gID0gMDtcblxuICBkc3RbOF0gID0gMDtcbiAgZHN0WzldICA9IDA7XG4gIGRzdFsxMF0gPSAoek5lYXIgKyB6RmFyKSAqIHJhbmdlSW52O1xuICBkc3RbMTFdID0gLTE7XG5cbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gek5lYXIgKiB6RmFyICogcmFuZ2VJbnYgKiAyO1xuICBkc3RbMTVdID0gMDtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGEgNC1ieS00IG9ydGhvZ29uYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBsZWZ0LCByaWdodCxcbiAqIGJvdHRvbSwgYW5kIHRvcCBkaW1lbnNpb25zIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIGFzIHdlbGwgYXMgdGhlXG4gKiBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmUgZGlzdGFuY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBzaWRlIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IHNpZGUgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICogICAgIG9mIHRoZSBmYXIgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIE91dHB1dCBtYXRyaXguIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcGVyc3BlY3RpdmUgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIG9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBkc3RbMF0gID0gMiAvIChyaWdodCAtIGxlZnQpO1xuICBkc3RbMV0gID0gMDtcbiAgZHN0WzJdICA9IDA7XG4gIGRzdFszXSAgPSAwO1xuXG4gIGRzdFs0XSAgPSAwO1xuICBkc3RbNV0gID0gMiAvICh0b3AgLSBib3R0b20pO1xuICBkc3RbNl0gID0gMDtcbiAgZHN0WzddICA9IDA7XG5cbiAgZHN0WzhdICA9IDA7XG4gIGRzdFs5XSAgPSAwO1xuICBkc3RbMTBdID0gMiAvIChuZWFyIC0gZmFyKTtcbiAgZHN0WzExXSA9IDA7XG5cbiAgZHN0WzEyXSA9IChyaWdodCArIGxlZnQpIC8gKGxlZnQgLSByaWdodCk7XG4gIGRzdFsxM10gPSAodG9wICsgYm90dG9tKSAvIChib3R0b20gLSB0b3ApO1xuICBkc3RbMTRdID0gKGZhciArIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICBkc3RbMTVdID0gMTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGEgNC1ieS00IHBlcnNwZWN0aXZlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBnaXZlbiB0aGUgbGVmdCwgcmlnaHQsXG4gKiB0b3AsIGJvdHRvbSwgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gVGhlIGFyZ3VtZW50cyBkZWZpbmUgYSBmcnVzdHVtXG4gKiBleHRlbmRpbmcgaW4gdGhlIG5lZ2F0aXZlIHogZGlyZWN0aW9uLiBUaGUgYXJndW1lbnRzIG5lYXIgYW5kIGZhciBhcmUgdGhlXG4gKiBkaXN0YW5jZXMgdG8gdGhlIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZXMuIE5vdGUgdGhhdCBuZWFyIGFuZCBmYXIgYXJlIG5vdFxuICogeiBjb29yZGluYXRlcywgYnV0IHJhdGhlciB0aGV5IGFyZSBkaXN0YW5jZXMgYWxvbmcgdGhlIG5lZ2F0aXZlIHotYXhpcy4gVGhlXG4gKiBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LiBXZSBhc3N1bWUgYSB1bml0XG4gKiBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZCBmcm9tIDAgdG8gMSBpbiB0aGUgelxuICogZGltZW5zaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgVGhlIG5lZ2F0aXZlIHogY29vcmRpbmF0ZSBvZiB0aGUgbmVhciBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBmYXIgcGxhbmUgb2YgdGhlIGJveC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gT3V0cHV0IG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBmcnVzdHVtKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBjb25zdCBkeCA9IChyaWdodCAtIGxlZnQpO1xuICBjb25zdCBkeSA9ICh0b3AgLSBib3R0b20pO1xuICBjb25zdCBkeiA9IChuZWFyIC0gZmFyKTtcblxuICBkc3RbIDBdID0gMiAqIG5lYXIgLyBkeDtcbiAgZHN0WyAxXSA9IDA7XG4gIGRzdFsgMl0gPSAwO1xuICBkc3RbIDNdID0gMDtcbiAgZHN0WyA0XSA9IDA7XG4gIGRzdFsgNV0gPSAyICogbmVhciAvIGR5O1xuICBkc3RbIDZdID0gMDtcbiAgZHN0WyA3XSA9IDA7XG4gIGRzdFsgOF0gPSAobGVmdCArIHJpZ2h0KSAvIGR4O1xuICBkc3RbIDldID0gKHRvcCArIGJvdHRvbSkgLyBkeTtcbiAgZHN0WzEwXSA9IGZhciAvIGR6O1xuICBkc3RbMTFdID0gLTE7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IG5lYXIgKiBmYXIgLyBkejtcbiAgZHN0WzE1XSA9IDA7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxubGV0IHhBeGlzO1xubGV0IHlBeGlzO1xubGV0IHpBeGlzO1xuXG4vKipcbiAqIENvbXB1dGVzIGEgNC1ieS00IGxvb2stYXQgdHJhbnNmb3JtYXRpb24uXG4gKlxuICogVGhpcyBpcyBhIG1hdHJpeCB3aGljaCBwb3NpdGlvbnMgdGhlIGNhbWVyYSBpdHNlbGYuIElmIHlvdSB3YW50XG4gKiBhIHZpZXcgbWF0cml4IChhIG1hdHJpeCB3aGljaCBtb3ZlcyB0aGluZ3MgaW4gZnJvbnQgb2YgdGhlIGNhbWVyYSlcbiAqIHRha2UgdGhlIGludmVyc2Ugb2YgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGV5ZSBUaGUgcG9zaXRpb24gb2YgdGhlIGV5ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdGFyZ2V0IFRoZSBwb3NpdGlvbiBtZWFudCB0byBiZSB2aWV3ZWQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHVwIEEgdmVjdG9yIHBvaW50aW5nIHVwLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgbG9vay1hdCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gbG9va0F0KGV5ZSwgdGFyZ2V0LCB1cCwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgeEF4aXMgPSB4QXhpcyB8fCBjcmVhdGUkMSgpO1xuICB5QXhpcyA9IHlBeGlzIHx8IGNyZWF0ZSQxKCk7XG4gIHpBeGlzID0gekF4aXMgfHwgY3JlYXRlJDEoKTtcblxuICBub3JtYWxpemUoXG4gICAgICBzdWJ0cmFjdChleWUsIHRhcmdldCwgekF4aXMpLCB6QXhpcyk7XG4gIG5vcm1hbGl6ZShjcm9zcyh1cCwgekF4aXMsIHhBeGlzKSwgeEF4aXMpO1xuICBub3JtYWxpemUoY3Jvc3MoekF4aXMsIHhBeGlzLCB5QXhpcyksIHlBeGlzKTtcblxuICBkc3RbIDBdID0geEF4aXNbMF07XG4gIGRzdFsgMV0gPSB4QXhpc1sxXTtcbiAgZHN0WyAyXSA9IHhBeGlzWzJdO1xuICBkc3RbIDNdID0gMDtcbiAgZHN0WyA0XSA9IHlBeGlzWzBdO1xuICBkc3RbIDVdID0geUF4aXNbMV07XG4gIGRzdFsgNl0gPSB5QXhpc1syXTtcbiAgZHN0WyA3XSA9IDA7XG4gIGRzdFsgOF0gPSB6QXhpc1swXTtcbiAgZHN0WyA5XSA9IHpBeGlzWzFdO1xuICBkc3RbMTBdID0gekF4aXNbMl07XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gZXllWzBdO1xuICBkc3RbMTNdID0gZXllWzFdO1xuICBkc3RbMTRdID0gZXllWzJdO1xuICBkc3RbMTVdID0gMTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHRyYW5zbGF0ZXMgYnkgdGhlIGdpdmVuIHZlY3RvciB2LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IgYnlcbiAqICAgICB3aGljaCB0byB0cmFuc2xhdGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSB0cmFuc2xhdGlvbiBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRpb24odiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgZHN0WyAwXSA9IDE7XG4gIGRzdFsgMV0gPSAwO1xuICBkc3RbIDJdID0gMDtcbiAgZHN0WyAzXSA9IDA7XG4gIGRzdFsgNF0gPSAwO1xuICBkc3RbIDVdID0gMTtcbiAgZHN0WyA2XSA9IDA7XG4gIGRzdFsgN10gPSAwO1xuICBkc3RbIDhdID0gMDtcbiAgZHN0WyA5XSA9IDA7XG4gIGRzdFsxMF0gPSAxO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IHZbMF07XG4gIGRzdFsxM10gPSB2WzFdO1xuICBkc3RbMTRdID0gdlsyXTtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBieSB0aGUgZ2l2ZW4gdmVjdG9yIHYuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yIGJ5XG4gKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgdHJhbnNsYXRlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKG0sIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGNvbnN0IHYwID0gdlswXTtcbiAgY29uc3QgdjEgPSB2WzFdO1xuICBjb25zdCB2MiA9IHZbMl07XG4gIGNvbnN0IG0wMCA9IG1bMF07XG4gIGNvbnN0IG0wMSA9IG1bMV07XG4gIGNvbnN0IG0wMiA9IG1bMl07XG4gIGNvbnN0IG0wMyA9IG1bM107XG4gIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gIGNvbnN0IG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgY29uc3QgbTIzID0gbVsyICogNCArIDNdO1xuICBjb25zdCBtMzAgPSBtWzMgKiA0ICsgMF07XG4gIGNvbnN0IG0zMSA9IG1bMyAqIDQgKyAxXTtcbiAgY29uc3QgbTMyID0gbVszICogNCArIDJdO1xuICBjb25zdCBtMzMgPSBtWzMgKiA0ICsgM107XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFsgMF0gPSBtMDA7XG4gICAgZHN0WyAxXSA9IG0wMTtcbiAgICBkc3RbIDJdID0gbTAyO1xuICAgIGRzdFsgM10gPSBtMDM7XG4gICAgZHN0WyA0XSA9IG0xMDtcbiAgICBkc3RbIDVdID0gbTExO1xuICAgIGRzdFsgNl0gPSBtMTI7XG4gICAgZHN0WyA3XSA9IG0xMztcbiAgICBkc3RbIDhdID0gbTIwO1xuICAgIGRzdFsgOV0gPSBtMjE7XG4gICAgZHN0WzEwXSA9IG0yMjtcbiAgICBkc3RbMTFdID0gbTIzO1xuICB9XG5cbiAgZHN0WzEyXSA9IG0wMCAqIHYwICsgbTEwICogdjEgKyBtMjAgKiB2MiArIG0zMDtcbiAgZHN0WzEzXSA9IG0wMSAqIHYwICsgbTExICogdjEgKyBtMjEgKiB2MiArIG0zMTtcbiAgZHN0WzE0XSA9IG0wMiAqIHYwICsgbTEyICogdjEgKyBtMjIgKiB2MiArIG0zMjtcbiAgZHN0WzE1XSA9IG0wMyAqIHYwICsgbTEzICogdjEgKyBtMjMgKiB2MiArIG0zMztcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSB4LWF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcm90YXRpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHJvdGF0aW9uWChhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcblxuICBkc3RbIDBdID0gMTtcbiAgZHN0WyAxXSA9IDA7XG4gIGRzdFsgMl0gPSAwO1xuICBkc3RbIDNdID0gMDtcbiAgZHN0WyA0XSA9IDA7XG4gIGRzdFsgNV0gPSBjO1xuICBkc3RbIDZdID0gcztcbiAgZHN0WyA3XSA9IDA7XG4gIGRzdFsgOF0gPSAwO1xuICBkc3RbIDldID0gLXM7XG4gIGRzdFsxMF0gPSBjO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGFyb3VuZCB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlblxuICogYW5nbGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0ZWQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVgobSwgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGNvbnN0IG0xMCA9IG1bNF07XG4gIGNvbnN0IG0xMSA9IG1bNV07XG4gIGNvbnN0IG0xMiA9IG1bNl07XG4gIGNvbnN0IG0xMyA9IG1bN107XG4gIGNvbnN0IG0yMCA9IG1bOF07XG4gIGNvbnN0IG0yMSA9IG1bOV07XG4gIGNvbnN0IG0yMiA9IG1bMTBdO1xuICBjb25zdCBtMjMgPSBtWzExXTtcbiAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcblxuICBkc3RbNF0gID0gYyAqIG0xMCArIHMgKiBtMjA7XG4gIGRzdFs1XSAgPSBjICogbTExICsgcyAqIG0yMTtcbiAgZHN0WzZdICA9IGMgKiBtMTIgKyBzICogbTIyO1xuICBkc3RbN10gID0gYyAqIG0xMyArIHMgKiBtMjM7XG4gIGRzdFs4XSAgPSBjICogbTIwIC0gcyAqIG0xMDtcbiAgZHN0WzldICA9IGMgKiBtMjEgLSBzICogbTExO1xuICBkc3RbMTBdID0gYyAqIG0yMiAtIHMgKiBtMTI7XG4gIGRzdFsxMV0gPSBjICogbTIzIC0gcyAqIG0xMztcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WyAwXSA9IG1bIDBdO1xuICAgIGRzdFsgMV0gPSBtWyAxXTtcbiAgICBkc3RbIDJdID0gbVsgMl07XG4gICAgZHN0WyAzXSA9IG1bIDNdO1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggcm90YXRlcyBhcm91bmQgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGlvbiBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gcm90YXRpb25ZKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuXG4gIGRzdFsgMF0gPSBjO1xuICBkc3RbIDFdID0gMDtcbiAgZHN0WyAyXSA9IC1zO1xuICBkc3RbIDNdID0gMDtcbiAgZHN0WyA0XSA9IDA7XG4gIGRzdFsgNV0gPSAxO1xuICBkc3RbIDZdID0gMDtcbiAgZHN0WyA3XSA9IDA7XG4gIGRzdFsgOF0gPSBzO1xuICBkc3RbIDldID0gMDtcbiAgZHN0WzEwXSA9IGM7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSB5LWF4aXMgYnkgdGhlIGdpdmVuXG4gKiBhbmdsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcm90YXRlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgY29uc3QgbTAzID0gbVswICogNCArIDNdO1xuICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG5cbiAgZHN0WyAwXSA9IGMgKiBtMDAgLSBzICogbTIwO1xuICBkc3RbIDFdID0gYyAqIG0wMSAtIHMgKiBtMjE7XG4gIGRzdFsgMl0gPSBjICogbTAyIC0gcyAqIG0yMjtcbiAgZHN0WyAzXSA9IGMgKiBtMDMgLSBzICogbTIzO1xuICBkc3RbIDhdID0gYyAqIG0yMCArIHMgKiBtMDA7XG4gIGRzdFsgOV0gPSBjICogbTIxICsgcyAqIG0wMTtcbiAgZHN0WzEwXSA9IGMgKiBtMjIgKyBzICogbTAyO1xuICBkc3RbMTFdID0gYyAqIG0yMyArIHMgKiBtMDM7XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFsgNF0gPSBtWyA0XTtcbiAgICBkc3RbIDVdID0gbVsgNV07XG4gICAgZHN0WyA2XSA9IG1bIDZdO1xuICAgIGRzdFsgN10gPSBtWyA3XTtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcm90YXRpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHJvdGF0aW9uWihhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcblxuICBkc3RbIDBdID0gYztcbiAgZHN0WyAxXSA9IHM7XG4gIGRzdFsgMl0gPSAwO1xuICBkc3RbIDNdID0gMDtcbiAgZHN0WyA0XSA9IC1zO1xuICBkc3RbIDVdID0gYztcbiAgZHN0WyA2XSA9IDA7XG4gIGRzdFsgN10gPSAwO1xuICBkc3RbIDhdID0gMDtcbiAgZHN0WyA5XSA9IDA7XG4gIGRzdFsxMF0gPSAxO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGFyb3VuZCB0aGUgei1heGlzIGJ5IHRoZSBnaXZlblxuICogYW5nbGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0ZWQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoobSwgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gIGNvbnN0IG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuXG4gIGRzdFsgMF0gPSBjICogbTAwICsgcyAqIG0xMDtcbiAgZHN0WyAxXSA9IGMgKiBtMDEgKyBzICogbTExO1xuICBkc3RbIDJdID0gYyAqIG0wMiArIHMgKiBtMTI7XG4gIGRzdFsgM10gPSBjICogbTAzICsgcyAqIG0xMztcbiAgZHN0WyA0XSA9IGMgKiBtMTAgLSBzICogbTAwO1xuICBkc3RbIDVdID0gYyAqIG0xMSAtIHMgKiBtMDE7XG4gIGRzdFsgNl0gPSBjICogbTEyIC0gcyAqIG0wMjtcbiAgZHN0WyA3XSA9IGMgKiBtMTMgLSBzICogbTAzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbIDhdID0gbVsgOF07XG4gICAgZHN0WyA5XSA9IG1bIDldO1xuICAgIGRzdFsxMF0gPSBtWzEwXTtcbiAgICBkc3RbMTFdID0gbVsxMV07XG4gICAgZHN0WzEyXSA9IG1bMTJdO1xuICAgIGRzdFsxM10gPSBtWzEzXTtcbiAgICBkc3RbMTRdID0gbVsxNF07XG4gICAgZHN0WzE1XSA9IG1bMTVdO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBheGlzIFRoZSBheGlzXG4gKiAgICAgYWJvdXQgd2hpY2ggdG8gcm90YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBBIG1hdHJpeCB3aGljaCByb3RhdGVzIGFuZ2xlIHJhZGlhbnNcbiAqICAgICBhcm91bmQgdGhlIGF4aXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gYXhpc1JvdGF0aW9uKGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBsZXQgeCA9IGF4aXNbMF07XG4gIGxldCB5ID0gYXhpc1sxXTtcbiAgbGV0IHogPSBheGlzWzJdO1xuICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHggLz0gbjtcbiAgeSAvPSBuO1xuICB6IC89IG47XG4gIGNvbnN0IHh4ID0geCAqIHg7XG4gIGNvbnN0IHl5ID0geSAqIHk7XG4gIGNvbnN0IHp6ID0geiAqIHo7XG4gIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gIGNvbnN0IG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG5cbiAgZHN0WyAwXSA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICBkc3RbIDFdID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSArIHogKiBzO1xuICBkc3RbIDJdID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSAtIHkgKiBzO1xuICBkc3RbIDNdID0gMDtcbiAgZHN0WyA0XSA9IHggKiB5ICogb25lTWludXNDb3NpbmUgLSB6ICogcztcbiAgZHN0WyA1XSA9IHl5ICsgKDEgLSB5eSkgKiBjO1xuICBkc3RbIDZdID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xuICBkc3RbIDddID0gMDtcbiAgZHN0WyA4XSA9IHggKiB6ICogb25lTWludXNDb3NpbmUgKyB5ICogcztcbiAgZHN0WyA5XSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgLSB4ICogcztcbiAgZHN0WzEwXSA9IHp6ICsgKDEgLSB6eikgKiBjO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieSB0aGVcbiAqIGdpdmVuIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGF4aXMgVGhlIGF4aXNcbiAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGVkIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBheGlzUm90YXRlKG0sIGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBsZXQgeCA9IGF4aXNbMF07XG4gIGxldCB5ID0gYXhpc1sxXTtcbiAgbGV0IHogPSBheGlzWzJdO1xuICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHggLz0gbjtcbiAgeSAvPSBuO1xuICB6IC89IG47XG4gIGNvbnN0IHh4ID0geCAqIHg7XG4gIGNvbnN0IHl5ID0geSAqIHk7XG4gIGNvbnN0IHp6ID0geiAqIHo7XG4gIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gIGNvbnN0IG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG5cbiAgY29uc3QgcjAwID0geHggKyAoMSAtIHh4KSAqIGM7XG4gIGNvbnN0IHIwMSA9IHggKiB5ICogb25lTWludXNDb3NpbmUgKyB6ICogcztcbiAgY29uc3QgcjAyID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSAtIHkgKiBzO1xuICBjb25zdCByMTAgPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lIC0geiAqIHM7XG4gIGNvbnN0IHIxMSA9IHl5ICsgKDEgLSB5eSkgKiBjO1xuICBjb25zdCByMTIgPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeCAqIHM7XG4gIGNvbnN0IHIyMCA9IHggKiB6ICogb25lTWludXNDb3NpbmUgKyB5ICogcztcbiAgY29uc3QgcjIxID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSAtIHggKiBzO1xuICBjb25zdCByMjIgPSB6eiArICgxIC0genopICogYztcblxuICBjb25zdCBtMDAgPSBtWzBdO1xuICBjb25zdCBtMDEgPSBtWzFdO1xuICBjb25zdCBtMDIgPSBtWzJdO1xuICBjb25zdCBtMDMgPSBtWzNdO1xuICBjb25zdCBtMTAgPSBtWzRdO1xuICBjb25zdCBtMTEgPSBtWzVdO1xuICBjb25zdCBtMTIgPSBtWzZdO1xuICBjb25zdCBtMTMgPSBtWzddO1xuICBjb25zdCBtMjAgPSBtWzhdO1xuICBjb25zdCBtMjEgPSBtWzldO1xuICBjb25zdCBtMjIgPSBtWzEwXTtcbiAgY29uc3QgbTIzID0gbVsxMV07XG5cbiAgZHN0WyAwXSA9IHIwMCAqIG0wMCArIHIwMSAqIG0xMCArIHIwMiAqIG0yMDtcbiAgZHN0WyAxXSA9IHIwMCAqIG0wMSArIHIwMSAqIG0xMSArIHIwMiAqIG0yMTtcbiAgZHN0WyAyXSA9IHIwMCAqIG0wMiArIHIwMSAqIG0xMiArIHIwMiAqIG0yMjtcbiAgZHN0WyAzXSA9IHIwMCAqIG0wMyArIHIwMSAqIG0xMyArIHIwMiAqIG0yMztcbiAgZHN0WyA0XSA9IHIxMCAqIG0wMCArIHIxMSAqIG0xMCArIHIxMiAqIG0yMDtcbiAgZHN0WyA1XSA9IHIxMCAqIG0wMSArIHIxMSAqIG0xMSArIHIxMiAqIG0yMTtcbiAgZHN0WyA2XSA9IHIxMCAqIG0wMiArIHIxMSAqIG0xMiArIHIxMiAqIG0yMjtcbiAgZHN0WyA3XSA9IHIxMCAqIG0wMyArIHIxMSAqIG0xMyArIHIxMiAqIG0yMztcbiAgZHN0WyA4XSA9IHIyMCAqIG0wMCArIHIyMSAqIG0xMCArIHIyMiAqIG0yMDtcbiAgZHN0WyA5XSA9IHIyMCAqIG0wMSArIHIyMSAqIG0xMSArIHIyMiAqIG0yMTtcbiAgZHN0WzEwXSA9IHIyMCAqIG0wMiArIHIyMSAqIG0xMiArIHIyMiAqIG0yMjtcbiAgZHN0WzExXSA9IHIyMCAqIG0wMyArIHIyMSAqIG0xMyArIHIyMiAqIG0yMztcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WzEyXSA9IG1bMTJdO1xuICAgIGRzdFsxM10gPSBtWzEzXTtcbiAgICBkc3RbMTRdID0gbVsxNF07XG4gICAgZHN0WzE1XSA9IG1bMTVdO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCBzY2FsZXMgaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50IGdpdmVuIGJ5XG4gKiB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzIHRocmVlXG4gKiBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IEEgdmVjdG9yIG9mXG4gKiAgICAgdGhyZWUgZW50cmllcyBzcGVjaWZ5aW5nIHRoZSBmYWN0b3IgYnkgd2hpY2ggdG8gc2NhbGUgaW4gZWFjaCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBzY2FsaW5nIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBzY2FsaW5nKHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGRzdFsgMF0gPSB2WzBdO1xuICBkc3RbIDFdID0gMDtcbiAgZHN0WyAyXSA9IDA7XG4gIGRzdFsgM10gPSAwO1xuICBkc3RbIDRdID0gMDtcbiAgZHN0WyA1XSA9IHZbMV07XG4gIGRzdFsgNl0gPSAwO1xuICBkc3RbIDddID0gMDtcbiAgZHN0WyA4XSA9IDA7XG4gIGRzdFsgOV0gPSAwO1xuICBkc3RbMTBdID0gdlsyXTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogU2NhbGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGluIGVhY2ggZGltZW5zaW9uIGJ5IGFuIGFtb3VudFxuICogZ2l2ZW4gYnkgdGhlIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdGhlIGdpdmVuIHZlY3RvcjsgYXNzdW1lcyB0aGUgdmVjdG9yIGhhc1xuICogdGhyZWUgZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4IHRvIGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IEEgdmVjdG9yIG9mIHRocmVlIGVudHJpZXMgc3BlY2lmeWluZyB0aGVcbiAqICAgICBmYWN0b3IgYnkgd2hpY2ggdG8gc2NhbGUgaW4gZWFjaCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBzY2FsZWQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG0sIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGNvbnN0IHYwID0gdlswXTtcbiAgY29uc3QgdjEgPSB2WzFdO1xuICBjb25zdCB2MiA9IHZbMl07XG5cbiAgZHN0WyAwXSA9IHYwICogbVswICogNCArIDBdO1xuICBkc3RbIDFdID0gdjAgKiBtWzAgKiA0ICsgMV07XG4gIGRzdFsgMl0gPSB2MCAqIG1bMCAqIDQgKyAyXTtcbiAgZHN0WyAzXSA9IHYwICogbVswICogNCArIDNdO1xuICBkc3RbIDRdID0gdjEgKiBtWzEgKiA0ICsgMF07XG4gIGRzdFsgNV0gPSB2MSAqIG1bMSAqIDQgKyAxXTtcbiAgZHN0WyA2XSA9IHYxICogbVsxICogNCArIDJdO1xuICBkc3RbIDddID0gdjEgKiBtWzEgKiA0ICsgM107XG4gIGRzdFsgOF0gPSB2MiAqIG1bMiAqIDQgKyAwXTtcbiAgZHN0WyA5XSA9IHYyICogbVsyICogNCArIDFdO1xuICBkc3RbMTBdID0gdjIgKiBtWzIgKiA0ICsgMl07XG4gIGRzdFsxMV0gPSB2MiAqIG1bMiAqIDQgKyAzXTtcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WzEyXSA9IG1bMTJdO1xuICAgIGRzdFsxM10gPSBtWzEzXTtcbiAgICBkc3RbMTRdID0gbVsxNF07XG4gICAgZHN0WzE1XSA9IG1bMTVdO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIDQtYnktNCBtYXRyaXggYW5kIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzLFxuICogaW50ZXJwcmV0cyB0aGUgdmVjdG9yIGFzIGEgcG9pbnQsIHRyYW5zZm9ybXMgdGhhdCBwb2ludCBieSB0aGUgbWF0cml4LCBhbmRcbiAqIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIHZlY3RvciB3aXRoIDMgZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSBwb2ludC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gb3B0aW9uYWwgdmVjMyB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgdHJhbnNmb3JtZWQgcG9pbnQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQobSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBjcmVhdGUkMSgpO1xuICBjb25zdCB2MCA9IHZbMF07XG4gIGNvbnN0IHYxID0gdlsxXTtcbiAgY29uc3QgdjIgPSB2WzJdO1xuICBjb25zdCBkID0gdjAgKiBtWzAgKiA0ICsgM10gKyB2MSAqIG1bMSAqIDQgKyAzXSArIHYyICogbVsyICogNCArIDNdICsgbVszICogNCArIDNdO1xuXG4gIGRzdFswXSA9ICh2MCAqIG1bMCAqIDQgKyAwXSArIHYxICogbVsxICogNCArIDBdICsgdjIgKiBtWzIgKiA0ICsgMF0gKyBtWzMgKiA0ICsgMF0pIC8gZDtcbiAgZHN0WzFdID0gKHYwICogbVswICogNCArIDFdICsgdjEgKiBtWzEgKiA0ICsgMV0gKyB2MiAqIG1bMiAqIDQgKyAxXSArIG1bMyAqIDQgKyAxXSkgLyBkO1xuICBkc3RbMl0gPSAodjAgKiBtWzAgKiA0ICsgMl0gKyB2MSAqIG1bMSAqIDQgKyAyXSArIHYyICogbVsyICogNCArIDJdICsgbVszICogNCArIDJdKSAvIGQ7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIDQtYnktNCBtYXRyaXggYW5kIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzLCBpbnRlcnByZXRzIHRoZSB2ZWN0b3IgYXMgYVxuICogZGlyZWN0aW9uLCB0cmFuc2Zvcm1zIHRoYXQgZGlyZWN0aW9uIGJ5IHRoZSBtYXRyaXgsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQ7XG4gKiBhc3N1bWVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvZiAzLWRpbWVuc2lvbmFsIHNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZSBtYXRyaXhcbiAqIGlzIHBhcmFsbGVsLXByZXNlcnZpbmcsIGkuZS4gYW55IGNvbWJpbmF0aW9uIG9mIHJvdGF0aW9uLCBzY2FsaW5nIGFuZFxuICogdHJhbnNsYXRpb24sIGJ1dCBub3QgYSBwZXJzcGVjdGl2ZSBkaXN0b3J0aW9uLiBSZXR1cm5zIGEgdmVjdG9yIHdpdGggM1xuICogZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIG9wdGlvbmFsIFZlYzMgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHRyYW5zZm9ybWVkIGRpcmVjdGlvbi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1EaXJlY3Rpb24obSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBjcmVhdGUkMSgpO1xuXG4gIGNvbnN0IHYwID0gdlswXTtcbiAgY29uc3QgdjEgPSB2WzFdO1xuICBjb25zdCB2MiA9IHZbMl07XG5cbiAgZHN0WzBdID0gdjAgKiBtWzAgKiA0ICsgMF0gKyB2MSAqIG1bMSAqIDQgKyAwXSArIHYyICogbVsyICogNCArIDBdO1xuICBkc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXSArIHYxICogbVsxICogNCArIDFdICsgdjIgKiBtWzIgKiA0ICsgMV07XG4gIGRzdFsyXSA9IHYwICogbVswICogNCArIDJdICsgdjEgKiBtWzEgKiA0ICsgMl0gKyB2MiAqIG1bMiAqIDQgKyAyXTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFRha2VzIGEgNC1ieS00IG1hdHJpeCBtIGFuZCBhIHZlY3RvciB2IHdpdGggMyBlbnRyaWVzLCBpbnRlcnByZXRzIHRoZSB2ZWN0b3JcbiAqIGFzIGEgbm9ybWFsIHRvIGEgc3VyZmFjZSwgYW5kIGNvbXB1dGVzIGEgdmVjdG9yIHdoaWNoIGlzIG5vcm1hbCB1cG9uXG4gKiB0cmFuc2Zvcm1pbmcgdGhhdCBzdXJmYWNlIGJ5IHRoZSBtYXRyaXguIFRoZSBlZmZlY3Qgb2YgdGhpcyBmdW5jdGlvbiBpcyB0aGVcbiAqIHNhbWUgYXMgdHJhbnNmb3JtaW5nIHYgKGFzIGEgZGlyZWN0aW9uKSBieSB0aGUgaW52ZXJzZS10cmFuc3Bvc2Ugb2YgbS4gIFRoaXNcbiAqIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIHRyYW5zZm9ybWF0aW9uIG9mIDMtZGltZW5zaW9uYWwgc3BhY2UgcmVwcmVzZW50ZWQgYnkgdGhlXG4gKiBtYXRyaXggaXMgcGFyYWxsZWwtcHJlc2VydmluZywgaS5lLiBhbnkgY29tYmluYXRpb24gb2Ygcm90YXRpb24sIHNjYWxpbmcgYW5kXG4gKiB0cmFuc2xhdGlvbiwgYnV0IG5vdCBhIHBlcnNwZWN0aXZlIGRpc3RvcnRpb24uICBSZXR1cm5zIGEgdmVjdG9yIHdpdGggM1xuICogZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSBub3JtYWwuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIFRoZSBkaXJlY3Rpb24uIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgdHJhbnNmb3JtZWQgbm9ybWFsLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vcm1hbCQxKG0sIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgY3JlYXRlJDEoKTtcbiAgY29uc3QgbWkgPSBpbnZlcnNlKG0pO1xuICBjb25zdCB2MCA9IHZbMF07XG4gIGNvbnN0IHYxID0gdlsxXTtcbiAgY29uc3QgdjIgPSB2WzJdO1xuXG4gIGRzdFswXSA9IHYwICogbWlbMCAqIDQgKyAwXSArIHYxICogbWlbMCAqIDQgKyAxXSArIHYyICogbWlbMCAqIDQgKyAyXTtcbiAgZHN0WzFdID0gdjAgKiBtaVsxICogNCArIDBdICsgdjEgKiBtaVsxICogNCArIDFdICsgdjIgKiBtaVsxICogNCArIDJdO1xuICBkc3RbMl0gPSB2MCAqIG1pWzIgKiA0ICsgMF0gKyB2MSAqIG1pWzIgKiA0ICsgMV0gKyB2MiAqIG1pWzIgKiA0ICsgMl07XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxudmFyIG00ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGF4aXNSb3RhdGU6IGF4aXNSb3RhdGUsXG4gIGF4aXNSb3RhdGlvbjogYXhpc1JvdGF0aW9uLFxuICBjb3B5OiBjb3B5LFxuICBjcmVhdGU6IGNyZWF0ZSxcbiAgZnJ1c3R1bTogZnJ1c3R1bSxcbiAgZ2V0QXhpczogZ2V0QXhpcyxcbiAgZ2V0VHJhbnNsYXRpb246IGdldFRyYW5zbGF0aW9uLFxuICBpZGVudGl0eTogaWRlbnRpdHksXG4gIGludmVyc2U6IGludmVyc2UsXG4gIGxvb2tBdDogbG9va0F0LFxuICBtdWx0aXBseTogbXVsdGlwbHksXG4gIG5lZ2F0ZTogbmVnYXRlLFxuICBvcnRobzogb3J0aG8sXG4gIHBlcnNwZWN0aXZlOiBwZXJzcGVjdGl2ZSxcbiAgcm90YXRlWDogcm90YXRlWCxcbiAgcm90YXRlWTogcm90YXRlWSxcbiAgcm90YXRlWjogcm90YXRlWixcbiAgcm90YXRpb25YOiByb3RhdGlvblgsXG4gIHJvdGF0aW9uWTogcm90YXRpb25ZLFxuICByb3RhdGlvblo6IHJvdGF0aW9uWixcbiAgc2NhbGU6IHNjYWxlLFxuICBzY2FsaW5nOiBzY2FsaW5nLFxuICBzZXRBeGlzOiBzZXRBeGlzLFxuICBzZXREZWZhdWx0VHlwZTogc2V0RGVmYXVsdFR5cGUsXG4gIHNldFRyYW5zbGF0aW9uOiBzZXRUcmFuc2xhdGlvbixcbiAgdHJhbnNmb3JtRGlyZWN0aW9uOiB0cmFuc2Zvcm1EaXJlY3Rpb24sXG4gIHRyYW5zZm9ybU5vcm1hbDogdHJhbnNmb3JtTm9ybWFsJDEsXG4gIHRyYW5zZm9ybVBvaW50OiB0cmFuc2Zvcm1Qb2ludCxcbiAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gIHRyYW5zbGF0aW9uOiB0cmFuc2xhdGlvbixcbiAgdHJhbnNwb3NlOiB0cmFuc3Bvc2Vcbn0pO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIERhdGFUeXBlICovXG5jb25zdCBCWVRFJDIgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMDtcbmNvbnN0IFVOU0lHTkVEX0JZVEUkMyAgICAgICAgICAgICAgICAgID0gMHgxNDAxO1xuY29uc3QgU0hPUlQkMiAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDI7XG5jb25zdCBVTlNJR05FRF9TSE9SVCQzICAgICAgICAgICAgICAgICA9IDB4MTQwMztcbmNvbnN0IElOVCQzICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDA0O1xuY29uc3QgVU5TSUdORURfSU5UJDMgICAgICAgICAgICAgICAgICAgPSAweDE0MDU7XG5jb25zdCBGTE9BVCQzICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNjtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUXzRfNF80XzQkMSAgICAgICA9IDB4ODAzMztcbmNvbnN0IFVOU0lHTkVEX1NIT1JUXzVfNV81XzEkMSAgICAgICA9IDB4ODAzNDtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUXzVfNl81JDEgICAgICAgICA9IDB4ODM2MztcbmNvbnN0IEhBTEZfRkxPQVQkMSAgICAgICAgICAgICAgICAgICA9IDB4MTQwQjtcbmNvbnN0IFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViQxICA9IDB4ODM2ODtcbmNvbnN0IFVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVYkMSA9IDB4OEMzQjtcbmNvbnN0IFVOU0lHTkVEX0lOVF81XzlfOV85X1JFViQxICAgICA9IDB4OEMzRTtcbmNvbnN0IEZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFViQxID0gMHg4REFEO1xuY29uc3QgVU5TSUdORURfSU5UXzI0XzgkMSAgICAgICAgICAgID0gMHg4NEZBO1xuXG5jb25zdCBnbFR5cGVUb1R5cGVkQXJyYXkgPSB7fTtcbntcbiAgY29uc3QgdHQgPSBnbFR5cGVUb1R5cGVkQXJyYXk7XG4gIHR0W0JZVEUkMl0gICAgICAgICAgICAgICAgICAgICAgICAgICA9IEludDhBcnJheTtcbiAgdHRbVU5TSUdORURfQllURSQzXSAgICAgICAgICAgICAgICAgID0gVWludDhBcnJheTtcbiAgdHRbU0hPUlQkMl0gICAgICAgICAgICAgICAgICAgICAgICAgID0gSW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlQkM10gICAgICAgICAgICAgICAgID0gVWludDE2QXJyYXk7XG4gIHR0W0lOVCQzXSAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IEludDMyQXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVCQzXSAgICAgICAgICAgICAgICAgICA9IFVpbnQzMkFycmF5O1xuICB0dFtGTE9BVCQzXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBGbG9hdDMyQXJyYXk7XG4gIHR0W1VOU0lHTkVEX1NIT1JUXzRfNF80XzQkMV0gICAgICAgICA9IFVpbnQxNkFycmF5O1xuICB0dFtVTlNJR05FRF9TSE9SVF81XzVfNV8xJDFdICAgICAgICAgPSBVaW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNV82XzUkMV0gICAgICAgICAgID0gVWludDE2QXJyYXk7XG4gIHR0W0hBTEZfRkxPQVQkMV0gICAgICAgICAgICAgICAgICAgICA9IFVpbnQxNkFycmF5O1xuICB0dFtVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVYkMV0gICAgPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFViQxXSAgID0gVWludDMyQXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVF81XzlfOV85X1JFViQxXSAgICAgICA9IFVpbnQzMkFycmF5O1xuICB0dFtGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYkMV0gPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzI0XzgkMV0gICAgICAgICAgICAgID0gVWludDMyQXJyYXk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBHTCB0eXBlIGZvciBhIHR5cGVkQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSB0eXBlZEFycmF5IGEgdHlwZWRBcnJheVxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgR0wgdHlwZSBmb3IgYXJyYXkuIEZvciBleGFtcGxlIHBhc3MgaW4gYW4gYEludDhBcnJheWAgYW5kIGBnbC5CWVRFYCB3aWxsXG4gKiAgIGJlIHJldHVybmVkLiBQYXNzIGluIGEgYFVpbnQzMkFycmF5YCBhbmQgYGdsLlVOU0lHTkVEX0lOVGAgd2lsbCBiZSByZXR1cm5lZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3R5cGVkQXJyYXlcbiAqL1xuZnVuY3Rpb24gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheSh0eXBlZEFycmF5KSB7XG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5KSAgICAgICAgIHsgcmV0dXJuIEJZVEUkMjsgfSAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICAgICAgICB7IHJldHVybiBVTlNJR05FRF9CWVRFJDM7IH0gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgeyByZXR1cm4gVU5TSUdORURfQllURSQzOyB9ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSkgICAgICAgIHsgcmV0dXJuIFNIT1JUJDI7IH0gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSAgICAgICB7IHJldHVybiBVTlNJR05FRF9TSE9SVCQzOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSAgICAgICAgeyByZXR1cm4gSU5UJDM7IH0gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpICAgICAgIHsgcmV0dXJuIFVOU0lHTkVEX0lOVCQzOyB9ICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkgICAgICB7IHJldHVybiBGTE9BVCQzOyB9ICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCB0eXBlZCBhcnJheSB0eXBlJyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBHTCB0eXBlIGZvciBhIHR5cGVkQXJyYXkgdHlwZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IHR5cGVkQXJyYXlUeXBlIGEgdHlwZWRBcnJheSBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgR0wgdHlwZSBmb3IgdHlwZS4gRm9yIGV4YW1wbGUgcGFzcyBpbiBgSW50OEFycmF5YCBhbmQgYGdsLkJZVEVgIHdpbGxcbiAqICAgYmUgcmV0dXJuZWQuIFBhc3MgaW4gYFVpbnQzMkFycmF5YCBhbmQgYGdsLlVOU0lHTkVEX0lOVGAgd2lsbCBiZSByZXR1cm5lZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3R5cGVkQXJyYXlcbiAqL1xuZnVuY3Rpb24gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUodHlwZWRBcnJheVR5cGUpIHtcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQ4QXJyYXkpICAgICAgICAgeyByZXR1cm4gQllURSQyOyB9ICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gVWludDhBcnJheSkgICAgICAgIHsgcmV0dXJuIFVOU0lHTkVEX0JZVEUkMzsgfSAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQ4Q2xhbXBlZEFycmF5KSB7IHJldHVybiBVTlNJR05FRF9CWVRFJDM7IH0gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQxNkFycmF5KSAgICAgICAgeyByZXR1cm4gU0hPUlQkMjsgfSAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gVWludDE2QXJyYXkpICAgICAgIHsgcmV0dXJuIFVOU0lHTkVEX1NIT1JUJDM7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IEludDMyQXJyYXkpICAgICAgICB7IHJldHVybiBJTlQkMzsgfSAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBVaW50MzJBcnJheSkgICAgICAgeyByZXR1cm4gVU5TSUdORURfSU5UJDM7IH0gICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gRmxvYXQzMkFycmF5KSAgICAgIHsgcmV0dXJuIEZMT0FUJDM7IH0gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHR5cGVkIGFycmF5IHR5cGUnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIGZvciBhIGdpdmVuIEdMIHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIHRoZSBHTCB0eXBlLiAoZWc6IGBnbC5VTlNJR05FRF9JTlRgKVxuICogQHJldHVybiB7ZnVuY3Rpb259IHRoZSBjb25zdHJ1Y3RvciBmb3IgYSB0aGUgY29ycmVzcG9uZGluZyB0eXBlZCBhcnJheS4gKGVnLiBgVWludDMyQXJyYXlgKS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90eXBlZEFycmF5XG4gKi9cbmZ1bmN0aW9uIGdldFR5cGVkQXJyYXlUeXBlRm9yR0xUeXBlKHR5cGUpIHtcbiAgY29uc3QgQ1RPUiA9IGdsVHlwZVRvVHlwZWRBcnJheVt0eXBlXTtcbiAgaWYgKCFDVE9SKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGdsIHR5cGUnKTtcbiAgfVxuICByZXR1cm4gQ1RPUjtcbn1cblxuY29uc3QgaXNBcnJheUJ1ZmZlciQxID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuICA/IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJPclNoYXJlZEFycmF5QnVmZmVyKGEpIHtcbiAgICByZXR1cm4gYSAmJiBhLmJ1ZmZlciAmJiAoYS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBhLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKTtcbiAgfVxuICA6IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIoYSkge1xuICAgIHJldHVybiBhICYmIGEuYnVmZmVyICYmIGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gIH07XG5cbnZhciB0eXBlZGFycmF5cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZXRHTFR5cGVGb3JUeXBlZEFycmF5OiBnZXRHTFR5cGVGb3JUeXBlZEFycmF5LFxuICBnZXRHTFR5cGVGb3JUeXBlZEFycmF5VHlwZTogZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUsXG4gIGdldFR5cGVkQXJyYXlUeXBlRm9yR0xUeXBlOiBnZXRUeXBlZEFycmF5VHlwZUZvckdMVHlwZSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlciQxXG59KTtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTogXCJvZmZcIiAqL1xuXG4vKipcbiAqIENvcHkgbmFtZWQgcHJvcGVydGllc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzIG5hbWVzIG9mIHByb3BlcnRpZXMgdG8gY29weVxuICogQHBhcmFtIHtvYmplY3R9IHNyYyBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7b2JqZWN0fSBkc3Qgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29weU5hbWVkUHJvcGVydGllcyhuYW1lcywgc3JjLCBkc3QpIHtcbiAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzcmNbbmFtZV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRzdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gZGVzdCBvbmx5IGlmIGEgbWF0Y2hpbmcga2V5IGlzIGluIGRlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gc3JjIHRoZSBzb3VyY2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsID8+fSBkc3QgdGhlIGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvcHlFeGlzdGluZ1Byb3BlcnRpZXMoc3JjLCBkc3QpIHtcbiAgT2JqZWN0LmtleXMoZHN0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChkc3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkgeyAgLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlcnJvciQxKC4uLmFyZ3MpIHtcbiAgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gd2FybiQxKC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xufVxuXG5jb25zdCBpc1R5cGVXZWFrTWFwcyA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gaXNUeXBlKG9iamVjdCwgdHlwZSkge1xuICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgd2Vha01hcCA9IGlzVHlwZVdlYWtNYXBzLmdldCh0eXBlKTtcbiAgaWYgKCF3ZWFrTWFwKSB7XG4gICAgd2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgaXNUeXBlV2Vha01hcHMuc2V0KHR5cGUsIHdlYWtNYXApO1xuICB9XG4gIGxldCBpc09mVHlwZSA9IHdlYWtNYXAuZ2V0KG9iamVjdCk7XG4gIGlmIChpc09mVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgIGlzT2ZUeXBlID0gcy5zdWJzdHJpbmcoOCwgcy5sZW5ndGggLSAxKSA9PT0gdHlwZTtcbiAgICB3ZWFrTWFwLnNldChvYmplY3QsIGlzT2ZUeXBlKTtcbiAgfVxuICByZXR1cm4gaXNPZlR5cGU7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKGdsLCB0KSB7XG4gIHJldHVybiB0eXBlb2YgV2ViR0xCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGlzVHlwZSh0LCAnV2ViR0xCdWZmZXInKTtcbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJidWZmZXIoZ2wsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBXZWJHTFJlbmRlcmJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNUeXBlKHQsICdXZWJHTFJlbmRlcmJ1ZmZlcicpO1xufVxuXG5mdW5jdGlvbiBpc1RleHR1cmUoZ2wsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBXZWJHTFRleHR1cmUgIT09ICd1bmRlZmluZWQnICYmIGlzVHlwZSh0LCAnV2ViR0xUZXh0dXJlJyk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtcGxlcihnbCwgdCkge1xuICByZXR1cm4gdHlwZW9mIFdlYkdMU2FtcGxlciAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNUeXBlKHQsICdXZWJHTFNhbXBsZXInKTtcbn1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBTVEFUSUNfRFJBVyAgICAgICAgICAgICAgICAgID0gMHg4OGU0O1xuY29uc3QgQVJSQVlfQlVGRkVSJDEgICAgICAgICAgICAgICAgID0gMHg4ODkyO1xuY29uc3QgRUxFTUVOVF9BUlJBWV9CVUZGRVIkMiAgICAgICAgID0gMHg4ODkzO1xuY29uc3QgQlVGRkVSX1NJWkUgICAgICAgICAgICAgICAgICA9IDB4ODc2NDtcblxuY29uc3QgQllURSQxICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDAwO1xuY29uc3QgVU5TSUdORURfQllURSQyICAgICAgICAgICAgICAgID0gMHgxNDAxO1xuY29uc3QgU0hPUlQkMSAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDAyO1xuY29uc3QgVU5TSUdORURfU0hPUlQkMiAgICAgICAgICAgICAgID0gMHgxNDAzO1xuY29uc3QgSU5UJDIgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDA0O1xuY29uc3QgVU5TSUdORURfSU5UJDIgICAgICAgICAgICAgICAgID0gMHgxNDA1O1xuY29uc3QgRkxPQVQkMiAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDA2O1xuY29uc3QgZGVmYXVsdHMkMiA9IHtcbiAgYXR0cmliUHJlZml4OiBcIlwiLFxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IGF0dHJpYiBwcmVmaXhcbiAqXG4gKiBXaGVuIHdyaXRpbmcgc2hhZGVycyBJIHByZWZlciB0byBuYW1lIGF0dHJpYnV0ZXMgd2l0aCBgYV9gLCB1bmlmb3JtcyB3aXRoIGB1X2AgYW5kIHZhcnlpbmdzIHdpdGggYHZfYFxuICogYXMgaXQgbWFrZXMgaXQgY2xlYXIgd2hlcmUgdGhleSBjYW1lIGZyb20uIEJ1dCwgd2hlbiBidWlsZGluZyBnZW9tZXRyeSBJIHByZWZlciB1c2luZyB1bi1wcmVmaXhlZCBuYW1lcy5cbiAqXG4gKiBJbiBvdGhlciB3b3JkcyBJJ2xsIGNyZWF0ZSBhcnJheXMgb2YgZ2VvbWV0cnkgbGlrZSB0aGlzXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICBwb3NpdGlvbjogLi4uXG4gKiAgICAgICBub3JtYWw6IC4uLlxuICogICAgICAgdGV4Y29vcmQ6IC4uLlxuICogICAgIH07XG4gKlxuICogQnV0IG5lZWQgdGhvc2UgbWFwcGVkIHRvIGF0dHJpYnV0ZXMgYW5kIG15IGF0dHJpYnV0ZXMgc3RhcnQgd2l0aCBgYV9gLlxuICpcbiAqIEBkZXByZWNhdGVkIHNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0RGVmYXVsdHN9XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHByZWZpeCBmb3IgYXR0cmlic1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlUHJlZml4KHByZWZpeCkge1xuICBkZWZhdWx0cyQyLmF0dHJpYlByZWZpeCA9IHByZWZpeDtcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdHMkMihuZXdEZWZhdWx0cykge1xuICBjb3B5RXhpc3RpbmdQcm9wZXJ0aWVzKG5ld0RlZmF1bHRzLCBkZWZhdWx0cyQyKTtcbn1cblxuZnVuY3Rpb24gc2V0QnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGUsIGJ1ZmZlciwgYXJyYXksIGRyYXdUeXBlKSB7XG4gIGdsLmJpbmRCdWZmZXIodHlwZSwgYnVmZmVyKTtcbiAgZ2wuYnVmZmVyRGF0YSh0eXBlLCBhcnJheSwgZHJhd1R5cGUgfHwgU1RBVElDX0RSQVcpO1xufVxuXG4vKipcbiAqIEdpdmVuIHR5cGVkIGFycmF5IGNyZWF0ZXMgYSBXZWJHTEJ1ZmZlciBhbmQgY29waWVzIHRoZSB0eXBlZCBhcnJheVxuICogaW50byBpdC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8U2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fFdlYkdMQnVmZmVyfSB0eXBlZEFycmF5IHRoZSB0eXBlZCBhcnJheS4gTm90ZTogSWYgYSBXZWJHTEJ1ZmZlciBpcyBwYXNzZWQgaW4gaXQgd2lsbCBqdXN0IGJlIHJldHVybmVkLiBObyBhY3Rpb24gd2lsbCBiZSB0YWtlblxuICogQHBhcmFtIHtudW1iZXJ9IFt0eXBlXSB0aGUgR0wgYmluZCB0eXBlIGZvciB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gYGdsLkFSUkFZX0JVRkZFUmAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RyYXdUeXBlXSB0aGUgR0wgZHJhdyB0eXBlIGZvciB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gJ2dsLlNUQVRJQ19EUkFXYC5cbiAqIEByZXR1cm4ge1dlYkdMQnVmZmVyfSB0aGUgY3JlYXRlZCBXZWJHTEJ1ZmZlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGVkQXJyYXksIHR5cGUsIGRyYXdUeXBlKSB7XG4gIGlmIChpc0J1ZmZlcihnbCwgdHlwZWRBcnJheSkpIHtcbiAgICByZXR1cm4gdHlwZWRBcnJheTtcbiAgfVxuICB0eXBlID0gdHlwZSB8fCBBUlJBWV9CVUZGRVIkMTtcbiAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIHNldEJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlLCBidWZmZXIsIHR5cGVkQXJyYXksIGRyYXdUeXBlKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gaXNJbmRpY2VzKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPT09IFwiaW5kaWNlc1wiO1xufVxuXG4vLyBUaGlzIGlzIHJlYWxseSBqdXN0IGEgZ3Vlc3MuIFRob3VnaCBJIGNhbid0IHJlYWxseSBpbWFnaW5lIHVzaW5nXG4vLyBhbnl0aGluZyBlbHNlPyBNYXliZSBmb3Igc29tZSBjb21wcmVzc2lvbj9cbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25Gb3JUeXBlZEFycmF5VHlwZSh0eXBlZEFycmF5VHlwZSkge1xuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IEludDhBcnJheSkgICAgeyByZXR1cm4gdHJ1ZTsgfSAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQ4QXJyYXkpICAgeyByZXR1cm4gdHJ1ZTsgfSAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5JDEoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5Lmxlbmd0aCA/IGFycmF5IDogYXJyYXkuZGF0YTtcbn1cblxuY29uc3QgdGV4Y29vcmRSRSA9IC9jb29yZHx0ZXh0dXJlL2k7XG5jb25zdCBjb2xvclJFID0gL2NvbG9yfGNvbG91ci9pO1xuXG5mdW5jdGlvbiBndWVzc051bUNvbXBvbmVudHNGcm9tTmFtZShuYW1lLCBsZW5ndGgpIHtcbiAgbGV0IG51bUNvbXBvbmVudHM7XG4gIGlmICh0ZXhjb29yZFJFLnRlc3QobmFtZSkpIHtcbiAgICBudW1Db21wb25lbnRzID0gMjtcbiAgfSBlbHNlIGlmIChjb2xvclJFLnRlc3QobmFtZSkpIHtcbiAgICBudW1Db21wb25lbnRzID0gNDtcbiAgfSBlbHNlIHtcbiAgICBudW1Db21wb25lbnRzID0gMzsgIC8vIHBvc2l0aW9uLCBub3JtYWxzLCBpbmRpY2VzIC4uLlxuICB9XG5cbiAgaWYgKGxlbmd0aCAlIG51bUNvbXBvbmVudHMgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGd1ZXNzIG51bUNvbXBvbmVudHMgZm9yIGF0dHJpYnV0ZSAnJHtuYW1lfScuIFRyaWVkICR7bnVtQ29tcG9uZW50c30gYnV0ICR7bGVuZ3RofSB2YWx1ZXMgaXMgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgJHtudW1Db21wb25lbnRzfS4gWW91IHNob3VsZCBzcGVjaWZ5IGl0LmApO1xuICB9XG5cbiAgcmV0dXJuIG51bUNvbXBvbmVudHM7XG59XG5cbmZ1bmN0aW9uIGdldE51bUNvbXBvbmVudHMkMShhcnJheSwgYXJyYXlOYW1lLCBudW1WYWx1ZXMpIHtcbiAgcmV0dXJuIGFycmF5Lm51bUNvbXBvbmVudHMgfHwgYXJyYXkuc2l6ZSB8fCBndWVzc051bUNvbXBvbmVudHNGcm9tTmFtZShhcnJheU5hbWUsIG51bVZhbHVlcyB8fCBnZXRBcnJheSQxKGFycmF5KS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBtYWtlVHlwZWRBcnJheShhcnJheSwgbmFtZSkge1xuICBpZiAoaXNBcnJheUJ1ZmZlciQxKGFycmF5KSkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyJDEoYXJyYXkuZGF0YSkpIHtcbiAgICByZXR1cm4gYXJyYXkuZGF0YTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIGFycmF5ID0ge1xuICAgICAgZGF0YTogYXJyYXksXG4gICAgfTtcbiAgfVxuXG4gIGxldCBUeXBlID0gYXJyYXkudHlwZSA/IHR5cGVkQXJyYXlUeXBlRnJvbUdMVHlwZU9yVHlwZWRBcnJheUN0b3IoYXJyYXkudHlwZSkgOiB1bmRlZmluZWQ7XG4gIGlmICghVHlwZSkge1xuICAgIGlmIChpc0luZGljZXMobmFtZSkpIHtcbiAgICAgIFR5cGUgPSBVaW50MTZBcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgVHlwZSA9IEZsb2F0MzJBcnJheTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBUeXBlKGFycmF5LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBnbFR5cGVGcm9tR0xUeXBlT3JUeXBlZEFycmF5VHlwZShnbFR5cGVPclR5cGVkQXJyYXlDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgZ2xUeXBlT3JUeXBlZEFycmF5Q3RvciA9PT0gJ251bWJlcidcbiAgICAgID8gZ2xUeXBlT3JUeXBlZEFycmF5Q3RvclxuICAgICAgOiBnbFR5cGVPclR5cGVkQXJyYXlDdG9yID8gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUoZ2xUeXBlT3JUeXBlZEFycmF5Q3RvcikgOiBGTE9BVCQyO1xufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5VHlwZUZyb21HTFR5cGVPclR5cGVkQXJyYXlDdG9yKGdsVHlwZU9yVHlwZWRBcnJheUN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBnbFR5cGVPclR5cGVkQXJyYXlDdG9yID09PSAnbnVtYmVyJ1xuICAgICAgPyBnZXRUeXBlZEFycmF5VHlwZUZvckdMVHlwZShnbFR5cGVPclR5cGVkQXJyYXlDdG9yKVxuICAgICAgOiBnbFR5cGVPclR5cGVkQXJyYXlDdG9yIHx8IEZsb2F0MzJBcnJheTtcbn1cblxuZnVuY3Rpb24gYXR0cmliQnVmZmVyRnJvbUJ1ZmZlcihnbCwgYXJyYXkvKiwgYXJyYXlOYW1lICovKSB7XG4gIHJldHVybiB7XG4gICAgYnVmZmVyOiBhcnJheS5idWZmZXIsXG4gICAgbnVtVmFsdWVzOiAyICogMyAqIDQsICAvLyBzYWZlbHkgZGl2aWRlZCBieSAyLCAzLCA0XG4gICAgdHlwZTogZ2xUeXBlRnJvbUdMVHlwZU9yVHlwZWRBcnJheVR5cGUoYXJyYXkudHlwZSksXG4gICAgYXJyYXlUeXBlOiB0eXBlZEFycmF5VHlwZUZyb21HTFR5cGVPclR5cGVkQXJyYXlDdG9yKGFycmF5LnR5cGUpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyaWJCdWZmZXJGcm9tU2l6ZShnbCwgYXJyYXkvKiwgYXJyYXlOYW1lKi8pIHtcbiAgY29uc3QgbnVtVmFsdWVzID0gYXJyYXkuZGF0YSB8fCBhcnJheTtcbiAgY29uc3QgYXJyYXlUeXBlID0gdHlwZWRBcnJheVR5cGVGcm9tR0xUeXBlT3JUeXBlZEFycmF5Q3RvcihhcnJheS50eXBlKTtcbiAgY29uc3QgbnVtQnl0ZXMgPSBudW1WYWx1ZXMgKiBhcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiQxLCBidWZmZXIpO1xuICBnbC5idWZmZXJEYXRhKEFSUkFZX0JVRkZFUiQxLCBudW1CeXRlcywgYXJyYXkuZHJhd1R5cGUgfHwgU1RBVElDX0RSQVcpO1xuICByZXR1cm4ge1xuICAgIGJ1ZmZlcixcbiAgICBudW1WYWx1ZXMsXG4gICAgdHlwZTogZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUoYXJyYXlUeXBlKSxcbiAgICBhcnJheVR5cGUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJpYkJ1ZmZlckZyb21BcnJheUxpa2UoZ2wsIGFycmF5LCBhcnJheU5hbWUpIHtcbiAgY29uc3QgdHlwZWRBcnJheSA9IG1ha2VUeXBlZEFycmF5KGFycmF5LCBhcnJheU5hbWUpO1xuICByZXR1cm4ge1xuICAgIGFycmF5VHlwZTogdHlwZWRBcnJheS5jb25zdHJ1Y3RvcixcbiAgICBidWZmZXI6IGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5KGdsLCB0eXBlZEFycmF5LCB1bmRlZmluZWQsIGFycmF5LmRyYXdUeXBlKSxcbiAgICB0eXBlOiBnZXRHTFR5cGVGb3JUeXBlZEFycmF5KHR5cGVkQXJyYXkpLFxuICAgIG51bVZhbHVlczogMCxcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgaW5mbyBmb3IgYW4gYXR0cmlidXRlLiBUaGlzIGlzIGVmZmVjdGl2ZWx5IGp1c3QgdGhlIGFyZ3VtZW50cyB0byBgZ2wudmVydGV4QXR0cmliUG9pbnRlcmAgcGx1cyB0aGUgV2ViR0xCdWZmZXJcbiAqIGZvciB0aGUgYXR0cmlidXRlLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF0dHJpYkluZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fSBbdmFsdWVdIGEgY29uc3RhbnQgdmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGUuIE5vdGU6IGlmIHRoaXMgaXMgc2V0IHRoZSBhdHRyaWJ1dGUgd2lsbCBiZVxuICogICAgZGlzYWJsZWQgYW5kIHNldCB0byB0aGlzIGNvbnN0YW50IHZhbHVlIGFuZCBhbGwgb3RoZXIgdmFsdWVzIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtQ29tcG9uZW50c10gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciB0aGlzIGF0dHJpYnV0ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZV0gc3lub255bSBmb3IgYG51bUNvbXBvbmVudHNgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0eXBlXSB0aGUgdHlwZSBvZiB0aGUgYXR0cmlidXRlIChlZy4gYGdsLkZMT0FUYCwgYGdsLlVOU0lHTkVEX0JZVEVgLCBldGMuLi4pIERlZmF1bHQgPSBgZ2wuRkxPQVRgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtub3JtYWxpemVdIHdoZXRoZXIgb3Igbm90IHRvIG5vcm1hbGl6ZSB0aGUgZGF0YS4gRGVmYXVsdCA9IGZhbHNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldF0gb2Zmc2V0IGludG8gYnVmZmVyIGluIGJ5dGVzLiBEZWZhdWx0ID0gMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdHJpZGVdIHRoZSBzdHJpZGUgaW4gYnl0ZXMgcGVyIGVsZW1lbnQuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Rpdmlzb3JdIHRoZSBkaXZpc29yIGluIGluc3RhbmNlcy4gRGVmYXVsdCA9IDAuXG4gKiAgICBSZXF1aXJlcyBXZWJHTDIgb3IgdGhlIEFOR0xFX2luc3RhbmNlZF9hcnJheXMgZXh0ZW5zaW9uLlxuICogICAgYW5kLCBpZiB5b3UncmUgdXNpbmcgV2ViR0wxIHlvdSBtdXN0IGhhdmUgY2FsbGVkIHtAbGluayBtb2R1bGU6dHdnbC5hZGRFeHRlbnNpb25zVG9Db250ZXh0fVxuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgZGF0YSBmb3IgdGhpcyBhdHRyaWJ1dGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHJhd1R5cGVdIHRoZSBkcmF3IHR5cGUgcGFzc2VkIHRvIGdsLmJ1ZmZlckRhdGEuIERlZmF1bHQgPSBnbC5TVEFUSUNfRFJBV1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KEludDhBcnJheUNvbnN0cnVjdG9yfFVpbnQ4QXJyYXlDb25zdHJ1Y3RvcnxJbnQxNkFycmF5Q29uc3RydWN0b3J8VWludDE2QXJyYXlDb25zdHJ1Y3RvcnxJbnQzMkFycmF5Q29uc3RydWN0b3J8VWludDMyQXJyYXlDb25zdHJ1Y3RvcnxGbG9hdDMyQXJyYXlDb25zdHJ1Y3Rvcil9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvclxuICovXG5cbi8qKlxuICogVXNlIHRoaXMgdHlwZSBvZiBhcnJheSBzcGVjIHdoZW4gVFdHTCBjYW4ndCBndWVzcyB0aGUgdHlwZSBvciBudW1iZXIgb2YgY29tcG9uZW50cyBvZiBhbiBhcnJheVxuICogQHR5cGVkZWYge09iamVjdH0gRnVsbEFycmF5U3BlY1xuICogQHByb3BlcnR5IHtudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd9IFt2YWx1ZV0gYSBjb25zdGFudCB2YWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZS4gTm90ZTogaWYgdGhpcyBpcyBzZXQgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlXG4gKiAgICBkaXNhYmxlZCBhbmQgc2V0IHRvIHRoaXMgY29uc3RhbnQgdmFsdWUgYW5kIGFsbCBvdGhlciB2YWx1ZXMgd2lsbCBiZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHsobnVtYmVyfG51bWJlcltdfEFycmF5QnVmZmVyVmlldyl9IFtkYXRhXSBUaGUgZGF0YSBvZiB0aGUgYXJyYXkuIEEgbnVtYmVyIGFsb25lIGJlY29tZXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1Db21wb25lbnRzXSBudW1iZXIgb2YgY29tcG9uZW50cyBmb3IgYHZlcnRleEF0dHJpYlBvaW50ZXJgLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBuYW1lIG9mIHRoZSBhcnJheS5cbiAqICAgIElmIGBjb29yZGAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDJgLlxuICogICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGAuXG4gKiAgICBvdGhlcndpc2UgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDNgXG4gKiBAcHJvcGVydHkge251bWJlcnxUeXBlZEFycmF5Q29uc3RydWN0b3J9IFt0eXBlXSB0eXBlLiBUaGlzIGlzIHVzZWQgaWYgYGRhdGFgIGlzIGEgSmF2YVNjcmlwdCBhcnJheSwgb3IgYGJ1ZmZlcmAgaXMgcGFzc2VkIGluLCBvciBgZGF0YWAgaXMgYSBudW1iZXIuXG4gKiAgIEl0IGNhbiBlaXRoZXIgYmUgdGhlIGNvbnN0cnVjdG9yIGZvciBhIHR5cGVkYXJyYXkuIChlZy4gYFVpbnQ4QXJyYXlgKSBPUiBhIFdlYkdMIHR5cGUsIChlZyBgZ2wuVU5TSUdORURfQllURWApLlxuICogICBGb3IgZXhhbXBsZSBpZiB5b3Ugd2FudCBjb2xvcnMgaW4gYSBgVWludDhBcnJheWAgeW91IG1pZ2h0IGhhdmUgYSBgRnVsbEFycmF5U3BlY2AgbGlrZSBgeyB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBkYXRhOiBbMjU1LDAsMjU1LDI1NSwgLi4uXSwgfWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NpemVdIHN5bm9ueW0gZm9yIGBudW1Db21wb25lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25vcm1hbGl6ZV0gbm9ybWFsaXplIGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgaXMgdHJ1ZSBpZiB0eXBlIGlzIGBJbnQ4QXJyYXlgIG9yIGBVaW50OEFycmF5YCBvdGhlcndpc2UgZmFsc2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0cmlkZV0gc3RyaWRlIGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldF0gb2Zmc2V0IGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Rpdmlzb3JdIGRpdmlzb3IgZm9yIGB2ZXJ0ZXhBdHRyaWJEaXZpc29yYC4gRGVmYXVsdCA9IDAuXG4gKiAgICAgUmVxdWlyZXMgV2ViR0wyIG9yIHRoZSBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzIGV4dGVuc2lvbi5cbiAqICAgICBhbmQsIGlmIHlvdSB1c2luZyBXZWJHTDEgeW91IG11c3QgaGF2ZSBjYWxsZWQge0BsaW5rIG1vZHVsZTp0d2dsLmFkZEV4dGVuc2lvbnNUb0NvbnRleHR9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2F0dHJpYl0gbmFtZSBvZiBhdHRyaWJ1dGUgdGhpcyBhcnJheSBtYXBzIHRvLiBEZWZhdWx0cyB0byBzYW1lIG5hbWUgYXMgYXJyYXkgcHJlZml4ZWQgYnkgdGhlIGRlZmF1bHQgYXR0cmliUHJlZml4LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBzeW5vbnltIGZvciBgYXR0cmliYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmliTmFtZV0gc3lub255bSBmb3IgYGF0dHJpYmAuXG4gKiBAcHJvcGVydHkge1dlYkdMQnVmZmVyfSBbYnVmZmVyXSBCdWZmZXIgdG8gdXNlIGZvciB0aGlzIGF0dHJpYnV0ZS4gVGhpcyBsZXRzIHlvdSB1c2UgeW91ciBvd24gYnVmZmVyXG4gKiAgICBidXQgeW91IHdpbGwgbmVlZCB0byBzdXBwbHkgYG51bUNvbXBvbmVudHNgIGFuZCBgdHlwZWAuIFlvdSBjYW4gZWZmZWN0aXZlbHkgcGFzcyBhbiBgQXR0cmliSW5mb2BcbiAqICAgIHRvIHByb3ZpZGUgdGhpcy4gRXhhbXBsZTpcbiAqXG4gKiAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8xID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwge1xuICogICAgICAgICAgIHBvc2l0aW9uOiBbMSwgMiwgMywgLi4uIF0sXG4gKiAgICAgICAgIH0pO1xuICogICAgICAgICBjb25zdCBidWZmZXJJbmZvMiA9IHR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIHtcbiAqICAgICAgICAgICBwb3NpdGlvbjogYnVmZmVySW5mbzEuYXR0cmlicy5wb3NpdGlvbiwgIC8vIHVzZSB0aGUgc2FtZSBidWZmZXIgZnJvbSBidWZmZXJJbmZvMVxuICogICAgICAgICB9KTtcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RyYXdUeXBlXSB0aGUgZHJhdyB0eXBlIHBhc3NlZCB0byBnbC5idWZmZXJEYXRhLiBEZWZhdWx0ID0gZ2wuU1RBVElDX0RSQVdcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQW4gaW5kaXZpZHVhbCBhcnJheSBpbiB7QGxpbmsgbW9kdWxlOnR3Z2wuQXJyYXlzfVxuICpcbiAqIFdoZW4gcGFzc2VkIHRvIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5c30gaWYgYW4gQXJyYXlTcGVjIGlzIGBudW1iZXJbXWAgb3IgYEFycmF5QnVmZmVyVmlld2BcbiAqIHRoZSB0eXBlcyB3aWxsIGJlIGd1ZXNzZWQgYmFzZWQgb24gdGhlIG5hbWUuIGBpbmRpY2VzYCB3aWxsIGJlIGBVaW50MTZBcnJheWAsIGV2ZXJ5dGhpbmcgZWxzZSB3aWxsXG4gKiBiZSBgRmxvYXQzMkFycmF5YC4gSWYgYW4gQXJyYXlTcGVjIGlzIGEgbnVtYmVyIGl0J3MgdGhlIG51bWJlciBvZiBmbG9hdHMgZm9yIGFuIGVtcHR5ICh6ZXJvZWQpIGJ1ZmZlci5cbiAqXG4gKiBAdHlwZWRlZiB7KG51bWJlcnxudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8bW9kdWxlOnR3Z2wuRnVsbEFycmF5U3BlYyl9IEFycmF5U3BlY1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvYmplY3Qgb2YgYXJyYXlzIGJ5IG5hbWUuIFRoZSBuYW1lcyBzaG91bGQgbWF0Y2ggeW91ciBzaGFkZXIncyBhdHRyaWJ1dGVzLiBJZiB5b3VyXG4gKiBhdHRyaWJ1dGVzIGhhdmUgYSBjb21tb24gcHJlZml4IHlvdSBjYW4gc3BlY2lmeSBpdCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC5zZXRBdHRyaWJ1dGVQcmVmaXh9LlxuICpcbiAqICAgICBCYXJlIEphdmFTY3JpcHQgQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogWy0xLCAxLCAwXSxcbiAqICAgICAgICAgICAgbm9ybWFsOiBbMCwgMSwgMF0sXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogICAgIEJhcmUgVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgMF0pLFxuICogICAgICAgICAgICBjb2xvcjogbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMTI4LCA2NCwgMjU1XSksXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogKiAgIFdpbGwgZ3Vlc3MgYXQgYG51bUNvbXBvbmVudHNgIGlmIG5vdCBzcGVjaWZpZWQgYmFzZWQgb24gbmFtZS5cbiAqXG4gKiAgICAgSWYgYGNvb3JkYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gMmBcbiAqXG4gKiAgICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGBcbiAqXG4gKiAgICAgb3RoZXJ3aXNlIGFzc3VtZXMgYG51bUNvbXBvbmVudHMgPSAzYFxuICpcbiAqIE9iamVjdHMgd2l0aCB2YXJpb3VzIGZpZWxkcy4gU2VlIHtAbGluayBtb2R1bGU6dHdnbC5GdWxsQXJyYXlTcGVjfS5cbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sIH0sXG4gKiAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCBkYXRhOiBbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0sICAgICAgICAgICAgICAgICB9LFxuICogICAgICAgbm9ybWFsOiAgIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLCAgICAgfSxcbiAqICAgICAgIGluZGljZXM6ICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAxLCAyLCAxLCAyLCAzXSwgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkFycmF5U3BlYz59IEFycmF5c1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2YgYXR0cmlidXRlIGRhdGEgYW5kIFdlYkdMQnVmZmVycyBmcm9tIHNldCBvZiBhcnJheXNcbiAqXG4gKiBHaXZlblxuICpcbiAqICAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdLCB9LFxuICogICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSwgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgbm9ybWFsOiAgIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLCAgICAgfSxcbiAqICAgICAgICBjb2xvcjogICAgeyBudW1Db21wb25lbnRzOiA0LCBkYXRhOiBbMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDAsIDAsIDI1NSwgMCwgMCwgMjU1LCAyNTVdLCB0eXBlOiBVaW50OEFycmF5LCB9LFxuICogICAgICAgIGluZGljZXM6ICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAxLCAyLCAxLCAyLCAzXSwgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgIH07XG4gKlxuICogcmV0dXJucyBzb21ldGhpbmcgbGlrZVxuICpcbiAqICAgICAgdmFyIGF0dHJpYnMgPSB7XG4gKiAgICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgdHlwZTogZ2wuRkxPQVQsICAgICAgICAgbm9ybWFsaXplOiBmYWxzZSwgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgfSxcbiAqICAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCB0eXBlOiBnbC5GTE9BVCwgICAgICAgICBub3JtYWxpemU6IGZhbHNlLCBidWZmZXI6IFdlYkdMQnVmZmVyLCB9LFxuICogICAgICAgIG5vcm1hbDogICB7IG51bUNvbXBvbmVudHM6IDMsIHR5cGU6IGdsLkZMT0FULCAgICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsIGJ1ZmZlcjogV2ViR0xCdWZmZXIsIH0sXG4gKiAgICAgICAgY29sb3I6ICAgIHsgbnVtQ29tcG9uZW50czogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplOiB0cnVlLCAgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgfSxcbiAqICAgICAgfTtcbiAqXG4gKiBub3RlczpcbiAqXG4gKiAqICAgQXJyYXlzIGNhbiB0YWtlIHZhcmlvdXMgZm9ybXNcbiAqXG4gKiAgICAgQmFyZSBKYXZhU2NyaXB0IEFycmF5c1xuICpcbiAqICAgICAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICAgICAgcG9zaXRpb246IFstMSwgMSwgMF0sXG4gKiAgICAgICAgICAgIG5vcm1hbDogWzAsIDEsIDBdLFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqICAgICBCYXJlIFR5cGVkQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbLTEsIDEsIDBdKSxcbiAqICAgICAgICAgICAgY29sb3I6IG5ldyBVaW50OEFycmF5KFsyNTUsIDEyOCwgNjQsIDI1NV0pLFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqICogICBXaWxsIGd1ZXNzIGF0IGBudW1Db21wb25lbnRzYCBpZiBub3Qgc3BlY2lmaWVkIGJhc2VkIG9uIG5hbWUuXG4gKlxuICogICAgIElmIGBjb29yZGAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDJgXG4gKlxuICogICAgIElmIGBjb2xvcmAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDRgXG4gKlxuICogICAgIG90aGVyd2lzZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gM2BcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIHdlYmdsIHJlbmRlcmluZyBjb250ZXh0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BcnJheXN9IGFycmF5cyBUaGUgYXJyYXlzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFtzcmNCdWZmZXJJbmZvXSBhIEJ1ZmZlckluZm8gdG8gY29weSBmcm9tXG4gKiAgIFRoaXMgbGV0cyB5b3Ugc2hhcmUgYnVmZmVycy4gQW55IGFycmF5cyB5b3Ugc3VwcGx5IHdpbGwgb3ZlcnJpZGVcbiAqICAgdGhlIGJ1ZmZlcnMgZnJvbSBzcmNCdWZmZXJJbmZvLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSB0aGUgYXR0cmlic1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXR0cmlic0Zyb21BcnJheXMoZ2wsIGFycmF5cykge1xuICBjb25zdCBhdHRyaWJzID0ge307XG4gIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbihhcnJheU5hbWUpIHtcbiAgICBpZiAoIWlzSW5kaWNlcyhhcnJheU5hbWUpKSB7XG4gICAgICBjb25zdCBhcnJheSA9IGFycmF5c1thcnJheU5hbWVdO1xuICAgICAgY29uc3QgYXR0cmliTmFtZSA9IGFycmF5LmF0dHJpYiB8fCBhcnJheS5uYW1lIHx8IGFycmF5LmF0dHJpYk5hbWUgfHwgKGRlZmF1bHRzJDIuYXR0cmliUHJlZml4ICsgYXJyYXlOYW1lKTtcbiAgICAgIGlmIChhcnJheS52YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkudmFsdWUpICYmICFpc0FycmF5QnVmZmVyJDEoYXJyYXkudmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheS52YWx1ZSBpcyBub3QgYXJyYXkgb3IgdHlwZWRhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnNbYXR0cmliTmFtZV0gPSB7XG4gICAgICAgICAgdmFsdWU6IGFycmF5LnZhbHVlLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGZuO1xuICAgICAgICBpZiAoYXJyYXkuYnVmZmVyICYmIGFycmF5LmJ1ZmZlciBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyKSB7XG4gICAgICAgICAgZm4gPSBhdHRyaWJCdWZmZXJGcm9tQnVmZmVyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJheSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYXJyYXkuZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGZuID0gYXR0cmliQnVmZmVyRnJvbVNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm4gPSBhdHRyaWJCdWZmZXJGcm9tQXJyYXlMaWtlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtidWZmZXIsIHR5cGUsIG51bVZhbHVlcywgYXJyYXlUeXBlfSA9IGZuKGdsLCBhcnJheSwgYXJyYXlOYW1lKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXphdGlvbiA9IGFycmF5Lm5vcm1hbGl6ZSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubm9ybWFsaXplIDogZ2V0Tm9ybWFsaXphdGlvbkZvclR5cGVkQXJyYXlUeXBlKGFycmF5VHlwZSk7XG4gICAgICAgIGNvbnN0IG51bUNvbXBvbmVudHMgPSBnZXROdW1Db21wb25lbnRzJDEoYXJyYXksIGFycmF5TmFtZSwgbnVtVmFsdWVzKTtcbiAgICAgICAgYXR0cmlic1thdHRyaWJOYW1lXSA9IHtcbiAgICAgICAgICBidWZmZXI6ICAgICAgICBidWZmZXIsXG4gICAgICAgICAgbnVtQ29tcG9uZW50czogbnVtQ29tcG9uZW50cyxcbiAgICAgICAgICB0eXBlOiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG5vcm1hbGl6ZTogICAgIG5vcm1hbGl6YXRpb24sXG4gICAgICAgICAgc3RyaWRlOiAgICAgICAgYXJyYXkuc3RyaWRlIHx8IDAsXG4gICAgICAgICAgb2Zmc2V0OiAgICAgICAgYXJyYXkub2Zmc2V0IHx8IDAsXG4gICAgICAgICAgZGl2aXNvcjogICAgICAgYXJyYXkuZGl2aXNvciA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYXJyYXkuZGl2aXNvcixcbiAgICAgICAgICBkcmF3VHlwZTogICAgICBhcnJheS5kcmF3VHlwZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiQxLCBudWxsKTtcbiAgcmV0dXJuIGF0dHJpYnM7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgY29udGVudHMgb2YgYSBidWZmZXIgYXR0YWNoZWQgdG8gYW4gYXR0cmliSW5mb1xuICpcbiAqIFRoaXMgaXMgaGVscGVyIGZ1bmN0aW9uIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSBhIGJ1ZmZlci5cbiAqXG4gKiBMZXQncyBzYXkgeW91IG1ha2UgYSBidWZmZXJJbmZvXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgcG9zaXRpb246IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSksXG4gKiAgICAgICAgdGV4Y29vcmQ6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdKSxcbiAqICAgICAgICBub3JtYWw6ICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0pLFxuICogICAgICAgIGluZGljZXM6ICBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDEsIDIsIDNdKSxcbiAqICAgICB9O1xuICogICAgIHZhciBidWZmZXJJbmZvID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYXJyYXlzKTtcbiAqXG4gKiAgQW5kIHlvdSB3YW50IHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgcG9zaXRpb25zLiBZb3UgY291bGQgZG8gdGhpc1xuICpcbiAqICAgICAvLyBhc3N1bWluZyBhcnJheXMucG9zaXRpb24gaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkIHdpdGggbmV3IGRhdGEuXG4gKiAgICAgdHdnbC5zZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5KGdsLCBidWZmZXJJbmZvLmF0dHJpYnMucG9zaXRpb24sIGFycmF5cy5wb3NpdGlvbik7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gKiBAcGFyYW0ge0F0dHJpYkluZm99IGF0dHJpYkluZm8gVGhlIGF0dHJpYkluZm8gd2hvJ3MgYnVmZmVyIGNvbnRlbnRzIHRvIHNldC4gTk9URTogSWYgeW91IGhhdmUgYW4gYXR0cmlidXRlIHByZWZpeFxuICogICB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHdpbGwgaW5jbHVkZSB0aGUgcHJlZml4LlxuICogQHBhcmFtIHtBcnJheVNwZWN9IGFycmF5IE5vdGU6IGl0IGlzIGFyZ3VhYmx5IGluZWZmaWNpZW50IHRvIHBhc3MgaW4gYW55dGhpbmcgYnV0IGEgdHlwZWQgYXJyYXkgYmVjYXVzZSBhbnl0aGluZ1xuICogICAgZWxzZSB3aWxsIGhhdmUgdG8gYmUgY29udmVydGVkIHRvIGEgdHlwZWQgYXJyYXkgYmVmb3JlIGl0IGNhbiBiZSB1c2VkIGJ5IFdlYkdMLiBEdXJpbmcgaW5pdCB0aW1lIHRoYXRcbiAqICAgIGluZWZmaWNpZW5jeSBpcyB1c3VhbGx5IG5vdCBpbXBvcnRhbnQgYnV0IGlmIHlvdSdyZSB1cGRhdGluZyBkYXRhIGR5bmFtaWNhbGx5IGJlc3QgdG8gYmUgZWZmaWNpZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRdIGFuIG9wdGlvbmFsIG9mZnNldCBpbnRvIHRoZSBidWZmZXIuIFRoaXMgaXMgb25seSBhbiBvZmZzZXQgaW50byB0aGUgV2ViR0wgYnVmZmVyXG4gKiAgICBub3QgdGhlIGFycmF5LiBUbyBwYXNzIGluIGFuIG9mZnNldCBpbnRvIHRoZSBhcnJheSBpdHNlbGYgdXNlIGEgdHlwZWQgYXJyYXkgYW5kIGNyZWF0ZSBhbiBgQXJyYXlCdWZmZXJWaWV3YFxuICogICAgZm9yIHRoZSBwb3J0aW9uIG9mIHRoZSBhcnJheSB5b3Ugd2FudCB0byB1c2UuXG4gKlxuICogICAgICAgIHZhciBzb21lQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEwMDApOyAvLyBhbiBhcnJheSB3aXRoIDEwMDAgZmxvYXRzXG4gKiAgICAgICAgdmFyIHNvbWVTdWJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoc29tZUFycmF5LmJ1ZmZlciwgb2Zmc2V0SW5CeXRlcywgc2l6ZUluVW5pdHMpOyAvLyBhIHZpZXcgaW50byBzb21lQXJyYXlcbiAqXG4gKiAgICBOb3cgeW91IGNhbiBwYXNzIGBzb21lU3ViQXJyYXlgIGludG8gc2V0QXR0cmliSW5mb0J1ZmZlckZyb21BcnJheWBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXkoZ2wsIGF0dHJpYkluZm8sIGFycmF5LCBvZmZzZXQpIHtcbiAgYXJyYXkgPSBtYWtlVHlwZWRBcnJheShhcnJheSk7XG4gIGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSJDEsIGF0dHJpYkluZm8uYnVmZmVyKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKEFSUkFZX0JVRkZFUiQxLCBvZmZzZXQsIGFycmF5KTtcbiAgfSBlbHNlIHtcbiAgICBzZXRCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgQVJSQVlfQlVGRkVSJDEsIGF0dHJpYkluZm8uYnVmZmVyLCBhcnJheSwgYXR0cmliSW5mby5kcmF3VHlwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qnl0ZXNQZXJWYWx1ZUZvckdMVHlwZShnbCwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gQllURSQxKSAgICAgICAgICAgcmV0dXJuIDE7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlID09PSBVTlNJR05FRF9CWVRFJDIpICByZXR1cm4gMTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGUgPT09IFNIT1JUJDEpICAgICAgICAgIHJldHVybiAyOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZSA9PT0gVU5TSUdORURfU0hPUlQkMikgcmV0dXJuIDI7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlID09PSBJTlQkMikgICAgICAgICAgICByZXR1cm4gNDsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGUgPT09IFVOU0lHTkVEX0lOVCQyKSAgIHJldHVybiA0OyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZSA9PT0gRkxPQVQkMikgICAgICAgICAgcmV0dXJuIDQ7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHJldHVybiAwO1xufVxuXG4vLyBUcmllcyB0byBnZXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIGFycmF5cy5cbmNvbnN0IHBvc2l0aW9uS2V5cyA9IFsncG9zaXRpb24nLCAncG9zaXRpb25zJywgJ2FfcG9zaXRpb24nXTtcbmZ1bmN0aW9uIGdldE51bUVsZW1lbnRzRnJvbU5vbkluZGV4ZWRBcnJheXMoYXJyYXlzKSB7XG4gIGxldCBrZXk7XG4gIGxldCBpaTtcbiAgZm9yIChpaSA9IDA7IGlpIDwgcG9zaXRpb25LZXlzLmxlbmd0aDsgKytpaSkge1xuICAgIGtleSA9IHBvc2l0aW9uS2V5c1tpaV07XG4gICAgaWYgKGtleSBpbiBhcnJheXMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaWkgPT09IHBvc2l0aW9uS2V5cy5sZW5ndGgpIHtcbiAgICBrZXkgPSBPYmplY3Qua2V5cyhhcnJheXMpWzBdO1xuICB9XG4gIGNvbnN0IGFycmF5ID0gYXJyYXlzW2tleV07XG4gIGNvbnN0IGxlbmd0aCA9IGdldEFycmF5JDEoYXJyYXkpLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDE7ICAgLy8gVGhlcmUncyBubyBhcnJheXNcbiAgfVxuICBjb25zdCBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyQxKGFycmF5LCBrZXkpO1xuICBjb25zdCBudW1FbGVtZW50cyA9IGxlbmd0aCAvIG51bUNvbXBvbmVudHM7XG4gIGlmIChsZW5ndGggJSBudW1Db21wb25lbnRzID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbnVtQ29tcG9uZW50cyAke251bUNvbXBvbmVudHN9IG5vdCBjb3JyZWN0IGZvciBsZW5ndGggJHtsZW5ndGh9YCk7XG4gIH1cbiAgcmV0dXJuIG51bUVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBnZXROdW1FbGVtZW50c0Zyb21BdHRyaWJ1dGVzKGdsLCBhdHRyaWJzKSB7XG4gIGxldCBrZXk7XG4gIGxldCBpaTtcbiAgZm9yIChpaSA9IDA7IGlpIDwgcG9zaXRpb25LZXlzLmxlbmd0aDsgKytpaSkge1xuICAgIGtleSA9IHBvc2l0aW9uS2V5c1tpaV07XG4gICAgaWYgKGtleSBpbiBhdHRyaWJzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAga2V5ID0gZGVmYXVsdHMkMi5hdHRyaWJQcmVmaXggKyBrZXk7XG4gICAgaWYgKGtleSBpbiBhdHRyaWJzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGlpID09PSBwb3NpdGlvbktleXMubGVuZ3RoKSB7XG4gICAga2V5ID0gT2JqZWN0LmtleXMoYXR0cmlicylbMF07XG4gIH1cbiAgY29uc3QgYXR0cmliID0gYXR0cmlic1trZXldO1xuICBpZiAoIWF0dHJpYi5idWZmZXIpIHtcbiAgICByZXR1cm4gMTsgLy8gVGhlcmUncyBubyBidWZmZXJcbiAgfVxuICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiQxLCBhdHRyaWIuYnVmZmVyKTtcbiAgY29uc3QgbnVtQnl0ZXMgPSBnbC5nZXRCdWZmZXJQYXJhbWV0ZXIoQVJSQVlfQlVGRkVSJDEsIEJVRkZFUl9TSVpFKTtcbiAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIkMSwgbnVsbCk7XG5cbiAgY29uc3QgYnl0ZXNQZXJWYWx1ZSA9IGdldEJ5dGVzUGVyVmFsdWVGb3JHTFR5cGUoZ2wsIGF0dHJpYi50eXBlKTtcbiAgY29uc3QgdG90YWxFbGVtZW50cyA9IG51bUJ5dGVzIC8gYnl0ZXNQZXJWYWx1ZTtcbiAgY29uc3QgbnVtQ29tcG9uZW50cyA9IGF0dHJpYi5udW1Db21wb25lbnRzIHx8IGF0dHJpYi5zaXplO1xuICAvLyBUT0RPOiBjaGVjayBzdHJpZGVcbiAgY29uc3QgbnVtRWxlbWVudHMgPSB0b3RhbEVsZW1lbnRzIC8gbnVtQ29tcG9uZW50cztcbiAgaWYgKG51bUVsZW1lbnRzICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbnVtQ29tcG9uZW50cyAke251bUNvbXBvbmVudHN9IG5vdCBjb3JyZWN0IGZvciBsZW5ndGggJHtsZW5ndGh9YCk7XG4gIH1cbiAgcmV0dXJuIG51bUVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJ1ZmZlckluZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1FbGVtZW50cyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHBhc3MgdG8gYGdsLmRyYXdBcnJheXNgIG9yIGBnbC5kcmF3RWxlbWVudHNgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlbGVtZW50VHlwZV0gVGhlIHR5cGUgb2YgaW5kaWNlcyBgVU5TSUdORURfQllURWAsIGBVTlNJR05FRF9TSE9SVGAgZXRjLi5cbiAqIEBwcm9wZXJ0eSB7V2ViR0xCdWZmZXJ9IFtpbmRpY2VzXSBUaGUgaW5kaWNlcyBgRUxFTUVOVF9BUlJBWV9CVUZGRVJgIGlmIGFueSBpbmRpY2VzIGV4aXN0LlxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz59IFthdHRyaWJzXSBUaGUgYXR0cmlicyBhcHByb3ByaWF0ZSB0byBjYWxsIGBzZXRBdHRyaWJ1dGVzYFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgQnVmZmVySW5mbyBmcm9tIGFuIG9iamVjdCBvZiBhcnJheXMuXG4gKlxuICogVGhpcyBjYW4gYmUgcGFzc2VkIHRvIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlc30gYW5kIHRvXG4gKiB7QGxpbmsgbW9kdWxlOnR3Z2w6ZHJhd0J1ZmZlckluZm99LlxuICpcbiAqIEdpdmVuIGFuIG9iamVjdCBsaWtlXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdLCB9LFxuICogICAgICAgdGV4Y29vcmQ6IHsgbnVtQ29tcG9uZW50czogMiwgZGF0YTogWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdLCAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgIG5vcm1hbDogICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSwgICAgIH0sXG4gKiAgICAgICBpbmRpY2VzOiAgeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMSwgMiwgMSwgMiwgM10sICAgICAgICAgICAgICAgICAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogIENyZWF0ZXMgYW4gQnVmZmVySW5mbyBsaWtlIHRoaXNcbiAqXG4gKiAgICAgYnVmZmVySW5mbyA9IHtcbiAqICAgICAgIG51bUVsZW1lbnRzOiA0LCAgICAgICAgLy8gb3Igd2hhdGV2ZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpc1xuICogICAgICAgaW5kaWNlczogV2ViR0xCdWZmZXIsICAvLyB0aGlzIHByb3BlcnR5IHdpbGwgbm90IGV4aXN0IGlmIHRoZXJlIGFyZSBubyBpbmRpY2VzXG4gKiAgICAgICBhdHRyaWJzOiB7XG4gKiAgICAgICAgIHBvc2l0aW9uOiB7IGJ1ZmZlcjogV2ViR0xCdWZmZXIsIG51bUNvbXBvbmVudHM6IDMsIH0sXG4gKiAgICAgICAgIG5vcm1hbDogICB7IGJ1ZmZlcjogV2ViR0xCdWZmZXIsIG51bUNvbXBvbmVudHM6IDMsIH0sXG4gKiAgICAgICAgIHRleGNvb3JkOiB7IGJ1ZmZlcjogV2ViR0xCdWZmZXIsIG51bUNvbXBvbmVudHM6IDIsIH0sXG4gKiAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogIFRoZSBwcm9wZXJ0aWVzIG9mIGFycmF5cyBjYW4gYmUgSmF2YVNjcmlwdCBhcnJheXMgaW4gd2hpY2ggY2FzZSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAqICB3aWxsIGJlIGd1ZXNzZWQuXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgcG9zaXRpb246IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sXG4gKiAgICAgICAgdGV4Y29vcmQ6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSxcbiAqICAgICAgICBub3JtYWw6ICAgWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLFxuICogICAgICAgIGluZGljZXM6ICBbMCwgMSwgMiwgMSwgMiwgM10sXG4gKiAgICAgfTtcbiAqXG4gKiAgVGhleSBjYW4gYWxzbyBiZSBUeXBlZEFycmF5c1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0pLFxuICogICAgICAgIHRleGNvb3JkOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSksXG4gKiAgICAgICAgbm9ybWFsOiAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdKSxcbiAqICAgICAgICBpbmRpY2VzOiAgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAxLCAyLCAzXSksXG4gKiAgICAgfTtcbiAqXG4gKiAgT3IgQXVnbWVudGVkVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgdmFyIHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgNCk7XG4gKiAgICAgdmFyIHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgNCk7XG4gKiAgICAgdmFyIG5vcm1hbHMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgNCk7XG4gKiAgICAgdmFyIGluZGljZXMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgMiwgVWludDE2QXJyYXkpO1xuICpcbiAqICAgICBwb3NpdGlvbnMucHVzaChbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdKTtcbiAqICAgICB0ZXhjb29yZHMucHVzaChbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pO1xuICogICAgIG5vcm1hbHMucHVzaChbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0pO1xuICogICAgIGluZGljZXMucHVzaChbMCwgMSwgMiwgMSwgMiwgM10pO1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gKiAgICAgICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAqICAgICAgICBub3JtYWw6ICAgbm9ybWFscyxcbiAqICAgICAgICBpbmRpY2VzOiAgaW5kaWNlcyxcbiAqICAgICB9O1xuICpcbiAqIEZvciB0aGUgbGFzdCBleGFtcGxlIGl0IGlzIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiAgICAgdmFyIGJ1ZmZlckluZm8gPSB7XG4gKiAgICAgICBhdHRyaWJzOiB7XG4gKiAgICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIGJ1ZmZlcjogZ2wuY3JlYXRlQnVmZmVyKCksIH0sXG4gKiAgICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGJ1ZmZlcjogZ2wuY3JlYXRlQnVmZmVyKCksIH0sXG4gKiAgICAgICAgIG5vcm1hbDogeyBudW1Db21wb25lbnRzOiAzLCBidWZmZXI6IGdsLmNyZWF0ZUJ1ZmZlcigpLCB9LFxuICogICAgICAgfSxcbiAqICAgICAgIGluZGljZXM6IGdsLmNyZWF0ZUJ1ZmZlcigpLFxuICogICAgICAgbnVtRWxlbWVudHM6IDYsXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckluZm8uYXR0cmlicy5wb3NpdGlvbi5idWZmZXIpO1xuICogICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhcnJheXMucG9zaXRpb24sIGdsLlNUQVRJQ19EUkFXKTtcbiAqICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVySW5mby5hdHRyaWJzLnRleGNvb3JkLmJ1ZmZlcik7XG4gKiAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFycmF5cy50ZXhjb29yZCwgZ2wuU1RBVElDX0RSQVcpO1xuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJJbmZvLmF0dHJpYnMubm9ybWFsLmJ1ZmZlcik7XG4gKiAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFycmF5cy5ub3JtYWwsIGdsLlNUQVRJQ19EUkFXKTtcbiAqICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXJJbmZvLmluZGljZXMpO1xuICogICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGFycmF5cy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5c30gYXJyYXlzIFlvdXIgZGF0YVxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBbc3JjQnVmZmVySW5mb10gQW4gZXhpc3RpbmdcbiAqICAgICAgICBidWZmZXIgaW5mbyB0byBzdGFydCBmcm9tLiBXZWJHTEJ1ZmZlcnMgZXRjIHNwZWNpZmllZFxuICogICAgICAgIGluIHRoZSBzcmNCdWZmZXJJbmZvIHdpbGwgYmUgdXNlZCBpbiBhIG5ldyBCdWZmZXJJbmZvXG4gKiAgICAgICAgd2l0aCBhbnkgYXJyYXlzIHNwZWNpZmllZCBvdmVycmlkaW5nIHRoZSBvbmVzIGluXG4gKiAgICAgICAgc3JjQnVmZmVySW5mby5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IEEgQnVmZmVySW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIGFycmF5cywgc3JjQnVmZmVySW5mbykge1xuICBjb25zdCBuZXdBdHRyaWJzID0gY3JlYXRlQXR0cmlic0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gIGNvbnN0IGJ1ZmZlckluZm8gPSBPYmplY3QuYXNzaWduKHt9LCBzcmNCdWZmZXJJbmZvID8gc3JjQnVmZmVySW5mbyA6IHt9KTtcbiAgYnVmZmVySW5mby5hdHRyaWJzID0gT2JqZWN0LmFzc2lnbih7fSwgc3JjQnVmZmVySW5mbyA/IHNyY0J1ZmZlckluZm8uYXR0cmlicyA6IHt9LCBuZXdBdHRyaWJzKTtcbiAgY29uc3QgaW5kaWNlcyA9IGFycmF5cy5pbmRpY2VzO1xuICBpZiAoaW5kaWNlcykge1xuICAgIGNvbnN0IG5ld0luZGljZXMgPSBtYWtlVHlwZWRBcnJheShpbmRpY2VzLCBcImluZGljZXNcIik7XG4gICAgYnVmZmVySW5mby5pbmRpY2VzID0gY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIG5ld0luZGljZXMsIEVMRU1FTlRfQVJSQVlfQlVGRkVSJDIpO1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBuZXdJbmRpY2VzLmxlbmd0aDtcbiAgICBidWZmZXJJbmZvLmVsZW1lbnRUeXBlID0gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheShuZXdJbmRpY2VzKTtcbiAgfSBlbHNlIGlmICghYnVmZmVySW5mby5udW1FbGVtZW50cykge1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBnZXROdW1FbGVtZW50c0Zyb21BdHRyaWJ1dGVzKGdsLCBidWZmZXJJbmZvLmF0dHJpYnMpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlckluZm87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJ1ZmZlciBmcm9tIGFuIGFycmF5LCB0eXBlZCBhcnJheSwgb3IgYXJyYXkgc3BlY1xuICpcbiAqIEdpdmVuIHNvbWV0aGluZyBsaWtlIHRoaXNcbiAqXG4gKiAgICAgWzEsIDIsIDNdLFxuICpcbiAqIG9yXG4gKlxuICogICAgIG5ldyBVaW50MTZBcnJheShbMSwyLDNdKTtcbiAqXG4gKiBvclxuICpcbiAqICAgICB7XG4gKiAgICAgICAgZGF0YTogWzEsIDIsIDNdLFxuICogICAgICAgIHR5cGU6IFVpbnQ4QXJyYXksXG4gKiAgICAgfVxuICpcbiAqIHJldHVybnMgYSBXZWJHTEJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlTcGVjfSBhcnJheSBhbiBhcnJheSwgdHlwZWQgYXJyYXksIG9yIGFycmF5IHNwZWMuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJyYXlOYW1lIG5hbWUgb2YgYXJyYXkuIFVzZWQgdG8gZ3Vlc3MgdGhlIHR5cGUgaWYgdHlwZSBjYW4gbm90IGJlIGRlcml2ZWQgb3RoZXJ3aXNlLlxuICogQHJldHVybiB7V2ViR0xCdWZmZXJ9IGEgV2ViR0xCdWZmZXIgY29udGFpbmluZyB0aGUgZGF0YSBpbiBhcnJheS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckZyb21BcnJheShnbCwgYXJyYXksIGFycmF5TmFtZSkge1xuICBjb25zdCB0eXBlID0gYXJyYXlOYW1lID09PSBcImluZGljZXNcIiA/IEVMRU1FTlRfQVJSQVlfQlVGRkVSJDIgOiBBUlJBWV9CVUZGRVIkMTtcbiAgY29uc3QgdHlwZWRBcnJheSA9IG1ha2VUeXBlZEFycmF5KGFycmF5LCBhcnJheU5hbWUpO1xuICByZXR1cm4gY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGVkQXJyYXksIHR5cGUpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYnVmZmVycyBmcm9tIGFycmF5cyBvciB0eXBlZCBhcnJheXNcbiAqXG4gKiBHaXZlbiBzb21ldGhpbmcgbGlrZSB0aGlzXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgcG9zaXRpb25zOiBbMSwgMiwgM10sXG4gKiAgICAgICAgbm9ybWFsczogWzAsIDAsIDFdLFxuICogICAgIH1cbiAqXG4gKiByZXR1cm5zIHNvbWV0aGluZyBsaWtlXG4gKlxuICogICAgIGJ1ZmZlcnMgPSB7XG4gKiAgICAgICBwb3NpdGlvbnM6IFdlYkdMQnVmZmVyLFxuICogICAgICAgbm9ybWFsczogV2ViR0xCdWZmZXIsXG4gKiAgICAgfVxuICpcbiAqIElmIHRoZSBidWZmZXIgaXMgbmFtZWQgJ2luZGljZXMnIGl0IHdpbGwgYmUgbWFkZSBhbiBFTEVNRU5UX0FSUkFZX0JVRkZFUi5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5c30gYXJyYXlzXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IHJldHVybnMgYW4gb2JqZWN0IHdpdGggb25lIFdlYkdMQnVmZmVyIHBlciBhcnJheVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnVmZmVyc0Zyb21BcnJheXMoZ2wsIGFycmF5cykge1xuICBjb25zdCBidWZmZXJzID0geyB9O1xuICBPYmplY3Qua2V5cyhhcnJheXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgYnVmZmVyc1trZXldID0gY3JlYXRlQnVmZmVyRnJvbUFycmF5KGdsLCBhcnJheXNba2V5XSwga2V5KTtcbiAgfSk7XG5cbiAgLy8gVWdoIVxuICBpZiAoYXJyYXlzLmluZGljZXMpIHtcbiAgICBidWZmZXJzLm51bUVsZW1lbnRzID0gYXJyYXlzLmluZGljZXMubGVuZ3RoO1xuICAgIGJ1ZmZlcnMuZWxlbWVudFR5cGUgPSBnZXRHTFR5cGVGb3JUeXBlZEFycmF5KG1ha2VUeXBlZEFycmF5KGFycmF5cy5pbmRpY2VzKSk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVycy5udW1FbGVtZW50cyA9IGdldE51bUVsZW1lbnRzRnJvbU5vbkluZGV4ZWRBcnJheXMoYXJyYXlzKTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXJzO1xufVxuXG52YXIgYXR0cmlidXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGVBdHRyaWJzRnJvbUFycmF5czogY3JlYXRlQXR0cmlic0Zyb21BcnJheXMsXG4gIGNyZWF0ZUJ1ZmZlcnNGcm9tQXJyYXlzOiBjcmVhdGVCdWZmZXJzRnJvbUFycmF5cyxcbiAgY3JlYXRlQnVmZmVyRnJvbUFycmF5OiBjcmVhdGVCdWZmZXJGcm9tQXJyYXksXG4gIGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5OiBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheSxcbiAgY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXM6IGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzLFxuICBzZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5OiBzZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5LFxuICBzZXRBdHRyaWJ1dGVQcmVmaXg6IHNldEF0dHJpYnV0ZVByZWZpeCxcbiAgc2V0QXR0cmlidXRlRGVmYXVsdHNfOiBzZXREZWZhdWx0cyQyLFxuICBnZXROdW1Db21wb25lbnRzXzogZ2V0TnVtQ29tcG9uZW50cyQxLFxuICBnZXRBcnJheV86IGdldEFycmF5JDFcbn0pO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IGdldEFycmF5ID0gZ2V0QXJyYXkkMTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmNvbnN0IGdldE51bUNvbXBvbmVudHMgPSBnZXROdW1Db21wb25lbnRzJDE7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQHR5cGVkZWYgeyhJbnQ4QXJyYXl8VWludDhBcnJheXxJbnQxNkFycmF5fFVpbnQxNkFycmF5fEludDMyQXJyYXl8VWludDMyQXJyYXl8RmxvYXQzMkFycmF5KX0gVHlwZWRBcnJheVxuICovXG5cbi8qKlxuICogQWRkIGBwdXNoYCB0byBhIHR5cGVkIGFycmF5LiBJdCBqdXN0IGtlZXBzIGEgJ2N1cnNvcidcbiAqIGFuZCBhbGxvd3MgdXNlIHRvIGBwdXNoYCB2YWx1ZXMgaW50byB0aGUgYXJyYXkgc28gd2VcbiAqIGRvbid0IGhhdmUgdG8gbWFudWFsbHkgY29tcHV0ZSBvZmZzZXRzXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHR5cGVkQXJyYXkgVHlwZWRBcnJheSB0byBhdWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQ29tcG9uZW50cyBudW1iZXIgb2YgY29tcG9uZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGF1Z21lbnRUeXBlZEFycmF5KHR5cGVkQXJyYXksIG51bUNvbXBvbmVudHMpIHtcbiAgbGV0IGN1cnNvciA9IDA7XG4gIHR5cGVkQXJyYXkucHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2lpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGFyZ3VtZW50c1tpaV07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSB8fCBpc0FycmF5QnVmZmVyJDEodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGpqID0gMDsgamogPCB2YWx1ZS5sZW5ndGg7ICsramopIHtcbiAgICAgICAgICB0eXBlZEFycmF5W2N1cnNvcisrXSA9IHZhbHVlW2pqXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZWRBcnJheVtjdXJzb3IrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHR5cGVkQXJyYXkucmVzZXQgPSBmdW5jdGlvbihvcHRfaW5kZXgpIHtcbiAgICBjdXJzb3IgPSBvcHRfaW5kZXggfHwgMDtcbiAgfTtcbiAgdHlwZWRBcnJheS5udW1Db21wb25lbnRzID0gbnVtQ29tcG9uZW50cztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGVkQXJyYXksICdudW1FbGVtZW50cycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC8gdGhpcy5udW1Db21wb25lbnRzIHwgMDtcbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHR5cGVkQXJyYXk7XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIHR5cGVkIGFycmF5IHdpdGggYSBgcHVzaGAgZnVuY3Rpb24gYXR0YWNoZWRcbiAqIHNvIHRoYXQgeW91IGNhbiBlYXNpbHkgKnB1c2gqIHZhbHVlcy5cbiAqXG4gKiBgcHVzaGAgY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzLiBJZiBhbiBhcmd1bWVudCBpcyBhbiBhcnJheSBlYWNoIGVsZW1lbnRcbiAqIG9mIHRoZSBhcnJheSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0eXBlZCBhcnJheS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcnJheSA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgMik7ICAvLyBjcmVhdGVzIGEgRmxvYXQzMkFycmF5IHdpdGggNiB2YWx1ZXNcbiAqICAgICBhcnJheS5wdXNoKDEsIDIsIDMpO1xuICogICAgIGFycmF5LnB1c2goWzQsIDUsIDZdKTtcbiAqICAgICAvLyBhcnJheSBub3cgY29udGFpbnMgWzEsIDIsIDMsIDQsIDUsIDZdXG4gKlxuICogQWxzbyBoYXMgYG51bUNvbXBvbmVudHNgIGFuZCBgbnVtRWxlbWVudHNgIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bUNvbXBvbmVudHMgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1FbGVtZW50cyBudW1iZXIgb2YgZWxlbWVudHMuIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBhcnJheSB3aWxsIGJlIGBudW1Db21wb25lbnRzICogbnVtRWxlbWVudHNgLlxuICogQHBhcmFtIHtjb25zdHJ1Y3Rvcn0gb3B0X3R5cGUgQSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuIERlZmF1bHQgPSBgRmxvYXQzMkFycmF5YC5cbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyVmlld30gQSB0eXBlZCBhcnJheS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkobnVtQ29tcG9uZW50cywgbnVtRWxlbWVudHMsIG9wdF90eXBlKSB7XG4gIGNvbnN0IFR5cGUgPSBvcHRfdHlwZSB8fCBGbG9hdDMyQXJyYXk7XG4gIHJldHVybiBhdWdtZW50VHlwZWRBcnJheShuZXcgVHlwZShudW1Db21wb25lbnRzICogbnVtRWxlbWVudHMpLCBudW1Db21wb25lbnRzKTtcbn1cblxuZnVuY3Rpb24gYWxsQnV0SW5kaWNlcyhuYW1lKSB7XG4gIHJldHVybiBuYW1lICE9PSBcImluZGljZXNcIjtcbn1cblxuLyoqXG4gKiBHaXZlbiBpbmRleGVkIHZlcnRpY2VzIGNyZWF0ZXMgYSBuZXcgc2V0IG9mIHZlcnRpY2VzIHVuLWluZGV4ZWQgYnkgZXhwYW5kaW5nIHRoZSBpbmRleGVkIHZlcnRpY2VzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IHZlcnRpY2VzIFRoZSBpbmRleGVkIHZlcnRpY2VzIHRvIGRlaW5kZXhcbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGRlaW5kZXhlZCB2ZXJ0aWNlc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuZnVuY3Rpb24gZGVpbmRleFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIGNvbnN0IGluZGljZXMgPSB2ZXJ0aWNlcy5pbmRpY2VzO1xuICBjb25zdCBuZXdWZXJ0aWNlcyA9IHt9O1xuICBjb25zdCBudW1FbGVtZW50cyA9IGluZGljZXMubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGV4cGFuZFRvVW5pbmRleGVkKGNoYW5uZWwpIHtcbiAgICBjb25zdCBzcmNCdWZmZXIgPSB2ZXJ0aWNlc1tjaGFubmVsXTtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gc3JjQnVmZmVyLm51bUNvbXBvbmVudHM7XG4gICAgY29uc3QgZHN0QnVmZmVyID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheShudW1Db21wb25lbnRzLCBudW1FbGVtZW50cywgc3JjQnVmZmVyLmNvbnN0cnVjdG9yKTtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbnVtRWxlbWVudHM7ICsraWkpIHtcbiAgICAgIGNvbnN0IG5keCA9IGluZGljZXNbaWldO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbmR4ICogbnVtQ29tcG9uZW50cztcbiAgICAgIGZvciAobGV0IGpqID0gMDsgamogPCBudW1Db21wb25lbnRzOyArK2pqKSB7XG4gICAgICAgIGRzdEJ1ZmZlci5wdXNoKHNyY0J1ZmZlcltvZmZzZXQgKyBqal0pO1xuICAgICAgfVxuICAgIH1cbiAgICBuZXdWZXJ0aWNlc1tjaGFubmVsXSA9IGRzdEJ1ZmZlcjtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHZlcnRpY2VzKS5maWx0ZXIoYWxsQnV0SW5kaWNlcykuZm9yRWFjaChleHBhbmRUb1VuaW5kZXhlZCk7XG5cbiAgcmV0dXJuIG5ld1ZlcnRpY2VzO1xufVxuXG4vKipcbiAqIGZsYXR0ZW5zIHRoZSBub3JtYWxzIG9mIGRlaW5kZXhlZCB2ZXJ0aWNlcyBpbiBwbGFjZS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSB2ZXJ0aWNlcyBUaGUgZGVpbmRleGVkIHZlcnRpY2VzIHdobydzIG5vcm1hbHMgdG8gZmxhdHRlblxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgZmxhdHRlbmVkIHZlcnRpY2VzIChzYW1lIGFzIHdhcyBwYXNzZWQgaW4pXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBmbGF0dGVuTm9ybWFscyh2ZXJ0aWNlcykge1xuICBpZiAodmVydGljZXMuaW5kaWNlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuIG5vdCBmbGF0dGVuIG5vcm1hbHMgb2YgaW5kZXhlZCB2ZXJ0aWNlcy4gZGVpbmRleCB0aGVtIGZpcnN0Jyk7XG4gIH1cblxuICBjb25zdCBub3JtYWxzID0gdmVydGljZXMubm9ybWFsO1xuICBjb25zdCBudW1Ob3JtYWxzID0gbm9ybWFscy5sZW5ndGg7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBudW1Ob3JtYWxzOyBpaSArPSA5KSB7XG4gICAgLy8gcHVsbCBvdXQgdGhlIDMgbm9ybWFscyBmb3IgdGhpcyB0cmlhbmdsZVxuICAgIGNvbnN0IG5heCA9IG5vcm1hbHNbaWkgKyAwXTtcbiAgICBjb25zdCBuYXkgPSBub3JtYWxzW2lpICsgMV07XG4gICAgY29uc3QgbmF6ID0gbm9ybWFsc1tpaSArIDJdO1xuXG4gICAgY29uc3QgbmJ4ID0gbm9ybWFsc1tpaSArIDNdO1xuICAgIGNvbnN0IG5ieSA9IG5vcm1hbHNbaWkgKyA0XTtcbiAgICBjb25zdCBuYnogPSBub3JtYWxzW2lpICsgNV07XG5cbiAgICBjb25zdCBuY3ggPSBub3JtYWxzW2lpICsgNl07XG4gICAgY29uc3QgbmN5ID0gbm9ybWFsc1tpaSArIDddO1xuICAgIGNvbnN0IG5jeiA9IG5vcm1hbHNbaWkgKyA4XTtcblxuICAgIC8vIGFkZCB0aGVtXG4gICAgbGV0IG54ID0gbmF4ICsgbmJ4ICsgbmN4O1xuICAgIGxldCBueSA9IG5heSArIG5ieSArIG5jeTtcbiAgICBsZXQgbnogPSBuYXogKyBuYnogKyBuY3o7XG5cbiAgICAvLyBub3JtYWxpemUgdGhlbVxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChueCAqIG54ICsgbnkgKiBueSArIG56ICogbnopO1xuXG4gICAgbnggLz0gbGVuZ3RoO1xuICAgIG55IC89IGxlbmd0aDtcbiAgICBueiAvPSBsZW5ndGg7XG5cbiAgICAvLyBjb3B5IHRoZW0gYmFjayBpblxuICAgIG5vcm1hbHNbaWkgKyAwXSA9IG54O1xuICAgIG5vcm1hbHNbaWkgKyAxXSA9IG55O1xuICAgIG5vcm1hbHNbaWkgKyAyXSA9IG56O1xuXG4gICAgbm9ybWFsc1tpaSArIDNdID0gbng7XG4gICAgbm9ybWFsc1tpaSArIDRdID0gbnk7XG4gICAgbm9ybWFsc1tpaSArIDVdID0gbno7XG5cbiAgICBub3JtYWxzW2lpICsgNl0gPSBueDtcbiAgICBub3JtYWxzW2lpICsgN10gPSBueTtcbiAgICBub3JtYWxzW2lpICsgOF0gPSBuejtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cblxuZnVuY3Rpb24gYXBwbHlGdW5jVG9WM0FycmF5KGFycmF5LCBtYXRyaXgsIGZuKSB7XG4gIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgY29uc3QgdG1wID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGxlbjsgaWkgKz0gMykge1xuICAgIGZuKG1hdHJpeCwgW2FycmF5W2lpXSwgYXJyYXlbaWkgKyAxXSwgYXJyYXlbaWkgKyAyXV0sIHRtcCk7XG4gICAgYXJyYXlbaWkgICAgXSA9IHRtcFswXTtcbiAgICBhcnJheVtpaSArIDFdID0gdG1wWzFdO1xuICAgIGFycmF5W2lpICsgMl0gPSB0bXBbMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9ybWFsKG1pLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IGNyZWF0ZSQxKCk7XG4gIGNvbnN0IHYwID0gdlswXTtcbiAgY29uc3QgdjEgPSB2WzFdO1xuICBjb25zdCB2MiA9IHZbMl07XG5cbiAgZHN0WzBdID0gdjAgKiBtaVswICogNCArIDBdICsgdjEgKiBtaVswICogNCArIDFdICsgdjIgKiBtaVswICogNCArIDJdO1xuICBkc3RbMV0gPSB2MCAqIG1pWzEgKiA0ICsgMF0gKyB2MSAqIG1pWzEgKiA0ICsgMV0gKyB2MiAqIG1pWzEgKiA0ICsgMl07XG4gIGRzdFsyXSA9IHYwICogbWlbMiAqIDQgKyAwXSArIHYxICogbWlbMiAqIDQgKyAxXSArIHYyICogbWlbMiAqIDQgKyAyXTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFJlb3JpZW50cyBkaXJlY3Rpb25zIGJ5IHRoZSBnaXZlbiBtYXRyaXguLlxuICogQHBhcmFtIHsobnVtYmVyW118VHlwZWRBcnJheSl9IGFycmF5IFRoZSBhcnJheS4gQXNzdW1lcyB2YWx1ZSBmbG9hdHMgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG1hdHJpeCBBIG1hdHJpeCB0byBtdWx0aXBseSBieS5cbiAqIEByZXR1cm4geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gdGhlIHNhbWUgYXJyYXkgdGhhdCB3YXMgcGFzc2VkIGluXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiByZW9yaWVudERpcmVjdGlvbnMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG1hdHJpeCwgdHJhbnNmb3JtRGlyZWN0aW9uKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFJlb3JpZW50cyBub3JtYWxzIGJ5IHRoZSBpbnZlcnNlLXRyYW5zcG9zZSBvZiB0aGUgZ2l2ZW5cbiAqIG1hdHJpeC4uXG4gKiBAcGFyYW0geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gYXJyYXkgVGhlIGFycmF5LiBBc3N1bWVzIHZhbHVlIGZsb2F0cyBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbWF0cml4IEEgbWF0cml4IHRvIG11bHRpcGx5IGJ5LlxuICogQHJldHVybiB7KG51bWJlcltdfFR5cGVkQXJyYXkpfSB0aGUgc2FtZSBhcnJheSB0aGF0IHdhcyBwYXNzZWQgaW5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIHJlb3JpZW50Tm9ybWFscyhhcnJheSwgbWF0cml4KSB7XG4gIGFwcGx5RnVuY1RvVjNBcnJheShhcnJheSwgaW52ZXJzZShtYXRyaXgpLCB0cmFuc2Zvcm1Ob3JtYWwpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogUmVvcmllbnRzIHBvc2l0aW9ucyBieSB0aGUgZ2l2ZW4gbWF0cml4LiBJbiBvdGhlciB3b3JkcywgaXRcbiAqIG11bHRpcGxpZXMgZWFjaCB2ZXJ0ZXggYnkgdGhlIGdpdmVuIG1hdHJpeC5cbiAqIEBwYXJhbSB7KG51bWJlcltdfFR5cGVkQXJyYXkpfSBhcnJheSBUaGUgYXJyYXkuIEFzc3VtZXMgdmFsdWUgZmxvYXRzIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtYXRyaXggQSBtYXRyaXggdG8gbXVsdGlwbHkgYnkuXG4gKiBAcmV0dXJuIHsobnVtYmVyW118VHlwZWRBcnJheSl9IHRoZSBzYW1lIGFycmF5IHRoYXQgd2FzIHBhc3NlZCBpblxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuZnVuY3Rpb24gcmVvcmllbnRQb3NpdGlvbnMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG1hdHJpeCwgdHJhbnNmb3JtUG9pbnQpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyhudW1iZXJbXXxUeXBlZEFycmF5KX0gTmF0aXZlQXJyYXlPclR5cGVkQXJyYXlcbiAqL1xuXG4vKipcbiAqIFJlb3JpZW50cyBhcnJheXMgYnkgdGhlIGdpdmVuIG1hdHJpeC4gQXNzdW1lcyBhcnJheXMgaGF2ZVxuICogbmFtZXMgdGhhdCBjb250YWlucyAncG9zJyBjb3VsZCBiZSByZW9yaWVudGVkIGFzIHBvc2l0aW9ucyxcbiAqICdiaW5vcm0nIG9yICd0YW4nIGFzIGRpcmVjdGlvbnMsIGFuZCAnbm9ybScgYXMgbm9ybWFscy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBOYXRpdmVBcnJheU9yVHlwZWRBcnJheT59IGFycmF5cyBUaGUgdmVydGljZXMgdG8gcmVvcmllbnRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbWF0cml4IG1hdHJpeCB0byByZW9yaWVudCBieS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBOYXRpdmVBcnJheU9yVHlwZWRBcnJheT59IHNhbWUgYXJyYXlzIHRoYXQgd2VyZSBwYXNzZWQgaW4uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiByZW9yaWVudFZlcnRpY2VzKGFycmF5cywgbWF0cml4KSB7XG4gIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgY29uc3QgYXJyYXkgPSBhcnJheXNbbmFtZV07XG4gICAgaWYgKG5hbWUuaW5kZXhPZihcInBvc1wiKSA+PSAwKSB7XG4gICAgICByZW9yaWVudFBvc2l0aW9ucyhhcnJheSwgbWF0cml4KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcInRhblwiKSA+PSAwIHx8IG5hbWUuaW5kZXhPZihcImJpbm9ybVwiKSA+PSAwKSB7XG4gICAgICByZW9yaWVudERpcmVjdGlvbnMoYXJyYXksIG1hdHJpeCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmluZGV4T2YoXCJub3JtXCIpID49IDApIHtcbiAgICAgIHJlb3JpZW50Tm9ybWFscyhhcnJheSwgbWF0cml4KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXJyYXlzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgWFkgcXVhZCBCdWZmZXJJbmZvXG4gKlxuICogVGhlIGRlZmF1bHQgd2l0aCBubyBwYXJhbWV0ZXJzIHdpbGwgcmV0dXJuIGEgMngyIHF1YWQgd2l0aCB2YWx1ZXMgZnJvbSAtMSB0byArMS5cbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIHdpdGggdGhhdCBnb2VzIGZyb20gMCB0byAxIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkQnVmZmVySW5mbyhnbCwgMSwgMC41LCAwLjUpO1xuICpcbiAqIElmIHlvdSB3YW50IGEgdW5pdCBxdWFkIGNlbnRlcmVkIGFib3ZlIDAsMCB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8oZ2wsIDEsIDAsIDAuNSk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHRoZSBzaXplIGFjcm9zcyB0aGUgcXVhZC4gRGVmYXVsdHMgdG8gMiB3aGljaCBtZWFucyB2ZXJ0aWNlcyB3aWxsIGdvIGZyb20gLTEgdG8gKzFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeE9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWFxuICogQHBhcmFtIHtudW1iZXJ9IFt5T2Zmc2V0XSB0aGUgYW1vdW50IHRvIG9mZnNldCB0aGUgcXVhZCBpbiBZXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSB0aGUgY3JlYXRlZCBYWSBRdWFkIEJ1ZmZlckluZm9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlWFlRdWFkQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWSBxdWFkIEJ1ZmZlcnNcbiAqXG4gKiBUaGUgZGVmYXVsdCB3aXRoIG5vIHBhcmFtZXRlcnMgd2lsbCByZXR1cm4gYSAyeDIgcXVhZCB3aXRoIHZhbHVlcyBmcm9tIC0xIHRvICsxLlxuICogSWYgeW91IHdhbnQgYSB1bml0IHF1YWQgd2l0aCB0aGF0IGdvZXMgZnJvbSAwIHRvIDEgeW91J2QgY2FsbCBpdCB3aXRoXG4gKlxuICogICAgIHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVYWVF1YWRCdWZmZXJJbmZvKGdsLCAxLCAwLjUsIDAuNSk7XG4gKlxuICogSWYgeW91IHdhbnQgYSB1bml0IHF1YWQgY2VudGVyZWQgYWJvdmUgMCwwIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkQnVmZmVySW5mbyhnbCwgMSwgMCwgMC41KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZV0gdGhlIHNpemUgYWNyb3NzIHRoZSBxdWFkLiBEZWZhdWx0cyB0byAyIHdoaWNoIG1lYW5zIHZlcnRpY2VzIHdpbGwgZ28gZnJvbSAtMSB0byArMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4T2Zmc2V0XSB0aGUgYW1vdW50IHRvIG9mZnNldCB0aGUgcXVhZCBpbiBYXG4gKiBAcGFyYW0ge251bWJlcn0gW3lPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFlcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IHRoZSBjcmVhdGVkIFhZIFF1YWQgYnVmZmVyc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVYWVF1YWRCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIFhZIHF1YWQgdmVydGljZXNcbiAqXG4gKiBUaGUgZGVmYXVsdCB3aXRoIG5vIHBhcmFtZXRlcnMgd2lsbCByZXR1cm4gYSAyeDIgcXVhZCB3aXRoIHZhbHVlcyBmcm9tIC0xIHRvICsxLlxuICogSWYgeW91IHdhbnQgYSB1bml0IHF1YWQgd2l0aCB0aGF0IGdvZXMgZnJvbSAwIHRvIDEgeW91J2QgY2FsbCBpdCB3aXRoXG4gKlxuICogICAgIHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVYWVF1YWRWZXJ0aWNlcygxLCAwLjUsIDAuNSk7XG4gKlxuICogSWYgeW91IHdhbnQgYSB1bml0IHF1YWQgY2VudGVyZWQgYWJvdmUgMCwwIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkVmVydGljZXMoMSwgMCwgMC41KTtcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHRoZSBzaXplIGFjcm9zcyB0aGUgcXVhZC4gRGVmYXVsdHMgdG8gMiB3aGljaCBtZWFucyB2ZXJ0aWNlcyB3aWxsIGdvIGZyb20gLTEgdG8gKzFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeE9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWFxuICogQHBhcmFtIHtudW1iZXJ9IFt5T2Zmc2V0XSB0aGUgYW1vdW50IHRvIG9mZnNldCB0aGUgcXVhZCBpbiBZXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IHRoZSBjcmVhdGVkIFhZIFF1YWQgdmVydGljZXNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVhZUXVhZFZlcnRpY2VzKHNpemUsIHhPZmZzZXQsIHlPZmZzZXQpIHtcbiAgc2l6ZSA9IHNpemUgfHwgMjtcbiAgeE9mZnNldCA9IHhPZmZzZXQgfHwgMDtcbiAgeU9mZnNldCA9IHlPZmZzZXQgfHwgMDtcbiAgc2l6ZSAqPSAwLjU7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHtcbiAgICAgIG51bUNvbXBvbmVudHM6IDIsXG4gICAgICBkYXRhOiBbXG4gICAgICAgIHhPZmZzZXQgKyAtMSAqIHNpemUsIHlPZmZzZXQgKyAtMSAqIHNpemUsXG4gICAgICAgIHhPZmZzZXQgKyAgMSAqIHNpemUsIHlPZmZzZXQgKyAtMSAqIHNpemUsXG4gICAgICAgIHhPZmZzZXQgKyAtMSAqIHNpemUsIHlPZmZzZXQgKyAgMSAqIHNpemUsXG4gICAgICAgIHhPZmZzZXQgKyAgMSAqIHNpemUsIHlPZmZzZXQgKyAgMSAqIHNpemUsXG4gICAgICBdLFxuICAgIH0sXG4gICAgbm9ybWFsOiBbXG4gICAgICAwLCAwLCAxLFxuICAgICAgMCwgMCwgMSxcbiAgICAgIDAsIDAsIDEsXG4gICAgICAwLCAwLCAxLFxuICAgIF0sXG4gICAgdGV4Y29vcmQ6IFtcbiAgICAgIDAsIDAsXG4gICAgICAxLCAwLFxuICAgICAgMCwgMSxcbiAgICAgIDEsIDEsXG4gICAgXSxcbiAgICBpbmRpY2VzOiBbIDAsIDEsIDIsIDIsIDEsIDMgXSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIFhaIHBsYW5lIEJ1ZmZlckluZm8uXG4gKlxuICogVGhlIGNyZWF0ZWQgcGxhbmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSBXaWR0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoXSBEZXB0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc1dpZHRoXSBOdW1iZXIgb2Ygc3RlcHMgYWNyb3NzIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3ViZGl2aXNpb25zRGVwdGhdIE51bWJlciBvZiBzdGVwcyBkb3duIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW21hdHJpeF0gQSBtYXRyaXggYnkgd2hpY2ggdG8gbXVsdGlwbHkgYWxsIHRoZSB2ZXJ0aWNlcy5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIHBsYW5lIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVBsYW5lQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWiBwbGFuZSBidWZmZXJzLlxuICpcbiAqIFRoZSBjcmVhdGVkIHBsYW5lIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gRGVwdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNXaWR0aF0gTnVtYmVyIG9mIHN0ZXBzIGFjcm9zcyB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc0RlcHRoXSBOdW1iZXIgb2Ygc3RlcHMgZG93biB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFttYXRyaXhdIEEgbWF0cml4IGJ5IHdoaWNoIHRvIG11bHRpcGx5IGFsbCB0aGUgdmVydGljZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBwbGFuZSBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVQbGFuZUJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgWFogcGxhbmUgdmVydGljZXMuXG4gKlxuICogVGhlIGNyZWF0ZWQgcGxhbmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gRGVwdGggb2YgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNXaWR0aF0gTnVtYmVyIG9mIHN0ZXBzIGFjcm9zcyB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc0RlcHRoXSBOdW1iZXIgb2Ygc3RlcHMgZG93biB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFttYXRyaXhdIEEgbWF0cml4IGJ5IHdoaWNoIHRvIG11bHRpcGx5IGFsbCB0aGUgdmVydGljZXMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHBsYW5lIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGxhbmVWZXJ0aWNlcyhcbiAgICB3aWR0aCxcbiAgICBkZXB0aCxcbiAgICBzdWJkaXZpc2lvbnNXaWR0aCxcbiAgICBzdWJkaXZpc2lvbnNEZXB0aCxcbiAgICBtYXRyaXgpIHtcbiAgd2lkdGggPSB3aWR0aCB8fCAxO1xuICBkZXB0aCA9IGRlcHRoIHx8IDE7XG4gIHN1YmRpdmlzaW9uc1dpZHRoID0gc3ViZGl2aXNpb25zV2lkdGggfHwgMTtcbiAgc3ViZGl2aXNpb25zRGVwdGggPSBzdWJkaXZpc2lvbnNEZXB0aCB8fCAxO1xuICBtYXRyaXggPSBtYXRyaXggfHwgaWRlbnRpdHkoKTtcblxuICBjb25zdCBudW1WZXJ0aWNlcyA9IChzdWJkaXZpc2lvbnNXaWR0aCArIDEpICogKHN1YmRpdmlzaW9uc0RlcHRoICsgMSk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCBub3JtYWxzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuXG4gIGZvciAobGV0IHogPSAwOyB6IDw9IHN1YmRpdmlzaW9uc0RlcHRoOyB6KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSBzdWJkaXZpc2lvbnNXaWR0aDsgeCsrKSB7XG4gICAgICBjb25zdCB1ID0geCAvIHN1YmRpdmlzaW9uc1dpZHRoO1xuICAgICAgY29uc3QgdiA9IHogLyBzdWJkaXZpc2lvbnNEZXB0aDtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgIHdpZHRoICogdSAtIHdpZHRoICogMC41LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgZGVwdGggKiB2IC0gZGVwdGggKiAwLjUpO1xuICAgICAgbm9ybWFscy5wdXNoKDAsIDEsIDApO1xuICAgICAgdGV4Y29vcmRzLnB1c2godSwgdik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbnVtVmVydHNBY3Jvc3MgPSBzdWJkaXZpc2lvbnNXaWR0aCArIDE7XG4gIGNvbnN0IGluZGljZXMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KFxuICAgICAgMywgc3ViZGl2aXNpb25zV2lkdGggKiBzdWJkaXZpc2lvbnNEZXB0aCAqIDIsIFVpbnQxNkFycmF5KTtcblxuICBmb3IgKGxldCB6ID0gMDsgeiA8IHN1YmRpdmlzaW9uc0RlcHRoOyB6KyspIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHN1YmRpdmlzaW9uc1dpZHRoOyB4KyspIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMSBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKFxuICAgICAgICAgICh6ICsgMCkgKiBudW1WZXJ0c0Fjcm9zcyArIHgsXG4gICAgICAgICAgKHogKyAxKSAqIG51bVZlcnRzQWNyb3NzICsgeCxcbiAgICAgICAgICAoeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyB4ICsgMSk7XG5cbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMiBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKFxuICAgICAgICAgICh6ICsgMSkgKiBudW1WZXJ0c0Fjcm9zcyArIHgsXG4gICAgICAgICAgKHogKyAxKSAqIG51bVZlcnRzQWNyb3NzICsgeCArIDEsXG4gICAgICAgICAgKHogKyAwKSAqIG51bVZlcnRzQWNyb3NzICsgeCArIDEpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFycmF5cyA9IHJlb3JpZW50VmVydGljZXMoe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiBub3JtYWxzLFxuICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gICAgaW5kaWNlczogaW5kaWNlcyxcbiAgfSwgbWF0cml4KTtcbiAgcmV0dXJuIGFycmF5cztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIHNwaGVyZSBCdWZmZXJJbmZvLlxuICpcbiAqIFRoZSBjcmVhdGVkIHNwaGVyZSBoYXMgcG9zaXRpb24sIG5vcm1hbCwgYW5kIHRleGNvb3JkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zQXhpcyBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zSGVpZ2h0IG51bWJlciBvZiB2ZXJ0aWNhbGx5IG9uIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBzdGFydCB0aGVcbiAqICAgICB0b3Agb2YgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMYXRpdHVkZUluUmFkaWFuc10gV2hlcmUgdG8gZW5kIHRoZVxuICogICAgIGJvdHRvbSBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gTWF0aC5QSS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBzdGFydFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfZW5kTG9uZ2l0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBlbmRcbiAqICAgICB3cmFwcGluZyB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMiAqIE1hdGguUEkuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBUaGUgY3JlYXRlZCBzcGhlcmUgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlU3BoZXJlQnVmZmVySW5mb1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBzcGhlcmUgYnVmZmVycy5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGhlcmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHJhZGl1cyBvZiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0F4aXMgbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0hlaWdodCBudW1iZXIgb2YgdmVydGljYWxseSBvbiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnQgdGhlXG4gKiAgICAgdG9wIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnNdIFdoZXJlIHRvIGVuZCB0aGVcbiAqICAgICBib3R0b20gb2YgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IE1hdGguUEkuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zdGFydExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnRcbiAqICAgICB3cmFwcGluZyB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gZW5kXG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDIgKiBNYXRoLlBJLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gVGhlIGNyZWF0ZWQgc3BoZXJlIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVNwaGVyZUJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgc3BoZXJlIHZlcnRpY2VzLlxuICpcbiAqIFRoZSBjcmVhdGVkIHNwaGVyZSBoYXMgcG9zaXRpb24sIG5vcm1hbCwgYW5kIHRleGNvb3JkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHJhZGl1cyBvZiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0F4aXMgbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0hlaWdodCBudW1iZXIgb2YgdmVydGljYWxseSBvbiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnQgdGhlXG4gKiAgICAgdG9wIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnNdIFdoZXJlIHRvIGVuZCB0aGVcbiAqICAgICBib3R0b20gb2YgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IE1hdGguUEkuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zdGFydExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gc3RhcnRcbiAqICAgICB3cmFwcGluZyB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExvbmdpdHVkZUluUmFkaWFuc10gd2hlcmUgdG8gZW5kXG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDIgKiBNYXRoLlBJLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCBzcGhlcmUgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVTcGhlcmVWZXJ0aWNlcyhcbiAgICByYWRpdXMsXG4gICAgc3ViZGl2aXNpb25zQXhpcyxcbiAgICBzdWJkaXZpc2lvbnNIZWlnaHQsXG4gICAgb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnMsXG4gICAgb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zLFxuICAgIG9wdF9zdGFydExvbmdpdHVkZUluUmFkaWFucyxcbiAgICBvcHRfZW5kTG9uZ2l0dWRlSW5SYWRpYW5zKSB7XG4gIGlmIChzdWJkaXZpc2lvbnNBeGlzIDw9IDAgfHwgc3ViZGl2aXNpb25zSGVpZ2h0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YmRpdmlzaW9uQXhpcyBhbmQgc3ViZGl2aXNpb25IZWlnaHQgbXVzdCBiZSA+IDAnKTtcbiAgfVxuXG4gIG9wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zID0gb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnMgfHwgMDtcbiAgb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zID0gb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zIHx8IE1hdGguUEk7XG4gIG9wdF9zdGFydExvbmdpdHVkZUluUmFkaWFucyA9IG9wdF9zdGFydExvbmdpdHVkZUluUmFkaWFucyB8fCAwO1xuICBvcHRfZW5kTG9uZ2l0dWRlSW5SYWRpYW5zID0gb3B0X2VuZExvbmdpdHVkZUluUmFkaWFucyB8fCAoTWF0aC5QSSAqIDIpO1xuXG4gIGNvbnN0IGxhdFJhbmdlID0gb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zIC0gb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnM7XG4gIGNvbnN0IGxvbmdSYW5nZSA9IG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMgLSBvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnM7XG5cbiAgLy8gV2UgYXJlIGdvaW5nIHRvIGdlbmVyYXRlIG91ciBzcGhlcmUgYnkgaXRlcmF0aW5nIHRocm91Z2ggaXRzXG4gIC8vIHNwaGVyaWNhbCBjb29yZGluYXRlcyBhbmQgZ2VuZXJhdGluZyAyIHRyaWFuZ2xlcyBmb3IgZWFjaCBxdWFkIG9uIGFcbiAgLy8gcmluZyBvZiB0aGUgc3BoZXJlLlxuICBjb25zdCBudW1WZXJ0aWNlcyA9IChzdWJkaXZpc2lvbnNBeGlzICsgMSkgKiAoc3ViZGl2aXNpb25zSGVpZ2h0ICsgMSk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCBub3JtYWxzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgY29uc3QgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG5cbiAgLy8gR2VuZXJhdGUgdGhlIGluZGl2aWR1YWwgdmVydGljZXMgaW4gb3VyIHZlcnRleCBidWZmZXIuXG4gIGZvciAobGV0IHkgPSAwOyB5IDw9IHN1YmRpdmlzaW9uc0hlaWdodDsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPD0gc3ViZGl2aXNpb25zQXhpczsgeCsrKSB7XG4gICAgICAvLyBHZW5lcmF0ZSBhIHZlcnRleCBiYXNlZCBvbiBpdHMgc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG4gICAgICBjb25zdCB1ID0geCAvIHN1YmRpdmlzaW9uc0F4aXM7XG4gICAgICBjb25zdCB2ID0geSAvIHN1YmRpdmlzaW9uc0hlaWdodDtcbiAgICAgIGNvbnN0IHRoZXRhID0gbG9uZ1JhbmdlICogdSArIG9wdF9zdGFydExvbmdpdHVkZUluUmFkaWFucztcbiAgICAgIGNvbnN0IHBoaSA9IGxhdFJhbmdlICogdiArIG9wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zO1xuICAgICAgY29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICBjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIGNvbnN0IHNpblBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgICBjb25zdCBjb3NQaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgY29uc3QgdXggPSBjb3NUaGV0YSAqIHNpblBoaTtcbiAgICAgIGNvbnN0IHV5ID0gY29zUGhpO1xuICAgICAgY29uc3QgdXogPSBzaW5UaGV0YSAqIHNpblBoaTtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHJhZGl1cyAqIHV4LCByYWRpdXMgKiB1eSwgcmFkaXVzICogdXopO1xuICAgICAgbm9ybWFscy5wdXNoKHV4LCB1eSwgdXopO1xuICAgICAgdGV4Y29vcmRzLnB1c2goMSAtIHUsIHYpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG51bVZlcnRzQXJvdW5kID0gc3ViZGl2aXNpb25zQXhpcyArIDE7XG4gIGNvbnN0IGluZGljZXMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIHN1YmRpdmlzaW9uc0F4aXMgKiBzdWJkaXZpc2lvbnNIZWlnaHQgKiAyLCBVaW50MTZBcnJheSk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgc3ViZGl2aXNpb25zQXhpczsgeCsrKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzdWJkaXZpc2lvbnNIZWlnaHQ7IHkrKykgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gTWFrZSB0cmlhbmdsZSAxIG9mIHF1YWQuXG4gICAgICBpbmRpY2VzLnB1c2goXG4gICAgICAgICAgKHkgKyAwKSAqIG51bVZlcnRzQXJvdW5kICsgeCxcbiAgICAgICAgICAoeSArIDApICogbnVtVmVydHNBcm91bmQgKyB4ICsgMSxcbiAgICAgICAgICAoeSArIDEpICogbnVtVmVydHNBcm91bmQgKyB4KTtcblxuICAgICAgLy8gTWFrZSB0cmlhbmdsZSAyIG9mIHF1YWQuXG4gICAgICBpbmRpY2VzLnB1c2goXG4gICAgICAgICAgKHkgKyAxKSAqIG51bVZlcnRzQXJvdW5kICsgeCxcbiAgICAgICAgICAoeSArIDApICogbnVtVmVydHNBcm91bmQgKyB4ICsgMSxcbiAgICAgICAgICAoeSArIDEpICogbnVtVmVydHNBcm91bmQgKyB4ICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXMsXG4gIH07XG59XG5cbi8qKlxuICogQXJyYXkgb2YgdGhlIGluZGljZXMgb2YgY29ybmVycyBvZiBlYWNoIGZhY2Ugb2YgYSBjdWJlLlxuICogQHR5cGUge0FycmF5LjxudW1iZXJbXT59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBDVUJFX0ZBQ0VfSU5ESUNFUyA9IFtcbiAgWzMsIDcsIDUsIDFdLCAgLy8gcmlnaHRcbiAgWzYsIDIsIDAsIDRdLCAgLy8gbGVmdFxuICBbNiwgNywgMywgMl0sICAvLyA/P1xuICBbMCwgMSwgNSwgNF0sICAvLyA/P1xuICBbNywgNiwgNCwgNV0sICAvLyBmcm9udFxuICBbMiwgMywgMSwgMF0sICAvLyBiYWNrXG5dO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBCdWZmZXJJbmZvIGZvciBhIGN1YmUuXG4gKlxuICogVGhlIGN1YmUgaXMgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gKC1zaXplIC8gMiwgc2l6ZSAvIDIpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgY3ViZS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN1YmVCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBidWZmZXJzIGFuZCBpbmRpY2VzIGZvciBhIGN1YmUuXG4gKlxuICogVGhlIGN1YmUgaXMgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gKC1zaXplIC8gMiwgc2l6ZSAvIDIpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB3aWR0aCwgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgY3ViZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN1YmVCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSB2ZXJ0aWNlcyBhbmQgaW5kaWNlcyBmb3IgYSBjdWJlLlxuICpcbiAqIFRoZSBjdWJlIGlzIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4uICgtc2l6ZSAvIDIsIHNpemUgLyAyKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHdpZHRoLCBoZWlnaHQgYW5kIGRlcHRoIG9mIHRoZSBjdWJlLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1YmVWZXJ0aWNlcyhzaXplKSB7XG4gIHNpemUgPSBzaXplIHx8IDE7XG4gIGNvbnN0IGsgPSBzaXplIC8gMjtcblxuICBjb25zdCBjb3JuZXJWZXJ0aWNlcyA9IFtcbiAgICBbLWssIC1rLCAta10sXG4gICAgWytrLCAtaywgLWtdLFxuICAgIFstaywgK2ssIC1rXSxcbiAgICBbK2ssICtrLCAta10sXG4gICAgWy1rLCAtaywgK2tdLFxuICAgIFsraywgLWssICtrXSxcbiAgICBbLWssICtrLCAra10sXG4gICAgWytrLCAraywgK2tdLFxuICBdO1xuXG4gIGNvbnN0IGZhY2VOb3JtYWxzID0gW1xuICAgIFsrMSwgKzAsICswXSxcbiAgICBbLTEsICswLCArMF0sXG4gICAgWyswLCArMSwgKzBdLFxuICAgIFsrMCwgLTEsICswXSxcbiAgICBbKzAsICswLCArMV0sXG4gICAgWyswLCArMCwgLTFdLFxuICBdO1xuXG4gIGNvbnN0IHV2Q29vcmRzID0gW1xuICAgIFsxLCAwXSxcbiAgICBbMCwgMF0sXG4gICAgWzAsIDFdLFxuICAgIFsxLCAxXSxcbiAgXTtcblxuICBjb25zdCBudW1WZXJ0aWNlcyA9IDYgKiA0O1xuICBjb25zdCBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgY29uc3Qgbm9ybWFscyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiAsIG51bVZlcnRpY2VzKTtcbiAgY29uc3QgaW5kaWNlcyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCA2ICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGZvciAobGV0IGYgPSAwOyBmIDwgNjsgKytmKSB7XG4gICAgY29uc3QgZmFjZUluZGljZXMgPSBDVUJFX0ZBQ0VfSU5ESUNFU1tmXTtcbiAgICBmb3IgKGxldCB2ID0gMDsgdiA8IDQ7ICsrdikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBjb3JuZXJWZXJ0aWNlc1tmYWNlSW5kaWNlc1t2XV07XG4gICAgICBjb25zdCBub3JtYWwgPSBmYWNlTm9ybWFsc1tmXTtcbiAgICAgIGNvbnN0IHV2ID0gdXZDb29yZHNbdl07XG5cbiAgICAgIC8vIEVhY2ggZmFjZSBuZWVkcyBhbGwgZm91ciB2ZXJ0aWNlcyBiZWNhdXNlIHRoZSBub3JtYWxzIGFuZCB0ZXh0dXJlXG4gICAgICAvLyBjb29yZGluYXRlcyBhcmUgbm90IGFsbCB0aGUgc2FtZS5cbiAgICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgIG5vcm1hbHMucHVzaChub3JtYWwpO1xuICAgICAgdGV4Y29vcmRzLnB1c2godXYpO1xuXG4gICAgfVxuICAgIC8vIFR3byB0cmlhbmdsZXMgbWFrZSBhIHNxdWFyZSBmYWNlLlxuICAgIGNvbnN0IG9mZnNldCA9IDQgKiBmO1xuICAgIGluZGljZXMucHVzaChvZmZzZXQgKyAwLCBvZmZzZXQgKyAxLCBvZmZzZXQgKyAyKTtcbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0ICsgMCwgb2Zmc2V0ICsgMiwgb2Zmc2V0ICsgMyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiBub3JtYWxzLFxuICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gICAgaW5kaWNlczogaW5kaWNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgQnVmZmVySW5mbyBmb3IgYSB0cnVuY2F0ZWQgY29uZSwgd2hpY2ggaXMgbGlrZSBhIGN5bGluZGVyXG4gKiBleGNlcHQgdGhhdCBpdCBoYXMgZGlmZmVyZW50IHRvcCBhbmQgYm90dG9tIHJhZGlpLiBBIHRydW5jYXRlZCBjb25lXG4gKiBjYW4gYWxzbyBiZSB1c2VkIHRvIGNyZWF0ZSBjeWxpbmRlcnMgYW5kIHJlZ3VsYXIgY29uZXMuIFRoZVxuICogdHJ1bmNhdGVkIGNvbmUgd2lsbCBiZSBjcmVhdGVkIGNlbnRlcmVkIGFib3V0IHRoZSBvcmlnaW4sIHdpdGggdGhlXG4gKiB5IGF4aXMgYXMgaXRzIHZlcnRpY2FsIGF4aXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tUmFkaXVzIEJvdHRvbSByYWRpdXMgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wUmFkaXVzIFRvcCByYWRpdXMgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRfdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRfYm90dG9tQ2FwXSBDcmVhdGUgYm90dG9tIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBUaGUgY3JlYXRlZCBjb25lIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGJ1ZmZlcnMgZm9yIGEgdHJ1bmNhdGVkIGNvbmUsIHdoaWNoIGlzIGxpa2UgYSBjeWxpbmRlclxuICogZXhjZXB0IHRoYXQgaXQgaGFzIGRpZmZlcmVudCB0b3AgYW5kIGJvdHRvbSByYWRpaS4gQSB0cnVuY2F0ZWQgY29uZVxuICogY2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGUgY3lsaW5kZXJzIGFuZCByZWd1bGFyIGNvbmVzLiBUaGVcbiAqIHRydW5jYXRlZCBjb25lIHdpbGwgYmUgY3JlYXRlZCBjZW50ZXJlZCBhYm91dCB0aGUgb3JpZ2luLCB3aXRoIHRoZVxuICogeSBheGlzIGFzIGl0cyB2ZXJ0aWNhbCBheGlzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbVJhZGl1cyBCb3R0b20gcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcFJhZGl1cyBUb3AgcmFkaXVzIG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0X2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gVGhlIGNyZWF0ZWQgY29uZSBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyB2ZXJ0aWNlcyBmb3IgYSB0cnVuY2F0ZWQgY29uZSwgd2hpY2ggaXMgbGlrZSBhIGN5bGluZGVyXG4gKiBleGNlcHQgdGhhdCBpdCBoYXMgZGlmZmVyZW50IHRvcCBhbmQgYm90dG9tIHJhZGlpLiBBIHRydW5jYXRlZCBjb25lXG4gKiBjYW4gYWxzbyBiZSB1c2VkIHRvIGNyZWF0ZSBjeWxpbmRlcnMgYW5kIHJlZ3VsYXIgY29uZXMuIFRoZVxuICogdHJ1bmNhdGVkIGNvbmUgd2lsbCBiZSBjcmVhdGVkIGNlbnRlcmVkIGFib3V0IHRoZSBvcmlnaW4sIHdpdGggdGhlXG4gKiB5IGF4aXMgYXMgaXRzIHZlcnRpY2FsIGF4aXMuIC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tUmFkaXVzIEJvdHRvbSByYWRpdXMgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wUmFkaXVzIFRvcCByYWRpdXMgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRfdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRfYm90dG9tQ2FwXSBDcmVhdGUgYm90dG9tIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIGNvbmUgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMoXG4gICAgYm90dG9tUmFkaXVzLFxuICAgIHRvcFJhZGl1cyxcbiAgICBoZWlnaHQsXG4gICAgcmFkaWFsU3ViZGl2aXNpb25zLFxuICAgIHZlcnRpY2FsU3ViZGl2aXNpb25zLFxuICAgIG9wdF90b3BDYXAsXG4gICAgb3B0X2JvdHRvbUNhcCkge1xuICBpZiAocmFkaWFsU3ViZGl2aXNpb25zIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmFkaWFsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBpZiAodmVydGljYWxTdWJkaXZpc2lvbnMgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBtdXN0IGJlIDEgb3IgZ3JlYXRlcicpO1xuICB9XG5cbiAgY29uc3QgdG9wQ2FwID0gKG9wdF90b3BDYXAgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0X3RvcENhcDtcbiAgY29uc3QgYm90dG9tQ2FwID0gKG9wdF9ib3R0b21DYXAgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0X2JvdHRvbUNhcDtcblxuICBjb25zdCBleHRyYSA9ICh0b3BDYXAgPyAyIDogMCkgKyAoYm90dG9tQ2FwID8gMiA6IDApO1xuXG4gIGNvbnN0IG51bVZlcnRpY2VzID0gKHJhZGlhbFN1YmRpdmlzaW9ucyArIDEpICogKHZlcnRpY2FsU3ViZGl2aXNpb25zICsgMSArIGV4dHJhKTtcbiAgY29uc3QgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IG5vcm1hbHMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTtcbiAgY29uc3QgaW5kaWNlcyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCByYWRpYWxTdWJkaXZpc2lvbnMgKiAodmVydGljYWxTdWJkaXZpc2lvbnMgKyBleHRyYSAvIDIpICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGNvbnN0IHZlcnRzQXJvdW5kRWRnZSA9IHJhZGlhbFN1YmRpdmlzaW9ucyArIDE7XG5cbiAgLy8gVGhlIHNsYW50IG9mIHRoZSBjb25lIGlzIGNvbnN0YW50IGFjcm9zcyBpdHMgc3VyZmFjZVxuICBjb25zdCBzbGFudCA9IE1hdGguYXRhbjIoYm90dG9tUmFkaXVzIC0gdG9wUmFkaXVzLCBoZWlnaHQpO1xuICBjb25zdCBjb3NTbGFudCA9IE1hdGguY29zKHNsYW50KTtcbiAgY29uc3Qgc2luU2xhbnQgPSBNYXRoLnNpbihzbGFudCk7XG5cbiAgY29uc3Qgc3RhcnQgPSB0b3BDYXAgPyAtMiA6IDA7XG4gIGNvbnN0IGVuZCA9IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgKGJvdHRvbUNhcCA/IDIgOiAwKTtcblxuICBmb3IgKGxldCB5eSA9IHN0YXJ0OyB5eSA8PSBlbmQ7ICsreXkpIHtcbiAgICBsZXQgdiA9IHl5IC8gdmVydGljYWxTdWJkaXZpc2lvbnM7XG4gICAgbGV0IHkgPSBoZWlnaHQgKiB2O1xuICAgIGxldCByaW5nUmFkaXVzO1xuICAgIGlmICh5eSA8IDApIHtcbiAgICAgIHkgPSAwO1xuICAgICAgdiA9IDE7XG4gICAgICByaW5nUmFkaXVzID0gYm90dG9tUmFkaXVzO1xuICAgIH0gZWxzZSBpZiAoeXkgPiB2ZXJ0aWNhbFN1YmRpdmlzaW9ucykge1xuICAgICAgeSA9IGhlaWdodDtcbiAgICAgIHYgPSAxO1xuICAgICAgcmluZ1JhZGl1cyA9IHRvcFJhZGl1cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmluZ1JhZGl1cyA9IGJvdHRvbVJhZGl1cyArXG4gICAgICAgICh0b3BSYWRpdXMgLSBib3R0b21SYWRpdXMpICogKHl5IC8gdmVydGljYWxTdWJkaXZpc2lvbnMpO1xuICAgIH1cbiAgICBpZiAoeXkgPT09IC0yIHx8IHl5ID09PSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyArIDIpIHtcbiAgICAgIHJpbmdSYWRpdXMgPSAwO1xuICAgICAgdiA9IDA7XG4gICAgfVxuICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgdmVydHNBcm91bmRFZGdlOyArK2lpKSB7XG4gICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihpaSAqIE1hdGguUEkgKiAyIC8gcmFkaWFsU3ViZGl2aXNpb25zKTtcbiAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGlpICogTWF0aC5QSSAqIDIgLyByYWRpYWxTdWJkaXZpc2lvbnMpO1xuICAgICAgcG9zaXRpb25zLnB1c2goc2luICogcmluZ1JhZGl1cywgeSwgY29zICogcmluZ1JhZGl1cyk7XG4gICAgICBpZiAoeXkgPCAwKSB7XG4gICAgICAgIG5vcm1hbHMucHVzaCgwLCAtMSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHl5ID4gdmVydGljYWxTdWJkaXZpc2lvbnMpIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKDAsIDEsIDApO1xuICAgICAgfSBlbHNlIGlmIChyaW5nUmFkaXVzID09PSAwLjApIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKDAsIDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKHNpbiAqIGNvc1NsYW50LCBzaW5TbGFudCwgY29zICogY29zU2xhbnQpO1xuICAgICAgfVxuICAgICAgdGV4Y29vcmRzLnB1c2goKGlpIC8gcmFkaWFsU3ViZGl2aXNpb25zKSwgMSAtIHYpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IHl5ID0gMDsgeXkgPCB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyArIGV4dHJhOyArK3l5KSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKHl5ID09PSAxICYmIHRvcENhcCB8fCB5eSA9PT0gdmVydGljYWxTdWJkaXZpc2lvbnMgKyBleHRyYSAtIDIgJiYgYm90dG9tQ2FwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHJhZGlhbFN1YmRpdmlzaW9uczsgKytpaSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaW5kaWNlcy5wdXNoKHZlcnRzQXJvdW5kRWRnZSAqICh5eSArIDApICsgMCArIGlpLFxuICAgICAgICAgICAgICAgICAgIHZlcnRzQXJvdW5kRWRnZSAqICh5eSArIDApICsgMSArIGlpLFxuICAgICAgICAgICAgICAgICAgIHZlcnRzQXJvdW5kRWRnZSAqICh5eSArIDEpICsgMSArIGlpKTtcbiAgICAgIGluZGljZXMucHVzaCh2ZXJ0c0Fyb3VuZEVkZ2UgKiAoeXkgKyAwKSArIDAgKyBpaSxcbiAgICAgICAgICAgICAgICAgICB2ZXJ0c0Fyb3VuZEVkZ2UgKiAoeXkgKyAxKSArIDEgKyBpaSxcbiAgICAgICAgICAgICAgICAgICB2ZXJ0c0Fyb3VuZEVkZ2UgKiAoeXkgKyAxKSArIDAgKyBpaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXMsXG4gIH07XG59XG5cbi8qKlxuICogRXhwYW5kcyBSTEUgZGF0YVxuICogQHBhcmFtIHtudW1iZXJbXX0gcmxlRGF0YSBkYXRhIGluIGZvcm1hdCBvZiBydW4tbGVuZ3RoLCB4LCB5LCB6LCBydW4tbGVuZ3RoLCB4LCB5LCB6XG4gKiBAcGFyYW0ge251bWJlcltdfSBbcGFkZGluZ10gdmFsdWUgdG8gYWRkIGVhY2ggZW50cnkgd2l0aC5cbiAqIEByZXR1cm4ge251bWJlcltdfSB0aGUgZXhwYW5kZWQgcmxlRGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXhwYW5kUkxFRGF0YShybGVEYXRhLCBwYWRkaW5nKSB7XG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IFtdO1xuICBjb25zdCBkYXRhID0gW107XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBybGVEYXRhLmxlbmd0aDsgaWkgKz0gNCkge1xuICAgIGNvbnN0IHJ1bkxlbmd0aCA9IHJsZURhdGFbaWldO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBybGVEYXRhLnNsaWNlKGlpICsgMSwgaWkgKyA0KTtcbiAgICBlbGVtZW50LnB1c2guYXBwbHkoZWxlbWVudCwgcGFkZGluZyk7XG4gICAgZm9yIChsZXQgamogPSAwOyBqaiA8IHJ1bkxlbmd0aDsgKytqaikge1xuICAgICAgZGF0YS5wdXNoLmFwcGx5KGRhdGEsIGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIDNEICdGJyBCdWZmZXJJbmZvLlxuICogQW4gJ0YnIGlzIHVzZWZ1bCBiZWNhdXNlIHlvdSBjYW4gZWFzaWx5IHRlbGwgd2hpY2ggd2F5IGl0IGlzIG9yaWVudGVkLlxuICogVGhlIGNyZWF0ZWQgJ0YnIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCB0ZXhjb29yZCwgYW5kIGNvbG9yIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBUaGUgY3JlYXRlZCBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGUzREZCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIDNEICdGJyBidWZmZXJzLlxuICogQW4gJ0YnIGlzIHVzZWZ1bCBiZWNhdXNlIHlvdSBjYW4gZWFzaWx5IHRlbGwgd2hpY2ggd2F5IGl0IGlzIG9yaWVudGVkLlxuICogVGhlIGNyZWF0ZWQgJ0YnIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCB0ZXhjb29yZCwgYW5kIGNvbG9yIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGUzREZCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIDNEICdGJyB2ZXJ0aWNlcy5cbiAqIEFuICdGJyBpcyB1c2VmdWwgYmVjYXVzZSB5b3UgY2FuIGVhc2lseSB0ZWxsIHdoaWNoIHdheSBpdCBpcyBvcmllbnRlZC5cbiAqIFRoZSBjcmVhdGVkICdGJyBoYXMgcG9zaXRpb24sIG5vcm1hbCwgdGV4Y29vcmQsIGFuZCBjb2xvciBhcnJheXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZTNERlZlcnRpY2VzKCkge1xuXG4gIGNvbnN0IHBvc2l0aW9ucyA9IFtcbiAgICAvLyBsZWZ0IGNvbHVtbiBmcm9udFxuICAgIDAsICAgMCwgIDAsXG4gICAgMCwgMTUwLCAgMCxcbiAgICAzMCwgICAwLCAgMCxcbiAgICAwLCAxNTAsICAwLFxuICAgIDMwLCAxNTAsICAwLFxuICAgIDMwLCAgIDAsICAwLFxuXG4gICAgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgICAzMCwgICAwLCAgMCxcbiAgICAzMCwgIDMwLCAgMCxcbiAgICAxMDAsICAgMCwgIDAsXG4gICAgMzAsICAzMCwgIDAsXG4gICAgMTAwLCAgMzAsICAwLFxuICAgIDEwMCwgICAwLCAgMCxcblxuICAgIC8vIG1pZGRsZSBydW5nIGZyb250XG4gICAgMzAsICA2MCwgIDAsXG4gICAgMzAsICA5MCwgIDAsXG4gICAgNjcsICA2MCwgIDAsXG4gICAgMzAsICA5MCwgIDAsXG4gICAgNjcsICA5MCwgIDAsXG4gICAgNjcsICA2MCwgIDAsXG5cbiAgICAvLyBsZWZ0IGNvbHVtbiBiYWNrXG4gICAgICAwLCAgIDAsICAzMCxcbiAgICAgMzAsICAgMCwgIDMwLFxuICAgICAgMCwgMTUwLCAgMzAsXG4gICAgICAwLCAxNTAsICAzMCxcbiAgICAgMzAsICAgMCwgIDMwLFxuICAgICAzMCwgMTUwLCAgMzAsXG5cbiAgICAvLyB0b3AgcnVuZyBiYWNrXG4gICAgIDMwLCAgIDAsICAzMCxcbiAgICAxMDAsICAgMCwgIDMwLFxuICAgICAzMCwgIDMwLCAgMzAsXG4gICAgIDMwLCAgMzAsICAzMCxcbiAgICAxMDAsICAgMCwgIDMwLFxuICAgIDEwMCwgIDMwLCAgMzAsXG5cbiAgICAvLyBtaWRkbGUgcnVuZyBiYWNrXG4gICAgIDMwLCAgNjAsICAzMCxcbiAgICAgNjcsICA2MCwgIDMwLFxuICAgICAzMCwgIDkwLCAgMzAsXG4gICAgIDMwLCAgOTAsICAzMCxcbiAgICAgNjcsICA2MCwgIDMwLFxuICAgICA2NywgIDkwLCAgMzAsXG5cbiAgICAvLyB0b3BcbiAgICAgIDAsICAgMCwgICAwLFxuICAgIDEwMCwgICAwLCAgIDAsXG4gICAgMTAwLCAgIDAsICAzMCxcbiAgICAgIDAsICAgMCwgICAwLFxuICAgIDEwMCwgICAwLCAgMzAsXG4gICAgICAwLCAgIDAsICAzMCxcblxuICAgIC8vIHRvcCBydW5nIGZyb250XG4gICAgMTAwLCAgIDAsICAgMCxcbiAgICAxMDAsICAzMCwgICAwLFxuICAgIDEwMCwgIDMwLCAgMzAsXG4gICAgMTAwLCAgIDAsICAgMCxcbiAgICAxMDAsICAzMCwgIDMwLFxuICAgIDEwMCwgICAwLCAgMzAsXG5cbiAgICAvLyB1bmRlciB0b3AgcnVuZ1xuICAgIDMwLCAgIDMwLCAgIDAsXG4gICAgMzAsICAgMzAsICAzMCxcbiAgICAxMDAsICAzMCwgIDMwLFxuICAgIDMwLCAgIDMwLCAgIDAsXG4gICAgMTAwLCAgMzAsICAzMCxcbiAgICAxMDAsICAzMCwgICAwLFxuXG4gICAgLy8gYmV0d2VlbiB0b3AgcnVuZyBhbmQgbWlkZGxlXG4gICAgMzAsICAgMzAsICAgMCxcbiAgICAzMCwgICA2MCwgIDMwLFxuICAgIDMwLCAgIDMwLCAgMzAsXG4gICAgMzAsICAgMzAsICAgMCxcbiAgICAzMCwgICA2MCwgICAwLFxuICAgIDMwLCAgIDYwLCAgMzAsXG5cbiAgICAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgICAzMCwgICA2MCwgICAwLFxuICAgIDY3LCAgIDYwLCAgMzAsXG4gICAgMzAsICAgNjAsICAzMCxcbiAgICAzMCwgICA2MCwgICAwLFxuICAgIDY3LCAgIDYwLCAgIDAsXG4gICAgNjcsICAgNjAsICAzMCxcblxuICAgIC8vIGZyb250IG9mIG1pZGRsZSBydW5nXG4gICAgNjcsICAgNjAsICAgMCxcbiAgICA2NywgICA5MCwgIDMwLFxuICAgIDY3LCAgIDYwLCAgMzAsXG4gICAgNjcsICAgNjAsICAgMCxcbiAgICA2NywgICA5MCwgICAwLFxuICAgIDY3LCAgIDkwLCAgMzAsXG5cbiAgICAvLyBib3R0b20gb2YgbWlkZGxlIHJ1bmcuXG4gICAgMzAsICAgOTAsICAgMCxcbiAgICAzMCwgICA5MCwgIDMwLFxuICAgIDY3LCAgIDkwLCAgMzAsXG4gICAgMzAsICAgOTAsICAgMCxcbiAgICA2NywgICA5MCwgIDMwLFxuICAgIDY3LCAgIDkwLCAgIDAsXG5cbiAgICAvLyBmcm9udCBvZiBib3R0b21cbiAgICAzMCwgICA5MCwgICAwLFxuICAgIDMwLCAgMTUwLCAgMzAsXG4gICAgMzAsICAgOTAsICAzMCxcbiAgICAzMCwgICA5MCwgICAwLFxuICAgIDMwLCAgMTUwLCAgIDAsXG4gICAgMzAsICAxNTAsICAzMCxcblxuICAgIC8vIGJvdHRvbVxuICAgIDAsICAgMTUwLCAgIDAsXG4gICAgMCwgICAxNTAsICAzMCxcbiAgICAzMCwgIDE1MCwgIDMwLFxuICAgIDAsICAgMTUwLCAgIDAsXG4gICAgMzAsICAxNTAsICAzMCxcbiAgICAzMCwgIDE1MCwgICAwLFxuXG4gICAgLy8gbGVmdCBzaWRlXG4gICAgMCwgICAwLCAgIDAsXG4gICAgMCwgICAwLCAgMzAsXG4gICAgMCwgMTUwLCAgMzAsXG4gICAgMCwgICAwLCAgIDAsXG4gICAgMCwgMTUwLCAgMzAsXG4gICAgMCwgMTUwLCAgIDAsXG4gIF07XG5cbiAgY29uc3QgdGV4Y29vcmRzID0gW1xuICAgIC8vIGxlZnQgY29sdW1uIGZyb250XG4gICAgMC4yMiwgMC4xOSxcbiAgICAwLjIyLCAwLjc5LFxuICAgIDAuMzQsIDAuMTksXG4gICAgMC4yMiwgMC43OSxcbiAgICAwLjM0LCAwLjc5LFxuICAgIDAuMzQsIDAuMTksXG5cbiAgICAvLyB0b3AgcnVuZyBmcm9udFxuICAgIDAuMzQsIDAuMTksXG4gICAgMC4zNCwgMC4zMSxcbiAgICAwLjYyLCAwLjE5LFxuICAgIDAuMzQsIDAuMzEsXG4gICAgMC42MiwgMC4zMSxcbiAgICAwLjYyLCAwLjE5LFxuXG4gICAgLy8gbWlkZGxlIHJ1bmcgZnJvbnRcbiAgICAwLjM0LCAwLjQzLFxuICAgIDAuMzQsIDAuNTUsXG4gICAgMC40OSwgMC40MyxcbiAgICAwLjM0LCAwLjU1LFxuICAgIDAuNDksIDAuNTUsXG4gICAgMC40OSwgMC40MyxcblxuICAgIC8vIGxlZnQgY29sdW1uIGJhY2tcbiAgICAwLCAwLFxuICAgIDEsIDAsXG4gICAgMCwgMSxcbiAgICAwLCAxLFxuICAgIDEsIDAsXG4gICAgMSwgMSxcblxuICAgIC8vIHRvcCBydW5nIGJhY2tcbiAgICAwLCAwLFxuICAgIDEsIDAsXG4gICAgMCwgMSxcbiAgICAwLCAxLFxuICAgIDEsIDAsXG4gICAgMSwgMSxcblxuICAgIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgICAwLCAwLFxuICAgIDEsIDAsXG4gICAgMCwgMSxcbiAgICAwLCAxLFxuICAgIDEsIDAsXG4gICAgMSwgMSxcblxuICAgIC8vIHRvcFxuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuICAgIDAsIDAsXG4gICAgMSwgMSxcbiAgICAwLCAxLFxuXG4gICAgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgICAwLCAwLFxuICAgIDEsIDAsXG4gICAgMSwgMSxcbiAgICAwLCAwLFxuICAgIDEsIDEsXG4gICAgMCwgMSxcblxuICAgIC8vIHVuZGVyIHRvcCBydW5nXG4gICAgMCwgMCxcbiAgICAwLCAxLFxuICAgIDEsIDEsXG4gICAgMCwgMCxcbiAgICAxLCAxLFxuICAgIDEsIDAsXG5cbiAgICAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgICAwLCAwLFxuICAgIDEsIDEsXG4gICAgMCwgMSxcbiAgICAwLCAwLFxuICAgIDEsIDAsXG4gICAgMSwgMSxcblxuICAgIC8vIHRvcCBvZiBtaWRkbGUgcnVuZ1xuICAgIDAsIDAsXG4gICAgMSwgMSxcbiAgICAwLCAxLFxuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuXG4gICAgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgICAwLCAwLFxuICAgIDEsIDEsXG4gICAgMCwgMSxcbiAgICAwLCAwLFxuICAgIDEsIDAsXG4gICAgMSwgMSxcblxuICAgIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgICAwLCAwLFxuICAgIDAsIDEsXG4gICAgMSwgMSxcbiAgICAwLCAwLFxuICAgIDEsIDEsXG4gICAgMSwgMCxcblxuICAgIC8vIGZyb250IG9mIGJvdHRvbVxuICAgIDAsIDAsXG4gICAgMSwgMSxcbiAgICAwLCAxLFxuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuXG4gICAgLy8gYm90dG9tXG4gICAgMCwgMCxcbiAgICAwLCAxLFxuICAgIDEsIDEsXG4gICAgMCwgMCxcbiAgICAxLCAxLFxuICAgIDEsIDAsXG5cbiAgICAvLyBsZWZ0IHNpZGVcbiAgICAwLCAwLFxuICAgIDAsIDEsXG4gICAgMSwgMSxcbiAgICAwLCAwLFxuICAgIDEsIDEsXG4gICAgMSwgMCxcbiAgXTtcblxuICBjb25zdCBub3JtYWxzID0gZXhwYW5kUkxFRGF0YShbXG4gICAgLy8gbGVmdCBjb2x1bW4gZnJvbnRcbiAgICAvLyB0b3AgcnVuZyBmcm9udFxuICAgIC8vIG1pZGRsZSBydW5nIGZyb250XG4gICAgMTgsIDAsIDAsIDEsXG5cbiAgICAvLyBsZWZ0IGNvbHVtbiBiYWNrXG4gICAgLy8gdG9wIHJ1bmcgYmFja1xuICAgIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgICAxOCwgMCwgMCwgLTEsXG5cbiAgICAvLyB0b3BcbiAgICA2LCAwLCAxLCAwLFxuXG4gICAgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgICA2LCAxLCAwLCAwLFxuXG4gICAgLy8gdW5kZXIgdG9wIHJ1bmdcbiAgICA2LCAwLCAtMSwgMCxcblxuICAgIC8vIGJldHdlZW4gdG9wIHJ1bmcgYW5kIG1pZGRsZVxuICAgIDYsIDEsIDAsIDAsXG5cbiAgICAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgICA2LCAwLCAxLCAwLFxuXG4gICAgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgICA2LCAxLCAwLCAwLFxuXG4gICAgLy8gYm90dG9tIG9mIG1pZGRsZSBydW5nLlxuICAgIDYsIDAsIC0xLCAwLFxuXG4gICAgLy8gZnJvbnQgb2YgYm90dG9tXG4gICAgNiwgMSwgMCwgMCxcblxuICAgIC8vIGJvdHRvbVxuICAgIDYsIDAsIC0xLCAwLFxuXG4gICAgLy8gbGVmdCBzaWRlXG4gICAgNiwgLTEsIDAsIDAsXG4gIF0pO1xuXG4gIGNvbnN0IGNvbG9ycyA9IGV4cGFuZFJMRURhdGEoW1xuICAgICAgICAvLyBsZWZ0IGNvbHVtbiBmcm9udFxuICAgICAgICAvLyB0b3AgcnVuZyBmcm9udFxuICAgICAgICAvLyBtaWRkbGUgcnVuZyBmcm9udFxuICAgICAgMTgsIDIwMCwgIDcwLCAxMjAsXG5cbiAgICAgICAgLy8gbGVmdCBjb2x1bW4gYmFja1xuICAgICAgICAvLyB0b3AgcnVuZyBiYWNrXG4gICAgICAgIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgICAgIDE4LCA4MCwgNzAsIDIwMCxcblxuICAgICAgICAvLyB0b3BcbiAgICAgIDYsIDcwLCAyMDAsIDIxMCxcblxuICAgICAgICAvLyB0b3AgcnVuZyBmcm9udFxuICAgICAgNiwgMjAwLCAyMDAsIDcwLFxuXG4gICAgICAgIC8vIHVuZGVyIHRvcCBydW5nXG4gICAgICA2LCAyMTAsIDEwMCwgNzAsXG5cbiAgICAgICAgLy8gYmV0d2VlbiB0b3AgcnVuZyBhbmQgbWlkZGxlXG4gICAgICA2LCAyMTAsIDE2MCwgNzAsXG5cbiAgICAgICAgLy8gdG9wIG9mIG1pZGRsZSBydW5nXG4gICAgICA2LCA3MCwgMTgwLCAyMTAsXG5cbiAgICAgICAgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgICAgIDYsIDEwMCwgNzAsIDIxMCxcblxuICAgICAgICAvLyBib3R0b20gb2YgbWlkZGxlIHJ1bmcuXG4gICAgICA2LCA3NiwgMjEwLCAxMDAsXG5cbiAgICAgICAgLy8gZnJvbnQgb2YgYm90dG9tXG4gICAgICA2LCAxNDAsIDIxMCwgODAsXG5cbiAgICAgICAgLy8gYm90dG9tXG4gICAgICA2LCA5MCwgMTMwLCAxMTAsXG5cbiAgICAgICAgLy8gbGVmdCBzaWRlXG4gICAgICA2LCAxNjAsIDE2MCwgMjIwLFxuICBdLCBbMjU1XSk7XG5cbiAgY29uc3QgbnVtVmVydHMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuICBjb25zdCBhcnJheXMgPSB7XG4gICAgcG9zaXRpb246IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydHMpLFxuICAgIHRleGNvb3JkOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsICBudW1WZXJ0cyksXG4gICAgbm9ybWFsOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRzKSxcbiAgICBjb2xvcjogY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSg0LCBudW1WZXJ0cywgVWludDhBcnJheSksXG4gICAgaW5kaWNlczogY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0cyAvIDMsIFVpbnQxNkFycmF5KSxcbiAgfTtcblxuICBhcnJheXMucG9zaXRpb24ucHVzaChwb3NpdGlvbnMpO1xuICBhcnJheXMudGV4Y29vcmQucHVzaCh0ZXhjb29yZHMpO1xuICBhcnJheXMubm9ybWFsLnB1c2gobm9ybWFscyk7XG4gIGFycmF5cy5jb2xvci5wdXNoKGNvbG9ycyk7XG5cbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG51bVZlcnRzOyArK2lpKSB7XG4gICAgYXJyYXlzLmluZGljZXMucHVzaChpaSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXlzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgY3Jlc2NlbnQgQnVmZmVySW5mby5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFJhZGl1cyBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbm5lclJhZGl1cyBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgVGhlIHRoaWNrbmVzcyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zRG93biBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRPZmZzZXRdIFdoZXJlIHRvIHN0YXJ0IGFyYy4gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRPZmZzZXRdIFdoZXJlIHRvIGVuZCBhcmcuIERlZmF1bHQgMS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGNyZXNjZW50IGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzZW50QnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzY2VudCB2ZXJ0aWNlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzZW50QnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzY2VudCBCdWZmZXJJbmZvLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsUmFkaXVzIFRoZSB2ZXJ0aWNhbCByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG91dGVyUmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyBUaGUgdGhpY2tuZXNzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNEb3duIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGNyZXNjZW50IGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzY2VudEJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgY3Jlc2NlbnQgdmVydGljZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsUmFkaXVzIFRoZSB2ZXJ0aWNhbCByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG91dGVyUmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyBUaGUgdGhpY2tuZXNzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNEb3duIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbiBmdW5jdGlvbiBjcmVhdGVDcmVzY2VudFZlcnRpY2VzKFxuICAgIHZlcnRpY2FsUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzLFxuICAgIGlubmVyUmFkaXVzLFxuICAgIHRoaWNrbmVzcyxcbiAgICBzdWJkaXZpc2lvbnNEb3duLFxuICAgIHN0YXJ0T2Zmc2V0LFxuICAgIGVuZE9mZnNldCkge1xuICBpZiAoc3ViZGl2aXNpb25zRG93biA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJkaXZpc2lvbkRvd24gbXVzdCBiZSA+IDAnKTtcbiAgfVxuXG4gIHN0YXJ0T2Zmc2V0ID0gc3RhcnRPZmZzZXQgfHwgMDtcbiAgZW5kT2Zmc2V0ICAgPSBlbmRPZmZzZXQgfHwgMTtcblxuICBjb25zdCBzdWJkaXZpc2lvbnNUaGljayA9IDI7XG5cbiAgY29uc3Qgb2Zmc2V0UmFuZ2UgPSBlbmRPZmZzZXQgLSBzdGFydE9mZnNldDtcbiAgY29uc3QgbnVtVmVydGljZXMgPSAoc3ViZGl2aXNpb25zRG93biArIDEpICogMiAqICgyICsgc3ViZGl2aXNpb25zVGhpY2spO1xuICBjb25zdCBwb3NpdGlvbnMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCBub3JtYWxzICAgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCB0ZXhjb29yZHMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuXG4gIGZ1bmN0aW9uIGxlcnAoYSwgYiwgcykge1xuICAgIHJldHVybiBhICsgKGIgLSBhKSAqIHM7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcmMoYXJjUmFkaXVzLCB4LCBub3JtYWxNdWx0LCBub3JtYWxBZGQsIHVNdWx0LCB1QWRkKSB7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPD0gc3ViZGl2aXNpb25zRG93bjsgeisrKSB7XG4gICAgICBjb25zdCB1QmFjayA9IHggLyAoc3ViZGl2aXNpb25zVGhpY2sgLSAxKTtcbiAgICAgIGNvbnN0IHYgPSB6IC8gc3ViZGl2aXNpb25zRG93bjtcbiAgICAgIGNvbnN0IHhCYWNrID0gKHVCYWNrIC0gMC41KSAqIDI7XG4gICAgICBjb25zdCBhbmdsZSA9IChzdGFydE9mZnNldCArICh2ICogb2Zmc2V0UmFuZ2UpKSAqIE1hdGguUEk7XG4gICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGxlcnAodmVydGljYWxSYWRpdXMsIGFyY1JhZGl1cywgcyk7XG4gICAgICBjb25zdCBweCA9IHhCYWNrICogdGhpY2tuZXNzO1xuICAgICAgY29uc3QgcHkgPSBjICogdmVydGljYWxSYWRpdXM7XG4gICAgICBjb25zdCBweiA9IHMgKiByYWRpdXM7XG4gICAgICBwb3NpdGlvbnMucHVzaChweCwgcHksIHB6KTtcbiAgICAgIGNvbnN0IG4gPSBhZGQobXVsdGlwbHkkMShbMCwgcywgY10sIG5vcm1hbE11bHQpLCBub3JtYWxBZGQpO1xuICAgICAgbm9ybWFscy5wdXNoKG4pO1xuICAgICAgdGV4Y29vcmRzLnB1c2godUJhY2sgKiB1TXVsdCArIHVBZGQsIHYpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHRoZSBpbmRpdmlkdWFsIHZlcnRpY2VzIGluIG91ciB2ZXJ0ZXggYnVmZmVyLlxuICBmb3IgKGxldCB4ID0gMDsgeCA8IHN1YmRpdmlzaW9uc1RoaWNrOyB4KyspIHtcbiAgICBjb25zdCB1QmFjayA9ICh4IC8gKHN1YmRpdmlzaW9uc1RoaWNrIC0gMSkgLSAwLjUpICogMjtcbiAgICBjcmVhdGVBcmMob3V0ZXJSYWRpdXMsIHgsIFsxLCAxLCAxXSwgWzAsICAgICAwLCAwXSwgMSwgMCk7XG4gICAgY3JlYXRlQXJjKG91dGVyUmFkaXVzLCB4LCBbMCwgMCwgMF0sIFt1QmFjaywgMCwgMF0sIDAsIDApO1xuICAgIGNyZWF0ZUFyYyhpbm5lclJhZGl1cywgeCwgWzEsIDEsIDFdLCBbMCwgICAgIDAsIDBdLCAxLCAwKTtcbiAgICBjcmVhdGVBcmMoaW5uZXJSYWRpdXMsIHgsIFswLCAwLCAwXSwgW3VCYWNrLCAwLCAwXSwgMCwgMSk7XG4gIH1cblxuICAvLyBEbyBvdXRlciBzdXJmYWNlLlxuICBjb25zdCBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCAoc3ViZGl2aXNpb25zRG93biAqIDIpICogKDIgKyBzdWJkaXZpc2lvbnNUaGljayksIFVpbnQxNkFycmF5KTtcblxuICBmdW5jdGlvbiBjcmVhdGVTdXJmYWNlKGxlZnRBcmNPZmZzZXQsIHJpZ2h0QXJjT2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBzdWJkaXZpc2lvbnNEb3duOyArK3opIHtcbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMSBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKFxuICAgICAgICAgIGxlZnRBcmNPZmZzZXQgKyB6ICsgMCxcbiAgICAgICAgICBsZWZ0QXJjT2Zmc2V0ICsgeiArIDEsXG4gICAgICAgICAgcmlnaHRBcmNPZmZzZXQgKyB6ICsgMCk7XG5cbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMiBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKFxuICAgICAgICAgIGxlZnRBcmNPZmZzZXQgKyB6ICsgMSxcbiAgICAgICAgICByaWdodEFyY09mZnNldCArIHogKyAxLFxuICAgICAgICAgIHJpZ2h0QXJjT2Zmc2V0ICsgeiArIDApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG51bVZlcnRpY2VzRG93biA9IHN1YmRpdmlzaW9uc0Rvd24gKyAxO1xuICAvLyBmcm9udFxuICBjcmVhdGVTdXJmYWNlKG51bVZlcnRpY2VzRG93biAqIDAsIG51bVZlcnRpY2VzRG93biAqIDQpO1xuICAvLyByaWdodFxuICBjcmVhdGVTdXJmYWNlKG51bVZlcnRpY2VzRG93biAqIDUsIG51bVZlcnRpY2VzRG93biAqIDcpO1xuICAvLyBiYWNrXG4gIGNyZWF0ZVN1cmZhY2UobnVtVmVydGljZXNEb3duICogNiwgbnVtVmVydGljZXNEb3duICogMik7XG4gIC8vIGxlZnRcbiAgY3JlYXRlU3VyZmFjZShudW1WZXJ0aWNlc0Rvd24gKiAzLCBudW1WZXJ0aWNlc0Rvd24gKiAxKTtcblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiAgIG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiAgaW5kaWNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGN5bGluZGVyIEJ1ZmZlckluZm8uIFRoZSBjeWxpbmRlciB3aWxsIGJlIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW5cbiAqIGFsb25nIHRoZSB5LWF4aXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyQnVmZmVySW5mb1xuICovXG5cbiAvKipcbiAgKiBDcmVhdGVzIGN5bGluZGVyIGJ1ZmZlcnMuIFRoZSBjeWxpbmRlciB3aWxsIGJlIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW5cbiAgKiBhbG9uZyB0aGUgeS1heGlzLlxuICAqXG4gICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY3lsaW5kZXIuXG4gICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgY3lsaW5kZXIuXG4gICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZSBjeWxpbmRlci5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gICogQGZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyQnVmZmVyc1xuICAqL1xuXG4gLyoqXG4gICogQ3JlYXRlcyBjeWxpbmRlciB2ZXJ0aWNlcy4gVGhlIGN5bGluZGVyIHdpbGwgYmUgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpblxuICAqIGFsb25nIHRoZSB5LWF4aXMuXG4gICpcbiAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBjeWxpbmRlci5cbiAgKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgY3lsaW5kZXIuXG4gICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAgKi9cbmZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyVmVydGljZXMoXG4gICAgcmFkaXVzLFxuICAgIGhlaWdodCxcbiAgICByYWRpYWxTdWJkaXZpc2lvbnMsXG4gICAgdmVydGljYWxTdWJkaXZpc2lvbnMsXG4gICAgdG9wQ2FwLFxuICAgIGJvdHRvbUNhcCkge1xuICByZXR1cm4gY3JlYXRlVHJ1bmNhdGVkQ29uZVZlcnRpY2VzKFxuICAgICAgcmFkaXVzLFxuICAgICAgcmFkaXVzLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcmFkaWFsU3ViZGl2aXNpb25zLFxuICAgICAgdmVydGljYWxTdWJkaXZpc2lvbnMsXG4gICAgICB0b3BDYXAsXG4gICAgICBib3R0b21DYXApO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgQnVmZmVySW5mbyBmb3IgYSB0b3J1c1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgY2VudGVyIG9mIHRvcnVzIGNpcmNsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgcmFkaXVzIG9mIHRvcnVzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgdG9ydXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYm9keVN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGJvZHkgdG9ydXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFydEFuZ2xlXSBzdGFydCBhbmdsZSBpbiByYWRpYW5zLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZEFuZ2xlXSBlbmQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IE1hdGguUEkgKiAyLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlVG9ydXNCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGJ1ZmZlcnMgZm9yIGEgdG9ydXNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVRvcnVzQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyB2ZXJ0aWNlcyBmb3IgYSB0b3J1c1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUb3J1c1ZlcnRpY2VzKFxuICAgIHJhZGl1cyxcbiAgICB0aGlja25lc3MsXG4gICAgcmFkaWFsU3ViZGl2aXNpb25zLFxuICAgIGJvZHlTdWJkaXZpc2lvbnMsXG4gICAgc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSkge1xuICBpZiAocmFkaWFsU3ViZGl2aXNpb25zIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmFkaWFsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBpZiAoYm9keVN1YmRpdmlzaW9ucyA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRpY2FsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSB8fCAwO1xuICBlbmRBbmdsZSA9IGVuZEFuZ2xlIHx8IE1hdGguUEkgKiAyO1xuICBjb25zdCByYW5nZSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcblxuICBjb25zdCByYWRpYWxQYXJ0cyA9IHJhZGlhbFN1YmRpdmlzaW9ucyArIDE7XG4gIGNvbnN0IGJvZHlQYXJ0cyAgID0gYm9keVN1YmRpdmlzaW9ucyArIDE7XG4gIGNvbnN0IG51bVZlcnRpY2VzID0gcmFkaWFsUGFydHMgKiBib2R5UGFydHM7XG4gIGNvbnN0IHBvc2l0aW9ucyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IG5vcm1hbHMgICAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IHRleGNvb3JkcyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IGluZGljZXMgICAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCAocmFkaWFsU3ViZGl2aXNpb25zKSAqIChib2R5U3ViZGl2aXNpb25zKSAqIDIsIFVpbnQxNkFycmF5KTtcblxuICBmb3IgKGxldCBzbGljZSA9IDA7IHNsaWNlIDwgYm9keVBhcnRzOyArK3NsaWNlKSB7XG4gICAgY29uc3QgdiA9IHNsaWNlIC8gYm9keVN1YmRpdmlzaW9ucztcbiAgICBjb25zdCBzbGljZUFuZ2xlID0gdiAqIE1hdGguUEkgKiAyO1xuICAgIGNvbnN0IHNsaWNlU2luID0gTWF0aC5zaW4oc2xpY2VBbmdsZSk7XG4gICAgY29uc3QgcmluZ1JhZGl1cyA9IHJhZGl1cyArIHNsaWNlU2luICogdGhpY2tuZXNzO1xuICAgIGNvbnN0IG55ID0gTWF0aC5jb3Moc2xpY2VBbmdsZSk7XG4gICAgY29uc3QgeSA9IG55ICogdGhpY2tuZXNzO1xuICAgIGZvciAobGV0IHJpbmcgPSAwOyByaW5nIDwgcmFkaWFsUGFydHM7ICsrcmluZykge1xuICAgICAgY29uc3QgdSA9IHJpbmcgLyByYWRpYWxTdWJkaXZpc2lvbnM7XG4gICAgICBjb25zdCByaW5nQW5nbGUgPSBzdGFydEFuZ2xlICsgdSAqIHJhbmdlO1xuICAgICAgY29uc3QgeFNpbiA9IE1hdGguc2luKHJpbmdBbmdsZSk7XG4gICAgICBjb25zdCB6Q29zID0gTWF0aC5jb3MocmluZ0FuZ2xlKTtcbiAgICAgIGNvbnN0IHggPSB4U2luICogcmluZ1JhZGl1cztcbiAgICAgIGNvbnN0IHogPSB6Q29zICogcmluZ1JhZGl1cztcbiAgICAgIGNvbnN0IG54ID0geFNpbiAqIHNsaWNlU2luO1xuICAgICAgY29uc3QgbnogPSB6Q29zICogc2xpY2VTaW47XG4gICAgICBwb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgIG5vcm1hbHMucHVzaChueCwgbnksIG56KTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKHUsIDEgLSB2KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBzbGljZSA9IDA7IHNsaWNlIDwgYm9keVN1YmRpdmlzaW9uczsgKytzbGljZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZvciAobGV0IHJpbmcgPSAwOyByaW5nIDwgcmFkaWFsU3ViZGl2aXNpb25zOyArK3JpbmcpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGNvbnN0IG5leHRSaW5nSW5kZXggID0gMSArIHJpbmc7XG4gICAgICBjb25zdCBuZXh0U2xpY2VJbmRleCA9IDEgKyBzbGljZTtcbiAgICAgIGluZGljZXMucHVzaChyYWRpYWxQYXJ0cyAqIHNsaWNlICAgICAgICAgICsgcmluZyxcbiAgICAgICAgICAgICAgICAgICByYWRpYWxQYXJ0cyAqIG5leHRTbGljZUluZGV4ICsgcmluZyxcbiAgICAgICAgICAgICAgICAgICByYWRpYWxQYXJ0cyAqIHNsaWNlICAgICAgICAgICsgbmV4dFJpbmdJbmRleCk7XG4gICAgICBpbmRpY2VzLnB1c2gocmFkaWFsUGFydHMgKiBuZXh0U2xpY2VJbmRleCArIHJpbmcsXG4gICAgICAgICAgICAgICAgICAgcmFkaWFsUGFydHMgKiBuZXh0U2xpY2VJbmRleCArIG5leHRSaW5nSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgcmFkaWFsUGFydHMgKiBzbGljZSAgICAgICAgICArIG5leHRSaW5nSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6ICAgbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6ICBpbmRpY2VzLFxuICB9O1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGRpc2MgQnVmZmVySW5mby4gVGhlIGRpc2Mgd2lsbCBiZSBpbiB0aGUgeHogcGxhbmUsIGNlbnRlcmVkIGF0XG4gKiB0aGUgb3JpZ2luLiBXaGVuIGNyZWF0aW5nLCBhdCBsZWFzdCAzIGRpdmlzaW9ucywgb3IgcGllXG4gKiBwaWVjZXMsIG5lZWQgdG8gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgdGhlIHRyaWFuZ2xlcyBtYWtpbmdcbiAqIHVwIHRoZSBkaXNjIHdpbGwgYmUgZGVnZW5lcmF0ZS4gWW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlXG4gKiBudW1iZXIgb2YgcmFkaWFsIHBpZWNlcyBgc3RhY2tzYC4gQSB2YWx1ZSBvZiAxIGZvclxuICogc3RhY2tzIHdpbGwgZ2l2ZSB5b3UgYSBzaW1wbGUgZGlzYyBvZiBwaWUgcGllY2VzLiAgSWYgeW91XG4gKiB3YW50IHRvIGNyZWF0ZSBhbiBhbm51bHVzIHlvdSBjYW4gc2V0IGBpbm5lclJhZGl1c2AgdG8gYVxuICogdmFsdWUgPiAwLiBGaW5hbGx5LCBgc3RhY2tQb3dlcmAgYWxsb3dzIHlvdSB0byBoYXZlIHRoZSB3aWR0aHNcbiAqIGluY3JlYXNlIG9yIGRlY3JlYXNlIGFzIHlvdSBtb3ZlIGF3YXkgZnJvbSB0aGUgY2VudGVyLiBUaGlzXG4gKiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIGRpc2MgYXMgYSBncm91bmQgcGxhbmVcbiAqIHdpdGggYSBmaXhlZCBjYW1lcmEgc3VjaCB0aGF0IHlvdSBkb24ndCBuZWVkIHRoZSByZXNvbHV0aW9uXG4gKiBvZiBzbWFsbCB0cmlhbmdsZXMgbmVhciB0aGUgcGVyaW1ldGVyLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuICogb2YgMiB3aWxsIHByb2R1Y2Ugc3RhY2tzIHdob3NlIG91dHNpZGUgcmFkaXVzIGluY3JlYXNlcyB3aXRoXG4gKiB0aGUgc3F1YXJlIG9mIHRoZSBzdGFjayBpbmRleC4gQSB2YWx1ZSBvZiAxIHdpbGwgZ2l2ZSB1bmlmb3JtXG4gKiBzdGFja3MuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgZ3JvdW5kIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyBOdW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoZSBncm91bmQgcGxhbmUgKGF0IGxlYXN0IDMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja3NdIE51bWJlciBvZiByYWRpYWwgZGl2aXNpb25zIChkZWZhdWx0PTEpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja1Bvd2VyXSBQb3dlciB0byByYWlzZSBzdGFjayBzaXplIHRvIGZvciBkZWNyZWFzaW5nIHdpZHRoLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlRGlzY0J1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgZGlzYyBidWZmZXJzLiBUaGUgZGlzYyB3aWxsIGJlIGluIHRoZSB4eiBwbGFuZSwgY2VudGVyZWQgYXRcbiAqIHRoZSBvcmlnaW4uIFdoZW4gY3JlYXRpbmcsIGF0IGxlYXN0IDMgZGl2aXNpb25zLCBvciBwaWVcbiAqIHBpZWNlcywgbmVlZCB0byBiZSBzcGVjaWZpZWQsIG90aGVyd2lzZSB0aGUgdHJpYW5nbGVzIG1ha2luZ1xuICogdXAgdGhlIGRpc2Mgd2lsbCBiZSBkZWdlbmVyYXRlLiBZb3UgY2FuIGFsc28gc3BlY2lmeSB0aGVcbiAqIG51bWJlciBvZiByYWRpYWwgcGllY2VzIGBzdGFja3NgLiBBIHZhbHVlIG9mIDEgZm9yXG4gKiBzdGFja3Mgd2lsbCBnaXZlIHlvdSBhIHNpbXBsZSBkaXNjIG9mIHBpZSBwaWVjZXMuICBJZiB5b3VcbiAqIHdhbnQgdG8gY3JlYXRlIGFuIGFubnVsdXMgeW91IGNhbiBzZXQgYGlubmVyUmFkaXVzYCB0byBhXG4gKiB2YWx1ZSA+IDAuIEZpbmFsbHksIGBzdGFja1Bvd2VyYCBhbGxvd3MgeW91IHRvIGhhdmUgdGhlIHdpZHRoc1xuICogaW5jcmVhc2Ugb3IgZGVjcmVhc2UgYXMgeW91IG1vdmUgYXdheSBmcm9tIHRoZSBjZW50ZXIuIFRoaXNcbiAqIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiB1c2luZyB0aGUgZGlzYyBhcyBhIGdyb3VuZCBwbGFuZVxuICogd2l0aCBhIGZpeGVkIGNhbWVyYSBzdWNoIHRoYXQgeW91IGRvbid0IG5lZWQgdGhlIHJlc29sdXRpb25cbiAqIG9mIHNtYWxsIHRyaWFuZ2xlcyBuZWFyIHRoZSBwZXJpbWV0ZXIuIEZvciBleGFtcGxlLCBhIHZhbHVlXG4gKiBvZiAyIHdpbGwgcHJvZHVjZSBzdGFja3Mgd2hvc2Ugb3V0c2lkZSByYWRpdXMgaW5jcmVhc2VzIHdpdGhcbiAqIHRoZSBzcXVhcmUgb2YgdGhlIHN0YWNrIGluZGV4LiBBIHZhbHVlIG9mIDEgd2lsbCBnaXZlIHVuaWZvcm1cbiAqIHN0YWNrcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSBncm91bmQgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gZGl2aXNpb25zIE51bWJlciBvZiB0cmlhbmdsZXMgaW4gdGhlIGdyb3VuZCBwbGFuZSAoYXQgbGVhc3QgMykuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YWNrc10gTnVtYmVyIG9mIHJhZGlhbCBkaXZpc2lvbnMgKGRlZmF1bHQ9MSkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2lubmVyUmFkaXVzXSBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YWNrUG93ZXJdIFBvd2VyIHRvIHJhaXNlIHN0YWNrIHNpemUgdG8gZm9yIGRlY3JlYXNpbmcgd2lkdGguXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVEaXNjQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBkaXNjIHZlcnRpY2VzLiBUaGUgZGlzYyB3aWxsIGJlIGluIHRoZSB4eiBwbGFuZSwgY2VudGVyZWQgYXRcbiAqIHRoZSBvcmlnaW4uIFdoZW4gY3JlYXRpbmcsIGF0IGxlYXN0IDMgZGl2aXNpb25zLCBvciBwaWVcbiAqIHBpZWNlcywgbmVlZCB0byBiZSBzcGVjaWZpZWQsIG90aGVyd2lzZSB0aGUgdHJpYW5nbGVzIG1ha2luZ1xuICogdXAgdGhlIGRpc2Mgd2lsbCBiZSBkZWdlbmVyYXRlLiBZb3UgY2FuIGFsc28gc3BlY2lmeSB0aGVcbiAqIG51bWJlciBvZiByYWRpYWwgcGllY2VzIGBzdGFja3NgLiBBIHZhbHVlIG9mIDEgZm9yXG4gKiBzdGFja3Mgd2lsbCBnaXZlIHlvdSBhIHNpbXBsZSBkaXNjIG9mIHBpZSBwaWVjZXMuICBJZiB5b3VcbiAqIHdhbnQgdG8gY3JlYXRlIGFuIGFubnVsdXMgeW91IGNhbiBzZXQgYGlubmVyUmFkaXVzYCB0byBhXG4gKiB2YWx1ZSA+IDAuIEZpbmFsbHksIGBzdGFja1Bvd2VyYCBhbGxvd3MgeW91IHRvIGhhdmUgdGhlIHdpZHRoc1xuICogaW5jcmVhc2Ugb3IgZGVjcmVhc2UgYXMgeW91IG1vdmUgYXdheSBmcm9tIHRoZSBjZW50ZXIuIFRoaXNcbiAqIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiB1c2luZyB0aGUgZGlzYyBhcyBhIGdyb3VuZCBwbGFuZVxuICogd2l0aCBhIGZpeGVkIGNhbWVyYSBzdWNoIHRoYXQgeW91IGRvbid0IG5lZWQgdGhlIHJlc29sdXRpb25cbiAqIG9mIHNtYWxsIHRyaWFuZ2xlcyBuZWFyIHRoZSBwZXJpbWV0ZXIuIEZvciBleGFtcGxlLCBhIHZhbHVlXG4gKiBvZiAyIHdpbGwgcHJvZHVjZSBzdGFja3Mgd2hvc2Ugb3V0c2lkZSByYWRpdXMgaW5jcmVhc2VzIHdpdGhcbiAqIHRoZSBzcXVhcmUgb2YgdGhlIHN0YWNrIGluZGV4LiBBIHZhbHVlIG9mIDEgd2lsbCBnaXZlIHVuaWZvcm1cbiAqIHN0YWNrcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgZ3JvdW5kIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyBOdW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoZSBncm91bmQgcGxhbmUgKGF0IGxlYXN0IDMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja3NdIE51bWJlciBvZiByYWRpYWwgZGl2aXNpb25zIChkZWZhdWx0PTEpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja1Bvd2VyXSBQb3dlciB0byByYWlzZSBzdGFjayBzaXplIHRvIGZvciBkZWNyZWFzaW5nIHdpZHRoLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2NWZXJ0aWNlcyhcbiAgICByYWRpdXMsXG4gICAgZGl2aXNpb25zLFxuICAgIHN0YWNrcyxcbiAgICBpbm5lclJhZGl1cyxcbiAgICBzdGFja1Bvd2VyKSB7XG4gIGlmIChkaXZpc2lvbnMgPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaXZpc2lvbnMgbXVzdCBiZSBhdCBsZWFzdCAzJyk7XG4gIH1cblxuICBzdGFja3MgPSBzdGFja3MgPyBzdGFja3MgOiAxO1xuICBzdGFja1Bvd2VyID0gc3RhY2tQb3dlciA/IHN0YWNrUG93ZXIgOiAxO1xuICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzID8gaW5uZXJSYWRpdXMgOiAwO1xuXG4gIC8vIE5vdGU6IFdlIGRvbid0IHNoYXJlIHRoZSBjZW50ZXIgdmVydGV4IGJlY2F1c2UgdGhhdCB3b3VsZFxuICAvLyBtZXNzIHVwIHRleHR1cmUgY29vcmRpbmF0ZXMuXG4gIGNvbnN0IG51bVZlcnRpY2VzID0gKGRpdmlzaW9ucyArIDEpICogKHN0YWNrcyArIDEpO1xuXG4gIGNvbnN0IHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCBub3JtYWxzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgY29uc3QgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IGluZGljZXMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgc3RhY2tzICogZGl2aXNpb25zICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGxldCBmaXJzdEluZGV4ID0gMDtcbiAgY29uc3QgcmFkaXVzU3BhbiA9IHJhZGl1cyAtIGlubmVyUmFkaXVzO1xuICBjb25zdCBwb2ludHNQZXJTdGFjayA9IGRpdmlzaW9ucyArIDE7XG5cbiAgLy8gQnVpbGQgdGhlIGRpc2sgb25lIHN0YWNrIGF0IGEgdGltZS5cbiAgZm9yIChsZXQgc3RhY2sgPSAwOyBzdGFjayA8PSBzdGFja3M7ICsrc3RhY2spIHtcbiAgICBjb25zdCBzdGFja1JhZGl1cyA9IGlubmVyUmFkaXVzICsgcmFkaXVzU3BhbiAqIE1hdGgucG93KHN0YWNrIC8gc3RhY2tzLCBzdGFja1Bvd2VyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgKytpKSB7XG4gICAgICBjb25zdCB0aGV0YSA9IDIuMCAqIE1hdGguUEkgKiBpIC8gZGl2aXNpb25zO1xuICAgICAgY29uc3QgeCA9IHN0YWNrUmFkaXVzICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgY29uc3QgeiA9IHN0YWNrUmFkaXVzICogTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICBwb3NpdGlvbnMucHVzaCh4LCAwLCB6KTtcbiAgICAgIG5vcm1hbHMucHVzaCgwLCAxLCAwKTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKDEgLSAoaSAvIGRpdmlzaW9ucyksIHN0YWNrIC8gc3RhY2tzKTtcbiAgICAgIGlmIChzdGFjayA+IDAgJiYgaSAhPT0gZGl2aXNpb25zKSB7XG4gICAgICAgIC8vIGEsIGIsIGMgYW5kIGQgYXJlIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlcyBvZiBhIHF1YWQuICB1bmxlc3NcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgc3RhY2sgaXMgdGhlIG9uZSBjbG9zZXN0IHRvIHRoZSBjZW50ZXIsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgLy8gdGhlIHZlcnRpY2VzIGEgYW5kIGIgY29ubmVjdCB0byB0aGUgY2VudGVyIHZlcnRleC5cbiAgICAgICAgY29uc3QgYSA9IGZpcnN0SW5kZXggKyAoaSArIDEpO1xuICAgICAgICBjb25zdCBiID0gZmlyc3RJbmRleCArIGk7XG4gICAgICAgIGNvbnN0IGMgPSBmaXJzdEluZGV4ICsgaSAtIHBvaW50c1BlclN0YWNrO1xuICAgICAgICBjb25zdCBkID0gZmlyc3RJbmRleCArIChpICsgMSkgLSBwb2ludHNQZXJTdGFjaztcblxuICAgICAgICAvLyBNYWtlIGEgcXVhZCBvZiB0aGUgdmVydGljZXMgYSwgYiwgYywgZC5cbiAgICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGMpO1xuICAgICAgICBpbmRpY2VzLnB1c2goYSwgYywgZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RJbmRleCArPSBkaXZpc2lvbnMgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXMsXG4gIH07XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgcmFuZ2UgLSAxIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZVxuICogQHJldHVybiB7bnVtYmVyfSByYW5kb20gdmFsdWUgYmV0d2VlbiAwIGFuZCByYW5nZSAtIDEgaW5jbHVzaXZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmFuZEludChyYW5nZSkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHJhbmdlIHwgMDtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHN1cHBseSByYW5kb20gY29sb3JzXG4gKiBAY2FsbGJhY2sgUmFuZG9tQ29sb3JGdW5jXG4gKiBAcGFyYW0ge251bWJlcn0gbmR4IGluZGV4IG9mIHRyaWFuZ2xlL3F1YWQgaWYgdW5pbmRleGVkIG9yIGluZGV4IG9mIHZlcnRleCBpZiBpbmRleGVkXG4gKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAwID0gcmVkLCAxID0gZ3JlZW4sIDIgPSBibHVlLCAzID0gYWxwaGFcbiAqIEByZXR1cm4ge251bWJlcn0gYSBudW1iZXIgZnJvbSAwIHRvIDI1NVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJhbmRvbVZlcnRpY2VzT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt2ZXJ0c1BlckNvbG9yXSBEZWZhdWx0cyB0byAzIGZvciBub24taW5kZXhlZCB2ZXJ0aWNlc1xuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC9wcmltaXRpdmVzLlJhbmRvbUNvbG9yRnVuY30gW3JhbmRdIEEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgcmFuZG9tIG51bWJlcnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGF1Z21lbnRlZFR5cGVkQXJyYXkgb2YgcmFuZG9tIHZlcnRleCBjb2xvcnMuXG4gKiBJZiB0aGUgdmVydGljZXMgYXJlIGluZGV4ZWQgKGhhdmUgYW4gaW5kaWNlcyBhcnJheSkgdGhlbiB3aWxsXG4gKiBqdXN0IG1ha2UgcmFuZG9tIGNvbG9ycy4gT3RoZXJ3aXNlIGFzc3VtZXMgdGhleSBhcmUgdHJpYW5nbGVzXG4gKiBhbmQgbWFrZXMgb25lIHJhbmRvbSBjb2xvciBmb3IgZXZlcnkgMyB2ZXJ0aWNlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEF1Z21lbnRlZFR5cGVkQXJyYXk+fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBhcyByZXR1cm5lZCBmcm9tIG9uZSBvZiB0aGUgY3JlYXRlWFhYVmVydGljZXMgZnVuY3Rpb25zLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9wcmltaXRpdmVzLlJhbmRvbVZlcnRpY2VzT3B0aW9uc30gW29wdGlvbnNdIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgQXVnbWVudGVkVHlwZWRBcnJheT59IHNhbWUgdmVydGljZXMgYXMgcGFzc2VkIGluIHdpdGggYGNvbG9yYCBhZGRlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIG1ha2VSYW5kb21WZXJ0ZXhDb2xvcnModmVydGljZXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG51bUVsZW1lbnRzID0gdmVydGljZXMucG9zaXRpb24ubnVtRWxlbWVudHM7XG4gIGNvbnN0IHZDb2xvcnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDQsIG51bUVsZW1lbnRzLCBVaW50OEFycmF5KTtcbiAgY29uc3QgcmFuZCA9IG9wdGlvbnMucmFuZCB8fCBmdW5jdGlvbihuZHgsIGNoYW5uZWwpIHtcbiAgICByZXR1cm4gY2hhbm5lbCA8IDMgPyByYW5kSW50KDI1NikgOiAyNTU7XG4gIH07XG4gIHZlcnRpY2VzLmNvbG9yID0gdkNvbG9ycztcbiAgaWYgKHZlcnRpY2VzLmluZGljZXMpIHtcbiAgICAvLyBqdXN0IG1ha2UgcmFuZG9tIGNvbG9ycyBpZiBpbmRleFxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBudW1FbGVtZW50czsgKytpaSkge1xuICAgICAgdkNvbG9ycy5wdXNoKHJhbmQoaWksIDApLCByYW5kKGlpLCAxKSwgcmFuZChpaSwgMiksIHJhbmQoaWksIDMpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFrZSByYW5kb20gY29sb3JzIHBlciB0cmlhbmdsZVxuICAgIGNvbnN0IG51bVZlcnRzUGVyQ29sb3IgPSBvcHRpb25zLnZlcnRzUGVyQ29sb3IgfHwgMztcbiAgICBjb25zdCBudW1TZXRzID0gbnVtRWxlbWVudHMgLyBudW1WZXJ0c1BlckNvbG9yO1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBudW1TZXRzOyArK2lpKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBjb25zdCBjb2xvciA9IFtyYW5kKGlpLCAwKSwgcmFuZChpaSwgMSksIHJhbmQoaWksIDIpLCByYW5kKGlpLCAzKV07XG4gICAgICBmb3IgKGxldCBqaiA9IDA7IGpqIDwgbnVtVmVydHNQZXJDb2xvcjsgKytqaikge1xuICAgICAgICB2Q29sb3JzLnB1c2goY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmVydGljZXM7XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVycyBmb3IgdGhlbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnVuYyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24oZ2wpIHtcbiAgICBjb25zdCBhcnJheXMgPSBmbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyc0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gIH07XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVySW5mbyBvYmplY3QgZm9yIHRoZW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbihnbCkge1xuICAgIGNvbnN0IGFycmF5cyA9IGZuLmFwcGx5KG51bGwsICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gIH07XG59XG5cbmNvbnN0IGFycmF5U3BlY1Byb3BlcnR5TmFtZXMgPSBbXG4gIFwibnVtQ29tcG9uZW50c1wiLFxuICBcInNpemVcIixcbiAgXCJ0eXBlXCIsXG4gIFwibm9ybWFsaXplXCIsXG4gIFwic3RyaWRlXCIsXG4gIFwib2Zmc2V0XCIsXG4gIFwiYXR0cmliXCIsXG4gIFwibmFtZVwiLFxuICBcImF0dHJpYk5hbWVcIixcbl07XG5cbi8qKlxuICogQ29weSBlbGVtZW50cyBmcm9tIG9uZSBhcnJheSB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzcmMgc291cmNlIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRzdCBkZXN0IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gZHN0TmR4IGluZGV4IGluIGRlc3QgdG8gY29weSBzcmNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgdG8gYWRkIHRvIGNvcGllZCB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvcHlFbGVtZW50cyhzcmMsIGRzdCwgZHN0TmR4LCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGxlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBsZW5ndGg7ICsraWkpIHtcbiAgICBkc3RbZHN0TmR4ICsgaWldID0gc3JjW2lpXSArIG9mZnNldDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIHNhbWUgdGltZVxuICpcbiAqIEBwYXJhbSB7KG51bWJlcltdfEFycmF5QnVmZmVyVmlld3xtb2R1bGU6dHdnbC5GdWxsQXJyYXlTcGVjKX0gc3JjQXJyYXkgYXJyYXkgd2hvJ3MgdHlwZSB0byBjb3B5XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHNpemUgb2YgbmV3IGFycmF5XG4gKiBAcmV0dXJuIHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fG1vZHVsZTp0d2dsLkZ1bGxBcnJheVNwZWMpfSBhcnJheSB3aXRoIHNhbWUgdHlwZSBhcyBzcmNBcnJheVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlNhbWVUeXBlKHNyY0FycmF5LCBsZW5ndGgpIHtcbiAgY29uc3QgYXJyYXlTcmMgPSBnZXRBcnJheShzcmNBcnJheSk7XG4gIGNvbnN0IG5ld0FycmF5ID0gbmV3IGFycmF5U3JjLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG4gIGxldCBuZXdBcnJheVNwZWMgPSBuZXdBcnJheTtcbiAgLy8gSWYgaXQgYXBwZWFycyB0byBoYXZlIGJlZW4gYXVnbWVudGVkIG1ha2UgbmV3IG9uZSBhdWdtZW50ZWRcbiAgaWYgKGFycmF5U3JjLm51bUNvbXBvbmVudHMgJiYgYXJyYXlTcmMubnVtRWxlbWVudHMpIHtcbiAgICBhdWdtZW50VHlwZWRBcnJheShuZXdBcnJheSwgYXJyYXlTcmMubnVtQ29tcG9uZW50cyk7XG4gIH1cbiAgLy8gSWYgaXQgd2FzIGEgZnVsbCBzcGVjIG1ha2UgbmV3IG9uZSBhIGZ1bGwgc3BlY1xuICBpZiAoc3JjQXJyYXkuZGF0YSkge1xuICAgIG5ld0FycmF5U3BlYyA9IHtcbiAgICAgIGRhdGE6IG5ld0FycmF5LFxuICAgIH07XG4gICAgY29weU5hbWVkUHJvcGVydGllcyhhcnJheVNwZWNQcm9wZXJ0eU5hbWVzLCBzcmNBcnJheSwgbmV3QXJyYXlTcGVjKTtcbiAgfVxuICByZXR1cm4gbmV3QXJyYXlTcGVjO1xufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlcyBzZXRzIG9mIHZlcnRpY2VzXG4gKlxuICogQXNzdW1lcyB0aGUgdmVydGljZXMgbWF0Y2ggaW4gY29tcG9zaXRpb24uIEZvciBleGFtcGxlXG4gKiBpZiBvbmUgc2V0IG9mIHZlcnRpY2VzIGhhcyBwb3NpdGlvbnMsIG5vcm1hbHMsIGFuZCBpbmRpY2VzXG4gKiBhbGwgc2V0cyBvZiB2ZXJ0aWNlcyBtdXN0IGhhdmUgcG9zaXRpb25zLCBub3JtYWxzLCBhbmQgaW5kaWNlc1xuICogYW5kIG9mIHRoZSBzYW1lIHR5cGUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIGNvbnN0IGN1YmVWZXJ0aWNlcyA9IHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVDdWJlVmVydGljZXMoMik7XG4gKiAgICAgIGNvbnN0IHNwaGVyZVZlcnRpY2VzID0gdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVNwaGVyZVZlcnRpY2VzKDEsIDEwLCAxMCk7XG4gKiAgICAgIC8vIG1vdmUgdGhlIHNwaGVyZSAyIHVuaXRzIHVwXG4gKiAgICAgIHR3Z2wucHJpbWl0aXZlcy5yZW9yaWVudFZlcnRpY2VzKFxuICogICAgICAgICAgc3BoZXJlVmVydGljZXMsIHR3Z2wubTQudHJhbnNsYXRpb24oWzAsIDIsIDBdKSk7XG4gKiAgICAgIC8vIG1lcmdlIHRoZSBzcGhlcmUgd2l0aCB0aGUgY3ViZVxuICogICAgICBjb25zdCBjdWJlU3BoZXJlVmVydGljZXMgPSB0d2dsLnByaW1pdGl2ZXMuY29uY2F0VmVydGljZXMoXG4gKiAgICAgICAgICBbY3ViZVZlcnRpY2VzLCBzcGhlcmVWZXJ0aWNlc10pO1xuICogICAgICAvLyB0dXJuIHRoZW0gaW50byBXZWJHTCBidWZmZXJzIGFuZCBhdHRyaWIgZGF0YVxuICogICAgICBjb25zdCBidWZmZXJJbmZvID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgY3ViZVNwaGVyZVZlcnRpY2VzKTtcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkFycmF5c1tdfSBhcnJheXMgQXJyYXkgb2YgYXJyYXlzIG9mIHZlcnRpY2VzXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5BcnJheXN9IFRoZSBjb25jYXRlbmF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBjb25jYXRWZXJ0aWNlcyhhcnJheU9mQXJyYXlzKSB7XG4gIGNvbnN0IG5hbWVzID0ge307XG4gIGxldCBiYXNlTmFtZTtcbiAgLy8gZ2V0IG5hbWVzIG9mIGFsbCBhcnJheXMuXG4gIC8vIGFuZCBudW1FbGVtZW50cyBmb3IgZWFjaCBzZXQgb2YgdmVydGljZXNcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGFycmF5T2ZBcnJheXMubGVuZ3RoOyArK2lpKSB7XG4gICAgY29uc3QgYXJyYXlzID0gYXJyYXlPZkFycmF5c1tpaV07XG4gICAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmICghbmFtZXNbbmFtZV0pIHtcbiAgICAgICAgbmFtZXNbbmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghYmFzZU5hbWUgJiYgbmFtZSAhPT0gJ2luZGljZXMnKSB7XG4gICAgICAgIGJhc2VOYW1lID0gbmFtZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFycmF5SW5mbyA9IGFycmF5c1tuYW1lXTtcbiAgICAgIGNvbnN0IG51bUNvbXBvbmVudHMgPSBnZXROdW1Db21wb25lbnRzKGFycmF5SW5mbywgbmFtZSk7XG4gICAgICBjb25zdCBhcnJheSA9IGdldEFycmF5KGFycmF5SW5mbyk7XG4gICAgICBjb25zdCBudW1FbGVtZW50cyA9IGFycmF5Lmxlbmd0aCAvIG51bUNvbXBvbmVudHM7XG4gICAgICBuYW1lc1tuYW1lXS5wdXNoKG51bUVsZW1lbnRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIG9mIGNvbWJpbmVkIGFycmF5XG4gIC8vIGFuZCByZXR1cm4gb25lIGZvciByZWZlcmVuY2VcbiAgZnVuY3Rpb24gZ2V0TGVuZ3RoT2ZDb21iaW5lZEFycmF5cyhuYW1lKSB7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IGFycmF5U3BlYztcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsraWkpIHtcbiAgICAgIGNvbnN0IGFycmF5cyA9IGFycmF5T2ZBcnJheXNbaWldO1xuICAgICAgY29uc3QgYXJyYXlJbmZvID0gYXJyYXlzW25hbWVdO1xuICAgICAgY29uc3QgYXJyYXkgPSBnZXRBcnJheShhcnJheUluZm8pO1xuICAgICAgbGVuZ3RoICs9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghYXJyYXlTcGVjIHx8IGFycmF5SW5mby5kYXRhKSB7XG4gICAgICAgIGFycmF5U3BlYyA9IGFycmF5SW5mbztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgc3BlYzogYXJyYXlTcGVjLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5QXJyYXlzVG9OZXdBcnJheShuYW1lLCBiYXNlLCBuZXdBcnJheSkge1xuICAgIGxldCBiYXNlSW5kZXggPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBhcnJheU9mQXJyYXlzLmxlbmd0aDsgKytpaSkge1xuICAgICAgY29uc3QgYXJyYXlzID0gYXJyYXlPZkFycmF5c1tpaV07XG4gICAgICBjb25zdCBhcnJheUluZm8gPSBhcnJheXNbbmFtZV07XG4gICAgICBjb25zdCBhcnJheSA9IGdldEFycmF5KGFycmF5SW5mbyk7XG4gICAgICBpZiAobmFtZSA9PT0gJ2luZGljZXMnKSB7XG4gICAgICAgIGNvcHlFbGVtZW50cyhhcnJheSwgbmV3QXJyYXksIG9mZnNldCwgYmFzZUluZGV4KTtcbiAgICAgICAgYmFzZUluZGV4ICs9IGJhc2VbaWldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUVsZW1lbnRzKGFycmF5LCBuZXdBcnJheSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYmFzZSA9IG5hbWVzW2Jhc2VOYW1lXTtcblxuICBjb25zdCBuZXdBcnJheXMgPSB7fTtcbiAgT2JqZWN0LmtleXMobmFtZXMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIGNvbnN0IGluZm8gPSBnZXRMZW5ndGhPZkNvbWJpbmVkQXJyYXlzKG5hbWUpO1xuICAgIGNvbnN0IG5ld0FycmF5U3BlYyA9IGNyZWF0ZUFycmF5T2ZTYW1lVHlwZShpbmZvLnNwZWMsIGluZm8ubGVuZ3RoKTtcbiAgICBjb3B5QXJyYXlzVG9OZXdBcnJheShuYW1lLCBiYXNlLCBnZXRBcnJheShuZXdBcnJheVNwZWMpKTtcbiAgICBuZXdBcnJheXNbbmFtZV0gPSBuZXdBcnJheVNwZWM7XG4gIH0pO1xuICByZXR1cm4gbmV3QXJyYXlzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkdXBsaWNhdGUgc2V0IG9mIHZlcnRpY2VzXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhbGxpbmcgcmVvcmllbnRWZXJ0aWNlcyB3aGVuIHlvdVxuICogYWxzbyB3YW50IHRvIGtlZXAgdGhlIG9yaWdpbmFsIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzfSBhcnJheXMgb2YgdmVydGljZXNcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkFycmF5c30gVGhlIGR1cGxpY2F0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBkdXBsaWNhdGVWZXJ0aWNlcyhhcnJheXMpIHtcbiAgY29uc3QgbmV3QXJyYXlzID0ge307XG4gIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgY29uc3QgYXJyYXlTcGVjID0gYXJyYXlzW25hbWVdO1xuICAgIGNvbnN0IHNyY0FycmF5ID0gZ2V0QXJyYXkoYXJyYXlTcGVjKTtcbiAgICBjb25zdCBuZXdBcnJheVNwZWMgPSBjcmVhdGVBcnJheU9mU2FtZVR5cGUoYXJyYXlTcGVjLCBzcmNBcnJheS5sZW5ndGgpO1xuICAgIGNvcHlFbGVtZW50cyhzcmNBcnJheSwgZ2V0QXJyYXkobmV3QXJyYXlTcGVjKSwgMCk7XG4gICAgbmV3QXJyYXlzW25hbWVdID0gbmV3QXJyYXlTcGVjO1xuICB9KTtcbiAgcmV0dXJuIG5ld0FycmF5cztcbn1cblxuY29uc3QgY3JlYXRlM0RGQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZTNERlZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZTNERkJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZTNERlZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZUN1YmVCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlQ3ViZVZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZUN1YmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVDdWJlVmVydGljZXMpO1xuY29uc3QgY3JlYXRlUGxhbmVCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlUGxhbmVWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVQbGFuZUJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVBsYW5lVmVydGljZXMpO1xuY29uc3QgY3JlYXRlU3BoZXJlQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVNwaGVyZVZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVNwaGVyZUJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVNwaGVyZVZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlVHJ1bmNhdGVkQ29uZVZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMpO1xuY29uc3QgY3JlYXRlWFlRdWFkQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVhZUXVhZFZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVhZUXVhZEJ1ZmZlcnMgPSBjcmVhdGVCdWZmZXJGdW5jKGNyZWF0ZVhZUXVhZFZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZUNyZXNjZW50VmVydGljZXMpO1xuY29uc3QgY3JlYXRlQ3Jlc2NlbnRCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVDcmVzY2VudFZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZUN5bGluZGVyQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZUN5bGluZGVyVmVydGljZXMpO1xuY29uc3QgY3JlYXRlQ3lsaW5kZXJCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVDeWxpbmRlclZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVRvcnVzQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVRvcnVzVmVydGljZXMpO1xuY29uc3QgY3JlYXRlVG9ydXNCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVUb3J1c1ZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZURpc2NCdWZmZXJJbmZvID0gY3JlYXRlQnVmZmVySW5mb0Z1bmMoY3JlYXRlRGlzY1ZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZURpc2NCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVEaXNjVmVydGljZXMpO1xuXG4vLyB0aGVzZSB3ZXJlIG1pcy1zcGVsbGVkIHVudGlsIDQuMTJcbmNvbnN0IGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvID0gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvO1xuY29uc3QgY3JlYXRlQ3Jlc2VudEJ1ZmZlcnMgPSBjcmVhdGVDcmVzY2VudEJ1ZmZlcnM7XG5jb25zdCBjcmVhdGVDcmVzZW50VmVydGljZXMgPSBjcmVhdGVDcmVzY2VudFZlcnRpY2VzO1xuXG52YXIgcHJpbWl0aXZlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGUzREZCdWZmZXJJbmZvOiBjcmVhdGUzREZCdWZmZXJJbmZvLFxuICBjcmVhdGUzREZCdWZmZXJzOiBjcmVhdGUzREZCdWZmZXJzLFxuICBjcmVhdGUzREZWZXJ0aWNlczogY3JlYXRlM0RGVmVydGljZXMsXG4gIGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXk6IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXksXG4gIGNyZWF0ZUN1YmVCdWZmZXJJbmZvOiBjcmVhdGVDdWJlQnVmZmVySW5mbyxcbiAgY3JlYXRlQ3ViZUJ1ZmZlcnM6IGNyZWF0ZUN1YmVCdWZmZXJzLFxuICBjcmVhdGVDdWJlVmVydGljZXM6IGNyZWF0ZUN1YmVWZXJ0aWNlcyxcbiAgY3JlYXRlUGxhbmVCdWZmZXJJbmZvOiBjcmVhdGVQbGFuZUJ1ZmZlckluZm8sXG4gIGNyZWF0ZVBsYW5lQnVmZmVyczogY3JlYXRlUGxhbmVCdWZmZXJzLFxuICBjcmVhdGVQbGFuZVZlcnRpY2VzOiBjcmVhdGVQbGFuZVZlcnRpY2VzLFxuICBjcmVhdGVTcGhlcmVCdWZmZXJJbmZvOiBjcmVhdGVTcGhlcmVCdWZmZXJJbmZvLFxuICBjcmVhdGVTcGhlcmVCdWZmZXJzOiBjcmVhdGVTcGhlcmVCdWZmZXJzLFxuICBjcmVhdGVTcGhlcmVWZXJ0aWNlczogY3JlYXRlU3BoZXJlVmVydGljZXMsXG4gIGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJJbmZvOiBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mbyxcbiAgY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlcnM6IGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzLFxuICBjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXM6IGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyxcbiAgY3JlYXRlWFlRdWFkQnVmZmVySW5mbzogY3JlYXRlWFlRdWFkQnVmZmVySW5mbyxcbiAgY3JlYXRlWFlRdWFkQnVmZmVyczogY3JlYXRlWFlRdWFkQnVmZmVycyxcbiAgY3JlYXRlWFlRdWFkVmVydGljZXM6IGNyZWF0ZVhZUXVhZFZlcnRpY2VzLFxuICBjcmVhdGVDcmVzZW50QnVmZmVySW5mbzogY3JlYXRlQ3Jlc2VudEJ1ZmZlckluZm8sXG4gIGNyZWF0ZUNyZXNlbnRCdWZmZXJzOiBjcmVhdGVDcmVzZW50QnVmZmVycyxcbiAgY3JlYXRlQ3Jlc2VudFZlcnRpY2VzOiBjcmVhdGVDcmVzZW50VmVydGljZXMsXG4gIGNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbzogY3JlYXRlQ3Jlc2NlbnRCdWZmZXJJbmZvLFxuICBjcmVhdGVDcmVzY2VudEJ1ZmZlcnM6IGNyZWF0ZUNyZXNjZW50QnVmZmVycyxcbiAgY3JlYXRlQ3Jlc2NlbnRWZXJ0aWNlczogY3JlYXRlQ3Jlc2NlbnRWZXJ0aWNlcyxcbiAgY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvOiBjcmVhdGVDeWxpbmRlckJ1ZmZlckluZm8sXG4gIGNyZWF0ZUN5bGluZGVyQnVmZmVyczogY3JlYXRlQ3lsaW5kZXJCdWZmZXJzLFxuICBjcmVhdGVDeWxpbmRlclZlcnRpY2VzOiBjcmVhdGVDeWxpbmRlclZlcnRpY2VzLFxuICBjcmVhdGVUb3J1c0J1ZmZlckluZm86IGNyZWF0ZVRvcnVzQnVmZmVySW5mbyxcbiAgY3JlYXRlVG9ydXNCdWZmZXJzOiBjcmVhdGVUb3J1c0J1ZmZlcnMsXG4gIGNyZWF0ZVRvcnVzVmVydGljZXM6IGNyZWF0ZVRvcnVzVmVydGljZXMsXG4gIGNyZWF0ZURpc2NCdWZmZXJJbmZvOiBjcmVhdGVEaXNjQnVmZmVySW5mbyxcbiAgY3JlYXRlRGlzY0J1ZmZlcnM6IGNyZWF0ZURpc2NCdWZmZXJzLFxuICBjcmVhdGVEaXNjVmVydGljZXM6IGNyZWF0ZURpc2NWZXJ0aWNlcyxcbiAgZGVpbmRleFZlcnRpY2VzOiBkZWluZGV4VmVydGljZXMsXG4gIGZsYXR0ZW5Ob3JtYWxzOiBmbGF0dGVuTm9ybWFscyxcbiAgbWFrZVJhbmRvbVZlcnRleENvbG9yczogbWFrZVJhbmRvbVZlcnRleENvbG9ycyxcbiAgcmVvcmllbnREaXJlY3Rpb25zOiByZW9yaWVudERpcmVjdGlvbnMsXG4gIHJlb3JpZW50Tm9ybWFsczogcmVvcmllbnROb3JtYWxzLFxuICByZW9yaWVudFBvc2l0aW9uczogcmVvcmllbnRQb3NpdGlvbnMsXG4gIHJlb3JpZW50VmVydGljZXM6IHJlb3JpZW50VmVydGljZXMsXG4gIGNvbmNhdFZlcnRpY2VzOiBjb25jYXRWZXJ0aWNlcyxcbiAgZHVwbGljYXRlVmVydGljZXM6IGR1cGxpY2F0ZVZlcnRpY2VzXG59KTtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIGdsIHZlcnNpb24gYXMgYSBudW1iZXJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHJldHVybiB7bnVtYmVyfSB2ZXJzaW9uIG9mIGdsXG4gKiBAcHJpdmF0ZVxuICovXG4vL2Z1bmN0aW9uIGdldFZlcnNpb25Bc051bWJlcihnbCkge1xuLy8gIHJldHVybiBwYXJzZUZsb2F0KGdsLmdldFBhcmFtZXRlcihnbC5WRVJTSU9OKS5zdWJzdHIoNikpO1xuLy99XG5cbi8qKlxuICogQ2hlY2sgaWYgY29udGV4dCBpcyBXZWJHTCAyLjBcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHJldHVybiB7Ym9vbH0gdHJ1ZSBpZiBpdCdzIFdlYkdMIDIuMFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIGlzV2ViR0wyKGdsKSB7XG4gIC8vIFRoaXMgaXMgdGhlIGNvcnJlY3QgY2hlY2sgYnV0IGl0J3Mgc2xvd1xuICAvLyAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5WRVJTSU9OKS5pbmRleE9mKFwiV2ViR0wgMi4wXCIpID09PSAwO1xuICAvLyBUaGlzIG1pZ2h0IGFsc28gYmUgdGhlIGNvcnJlY3QgY2hlY2sgYnV0IEknbSBhc3N1bWluZyBpdCdzIHNsb3ctaXNoXG4gIC8vIHJldHVybiBnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gIHJldHVybiAhIWdsLnRleFN0b3JhZ2UyRDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBjb250ZXh0IGlzIFdlYkdMIDEuMFxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcmV0dXJuIHtib29sfSB0cnVlIGlmIGl0J3MgV2ViR0wgMS4wXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuZnVuY3Rpb24gaXNXZWJHTDEoZ2wpIHtcbiAgLy8gVGhpcyBpcyB0aGUgY29ycmVjdCBjaGVjayBidXQgaXQncyBzbG93XG4gIC8vIGNvbnN0IHZlcnNpb24gPSBnZXRWZXJzaW9uQXNOdW1iZXIoZ2wpO1xuICAvLyByZXR1cm4gdmVyc2lvbiA8PSAxLjAgJiYgdmVyc2lvbiA+IDAuMDsgIC8vIGJlY2F1c2UgYXMgb2YgMjAxNi81IEVkZ2UgcmV0dXJucyAwLjk2XG4gIC8vIFRoaXMgbWlnaHQgYWxzbyBiZSB0aGUgY29ycmVjdCBjaGVjayBidXQgSSdtIGFzc3VtaW5nIGl0J3Mgc2xvdy1pc2hcbiAgLy8gcmV0dXJuIGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICByZXR1cm4gIWdsLnRleFN0b3JhZ2UyRDtcbn1cblxuLyoqXG4gKiBHZXRzIGEgc3RyaW5nIGZvciBXZWJHTCBlbnVtXG4gKlxuICogTm90ZTogU2V2ZXJhbCBlbnVtcyBhcmUgdGhlIHNhbWUuIFdpdGhvdXQgbW9yZVxuICogY29udGV4dCAod2hpY2ggZnVuY3Rpb24pIGl0J3MgaW1wb3NzaWJsZSB0byBhbHdheXNcbiAqIGdpdmUgdGhlIGNvcnJlY3QgZW51bS4gQXMgaXQgaXMsIGZvciBtYXRjaGluZyB2YWx1ZXNcbiAqIGl0IGdpdmVzIGFsbCBlbnVtcy4gQ2hlY2tpbmcgdGhlIFdlYkdMMlJlbmRlcmluZ0NvbnRleHRcbiAqIHRoYXQgbWVhbnNcbiAqXG4gKiAgICAgIDAgICAgID0gWkVSTyB8IFBPSU5UIHwgTk9ORSB8IE5PX0VSUk9SXG4gKiAgICAgIDEgICAgID0gT05FIHwgTElORVMgfCBTWU5DX0ZMVVNIX0NPTU1BTkRTX0JJVFxuICogICAgICAzMjc3NyA9IEJMRU5EX0VRVUFUSU9OX1JHQiB8IEJMRU5EX0VRVUFUSU9OX1JHQlxuICogICAgICAzNjY2MiA9IENPUFlfUkVBRF9CVUZGRVIgfCBDT1BZX1JFQURfQlVGRkVSX0JJTkRJTkdcbiAqICAgICAgMzY2NjMgPSBDT1BZX1dSSVRFX0JVRkZFUiB8IENPUFlfV1JJVEVfQlVGRkVSX0JJTkRJTkdcbiAqICAgICAgMzYwMDYgPSBGUkFNRUJVRkZFUl9CSU5ESU5HIHwgRFJBV19GUkFNRUJVRkZFUl9CSU5ESU5HXG4gKlxuICogSXQncyBhbHNvIG5vdCB1c2VmdWwgZm9yIGJpdHMgcmVhbGx5IHVubGVzcyB5b3UgcGFzcyBpbiBpbmRpdmlkdWFsIGJpdHMuXG4gKiBJbiBvdGhlciB3b3Jkc1xuICpcbiAqICAgICBjb25zdCBiaXRzID0gZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQ7XG4gKiAgICAgdHdnbC5nbEVudW1Ub1N0cmluZyhnbCwgYml0cyk7ICAvLyBub3QgZ29pbmcgdG8gd29ya1xuICpcbiAqIE5vdGUgdGhhdCBzb21lIGVudW1zIG9ubHkgZXhpc3Qgb24gZXh0ZW5zaW9ucy4gSWYgeW91XG4gKiB3YW50IHRoZW0gdG8gc2hvdyB1cCB5b3UgbmVlZCB0byBwYXNzIHRoZSBleHRlbnNpb24gYXQgbGVhc3RcbiAqIG9uY2UuIEZvciBleGFtcGxlXG4gKlxuICogICAgIGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKTtcbiAqICAgICBpZiAoZXh0KSB7XG4gKiAgICAgICAgdHdnbC5nbEVudW1Ub1N0cmluZyhleHQsIDApOyAgLy8ganVzdCBwcmltZSB0aGUgZnVuY3Rpb25cbiAqXG4gKiAgICAgICAgLi5sYXRlci4uXG4gKlxuICogICAgICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gZXh0LkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XG4gKiAgICAgICAgY29uc29sZS5sb2codHdnbC5nbEVudW1Ub1N0cmluZyhnbCwgaW50ZXJuYWxGb3JtYXQpKTtcbiAqXG4gKiBOb3RpY2UgSSBkaWRuJ3QgaGF2ZSB0byBwYXNzIHRoZSBleHRlbnNpb24gdGhlIHNlY29uZCB0aW1lLiBUaGlzIG1lYW5zXG4gKiB5b3UgY2FuIGhhdmUgcGxhY2UgdGhhdCBnZW5lcmljYWxseSBnZXRzIGFuIGVudW0gZm9yIHRleHR1cmUgZm9ybWF0cyBmb3IgZXhhbXBsZS5cbiAqIGFuZCBhcyBsb25nIGFzIHlvdSBwcmltZWQgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGV4dGVuc2lvbnNcbiAqXG4gKiBJZiB5b3UncmUgdXNpbmcgYHR3Z2wuYWRkRXh0ZW5zaW9uc1RvQ29udGV4dGAgdG8gZW5hYmxlIHlvdXIgZXh0ZW5zaW9uc1xuICogdGhlbiB0d2dsIHdpbGwgYXV0b21hdGljYWxseSBnZXQgdGhlIGV4dGVuc2lvbidzIGVudW1zLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dCBvciBhbnkgZXh0ZW5zaW9uIG9iamVjdFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHRoZSB2YWx1ZSBvZiB0aGUgZW51bSB5b3Ugd2FudCB0byBsb29rIHVwLlxuICogQHJldHVybiB7c3RyaW5nfSBlbnVtIHN0cmluZyBvciBoZXggdmFsdWVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICogQGZ1bmN0aW9uIGdsRW51bVRvU3RyaW5nXG4gKi9cbmNvbnN0IGdsRW51bVRvU3RyaW5nID0gKGZ1bmN0aW9uKCkge1xuICBjb25zdCBoYXZlRW51bXNGb3JUeXBlID0ge307XG4gIGNvbnN0IGVudW1zID0ge307XG5cbiAgZnVuY3Rpb24gYWRkRW51bXMoZ2wpIHtcbiAgICBjb25zdCB0eXBlID0gZ2wuY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAoIWhhdmVFbnVtc0ZvclR5cGVbdHlwZV0pIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGdsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xba2V5XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGVudW1zW2dsW2tleV1dO1xuICAgICAgICAgIGVudW1zW2dsW2tleV1dID0gZXhpc3RpbmcgPyBgJHtleGlzdGluZ30gfCAke2tleX1gIDoga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYXZlRW51bXNGb3JUeXBlW3R5cGVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZ2xFbnVtVG9TdHJpbmcoZ2wsIHZhbHVlKSB7XG4gICAgYWRkRW51bXMoZ2wpO1xuICAgIHJldHVybiBlbnVtc1t2YWx1ZV0gfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBgMHgke3ZhbHVlLnRvU3RyaW5nKDE2KX1gIDogdmFsdWUpO1xuICB9O1xufSgpKTtcblxudmFyIHV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdsRW51bVRvU3RyaW5nOiBnbEVudW1Ub1N0cmluZyxcbiAgaXNXZWJHTDE6IGlzV2ViR0wxLFxuICBpc1dlYkdMMjogaXNXZWJHTDJcbn0pO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5jb25zdCBkZWZhdWx0cyQxID0ge1xuICB0ZXh0dXJlQ29sb3I6IG5ldyBVaW50OEFycmF5KFsxMjgsIDE5MiwgMjU1LCAyNTVdKSxcbiAgdGV4dHVyZU9wdGlvbnM6IHt9LFxuICBjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxufTtcbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyJDE7XG5cbi8vIFNob3VsZCB3ZSBtYWtlIHRoaXMgb24gZGVtYW5kP1xuY29uc3QgZ2V0U2hhcmVkMkRDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGxldCBzX2N0eDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFNoYXJlZDJEQ29udGV4dCgpIHtcbiAgICBzX2N0eCA9IHNfY3R4IHx8XG4gICAgICAgICgodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KVxuICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIilcbiAgICAgICAgICA6IG51bGwpO1xuICAgIHJldHVybiBzX2N0eDtcbiAgfTtcbn0oKTtcblxuLy8gTk9URTogQ2hyb21lIHN1cHBvcnRzIDJEIGNhbnZhcyBpbiBhIFdvcmtlciAoYmVoaW5kIGZsYWcgYXMgb2YgdjY0IGJ1dFxuLy8gICAgICAgbm90IG9ubHkgZG9lcyBGaXJlZm94IE5PVCBzdXBwb3J0IGl0IGJ1dCBGaXJlZm94IGZyZWV6ZXMgaW1tZWRpYXRlbHlcbi8vICAgICAgIGlmIHlvdSB0cnkgdG8gY3JlYXRlIG9uZSBpbnN0ZWFkIG9mIGp1c3QgcmV0dXJuaW5nIG51bGwgYW5kIGNvbnRpbnVpbmcuXG4vLyAgOiAoZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcyAmJiAobmV3IGdsb2JhbC5PZmZzY3JlZW5DYW52YXMoMSwgMSkpLmdldENvbnRleHQoXCIyZFwiKSk7ICAvLyBPZmZzY3JlZW5DYW52YXMgbWF5IG5vdCBzdXBwb3J0IDJkXG5cbi8vIE5PVEU6IFdlIGNhbiBtYXliZSByZW1vdmUgc29tZSBvZiB0aGUgbmVlZCBmb3IgdGhlIDJkIGNhbnZhcy4gSW4gV2ViR0wyXG4vLyB3ZSBjYW4gdXNlIHRoZSB2YXJpb3VzIHVucGFjayBzZXR0aW5ncy4gT3RoZXJ3aXNlIHdlIGNvdWxkIHRyeSB1c2luZ1xuLy8gdGhlIGFiaWxpdHkgb2YgYW4gSW1hZ2VCaXRtYXAgdG8gYmUgY3V0LiBVbmZvcnR1bmF0ZWx5IGN1dHRpbmcgYW4gSW1hZ2VCaXRtYXBcbi8vIGlzIGFzeW5jIGFuZCB0aGUgY3VycmVudCBUV0dMIGNvZGUgZXhwZWN0cyBhIG5vbi1Bc3luYyByZXN1bHQgdGhvdWdoIHRoYXRcbi8vIG1pZ2h0IG5vdCBiZSBhIHByb2JsZW0uIEltYWdlQml0bWFwIHRob3VnaCBpcyBub3QgYXZhaWxhYmxlIGluIEVkZ2Ugb3IgU2FmYXJpXG4vLyBhcyBvZiAyMDE4LTAxLTAyXG5cbi8qIFBpeGVsRm9ybWF0ICovXG5jb25zdCBBTFBIQSAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE5MDY7XG5jb25zdCBSR0IgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE5MDc7XG5jb25zdCBSR0JBJDEgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTkwODtcbmNvbnN0IExVTUlOQU5DRSAgICAgICAgICAgICAgICAgICAgICA9IDB4MTkwOTtcbmNvbnN0IExVTUlOQU5DRV9BTFBIQSAgICAgICAgICAgICAgICA9IDB4MTkwQTtcbmNvbnN0IERFUFRIX0NPTVBPTkVOVCQxICAgICAgICAgICAgICAgID0gMHgxOTAyO1xuY29uc3QgREVQVEhfU1RFTkNJTCQxICAgICAgICAgICAgICAgICAgPSAweDg0Rjk7XG5cbi8qIFRleHR1cmVXcmFwTW9kZSAqL1xuLy8gY29uc3QgUkVQRUFUICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgyOTAxO1xuLy8gY29uc3QgTUlSUk9SRURfUkVQRUFUICAgICAgICAgICAgICAgID0gMHg4MzcwO1xuY29uc3QgQ0xBTVBfVE9fRURHRSQxICAgICAgICAgICAgICAgICAgPSAweDgxMmY7XG5cbi8qIFRleHR1cmVNYWdGaWx0ZXIgKi9cbmNvbnN0IE5FQVJFU1QgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MjYwMDtcbmNvbnN0IExJTkVBUiQxICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgyNjAxO1xuXG4vKiBUZXh0dXJlTWluRmlsdGVyICovXG4vLyBjb25zdCBORUFSRVNUX01JUE1BUF9ORUFSRVNUICAgICAgICAgPSAweDI3MDA7XG4vLyBjb25zdCBMSU5FQVJfTUlQTUFQX05FQVJFU1QgICAgICAgICAgPSAweDI3MDE7XG4vLyBjb25zdCBORUFSRVNUX01JUE1BUF9MSU5FQVIgICAgICAgICAgPSAweDI3MDI7XG4vLyBjb25zdCBMSU5FQVJfTUlQTUFQX0xJTkVBUiAgICAgICAgICAgPSAweDI3MDM7XG5cbi8qIFRleHR1cmUgVGFyZ2V0ICovXG5jb25zdCBURVhUVVJFXzJEJDIgICAgICAgICAgICAgICAgICAgICA9IDB4MGRlMTtcbmNvbnN0IFRFWFRVUkVfQ1VCRV9NQVAkMSAgICAgICAgICAgICAgID0gMHg4NTEzO1xuY29uc3QgVEVYVFVSRV8zRCQxICAgICAgICAgICAgICAgICAgICAgPSAweDgwNmY7XG5jb25zdCBURVhUVVJFXzJEX0FSUkFZJDEgICAgICAgICAgICAgICA9IDB4OGMxYTtcblxuLyogQ3ViZW1hcCBUYXJnZXRzICovXG5jb25zdCBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggICAgPSAweDg1MTU7XG5jb25zdCBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ggICAgPSAweDg1MTY7XG5jb25zdCBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1kgICAgPSAweDg1MTc7XG5jb25zdCBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1kgICAgPSAweDg1MTg7XG5jb25zdCBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ogICAgPSAweDg1MTk7XG5jb25zdCBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ogICAgPSAweDg1MWE7XG5cbi8qIFRleHR1cmUgUGFyYW1ldGVycyAqL1xuY29uc3QgVEVYVFVSRV9NSU5fRklMVEVSICAgICAgICAgICAgID0gMHgyODAxO1xuY29uc3QgVEVYVFVSRV9NQUdfRklMVEVSICAgICAgICAgICAgID0gMHgyODAwO1xuY29uc3QgVEVYVFVSRV9XUkFQX1MgICAgICAgICAgICAgICAgID0gMHgyODAyO1xuY29uc3QgVEVYVFVSRV9XUkFQX1QgICAgICAgICAgICAgICAgID0gMHgyODAzO1xuY29uc3QgVEVYVFVSRV9XUkFQX1IgICAgICAgICAgICAgICAgID0gMHg4MDcyO1xuY29uc3QgVEVYVFVSRV9NSU5fTE9EICAgICAgICAgICAgICAgID0gMHg4MTNhO1xuY29uc3QgVEVYVFVSRV9NQVhfTE9EICAgICAgICAgICAgICAgID0gMHg4MTNiO1xuY29uc3QgVEVYVFVSRV9CQVNFX0xFVkVMICAgICAgICAgICAgID0gMHg4MTNjO1xuY29uc3QgVEVYVFVSRV9NQVhfTEVWRUwgICAgICAgICAgICAgID0gMHg4MTNkO1xuY29uc3QgVEVYVFVSRV9DT01QQVJFX01PREUgICAgICAgICAgID0gMHg4ODRDO1xuY29uc3QgVEVYVFVSRV9DT01QQVJFX0ZVTkMgICAgICAgICAgID0gMHg4ODREO1xuXG4vKiBQaXhlbCBzdG9yZSAqL1xuY29uc3QgVU5QQUNLX0FMSUdOTUVOVCAgICAgICAgICAgICAgICAgICA9IDB4MGNmNTtcbmNvbnN0IFVOUEFDS19ST1dfTEVOR1RIICAgICAgICAgICAgICAgICAgPSAweDBjZjI7XG5jb25zdCBVTlBBQ0tfSU1BR0VfSEVJR0hUICAgICAgICAgICAgICAgID0gMHg4MDZlO1xuY29uc3QgVU5QQUNLX1NLSVBfUElYRUxTICAgICAgICAgICAgICAgICA9IDB4MGNmNDtcbmNvbnN0IFVOUEFDS19TS0lQX1JPV1MgICAgICAgICAgICAgICAgICAgPSAweDBjZjM7XG5jb25zdCBVTlBBQ0tfU0tJUF9JTUFHRVMgICAgICAgICAgICAgICAgID0gMHg4MDZkO1xuY29uc3QgVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCA9IDB4OTI0MztcbmNvbnN0IFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCAgICAgPSAweDkyNDE7XG5jb25zdCBVTlBBQ0tfRkxJUF9ZX1dFQkdMICAgICAgICAgICAgICAgID0gMHg5MjQwO1xuXG5jb25zdCBSOCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjI5O1xuY29uc3QgUjhfU05PUk0gICAgICAgICAgICAgICAgICAgICA9IDB4OEY5NDtcbmNvbnN0IFIxNkYgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMkQ7XG5jb25zdCBSMzJGICAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjJFO1xuY29uc3QgUjhVSSAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzMjtcbmNvbnN0IFI4SSAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMzE7XG5jb25zdCBSRzE2VUkgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjNBO1xuY29uc3QgUkcxNkkgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzOTtcbmNvbnN0IFJHMzJVSSAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyM0M7XG5jb25zdCBSRzMySSAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjNCO1xuY29uc3QgUkc4ICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIyQjtcbmNvbnN0IFJHOF9TTk9STSAgICAgICAgICAgICAgICAgICAgPSAweDhGOTU7XG5jb25zdCBSRzE2RiAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjJGO1xuY29uc3QgUkczMkYgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzMDtcbmNvbnN0IFJHOFVJICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMzg7XG5jb25zdCBSRzhJICAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjM3O1xuY29uc3QgUjE2VUkgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzNDtcbmNvbnN0IFIxNkkgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMzM7XG5jb25zdCBSMzJVSSAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjM2O1xuY29uc3QgUjMySSAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzNTtcbmNvbnN0IFJHQjggICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgwNTE7XG5jb25zdCBTUkdCOCAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4QzQxO1xuY29uc3QgUkdCNTY1JDEgICAgICAgICAgICAgICAgICAgICAgID0gMHg4RDYyO1xuY29uc3QgUkdCOF9TTk9STSAgICAgICAgICAgICAgICAgICA9IDB4OEY5NjtcbmNvbnN0IFIxMUZfRzExRl9CMTBGICAgICAgICAgICAgICAgPSAweDhDM0E7XG5jb25zdCBSR0I5X0U1ICAgICAgICAgICAgICAgICAgICAgID0gMHg4QzNEO1xuY29uc3QgUkdCMTZGICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODgxQjtcbmNvbnN0IFJHQjMyRiAgICAgICAgICAgICAgICAgICAgICAgPSAweDg4MTU7XG5jb25zdCBSR0I4VUkgICAgICAgICAgICAgICAgICAgICAgID0gMHg4RDdEO1xuY29uc3QgUkdCOEkgICAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ4RjtcbmNvbnN0IFJHQjE2VUkgICAgICAgICAgICAgICAgICAgICAgPSAweDhENzc7XG5jb25zdCBSR0IxNkkgICAgICAgICAgICAgICAgICAgICAgID0gMHg4RDg5O1xuY29uc3QgUkdCMzJVSSAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ3MTtcbmNvbnN0IFJHQjMySSAgICAgICAgICAgICAgICAgICAgICAgPSAweDhEODM7XG5jb25zdCBSR0JBOCAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MDU4O1xuY29uc3QgU1JHQjhfQUxQSEE4ICAgICAgICAgICAgICAgICA9IDB4OEM0MztcbmNvbnN0IFJHQkE4X1NOT1JNICAgICAgICAgICAgICAgICAgPSAweDhGOTc7XG5jb25zdCBSR0I1X0ExJDEgICAgICAgICAgICAgICAgICAgICAgPSAweDgwNTc7XG5jb25zdCBSR0JBNCQxICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgwNTY7XG5jb25zdCBSR0IxMF9BMiAgICAgICAgICAgICAgICAgICAgID0gMHg4MDU5O1xuY29uc3QgUkdCQTE2RiAgICAgICAgICAgICAgICAgICAgICA9IDB4ODgxQTtcbmNvbnN0IFJHQkEzMkYgICAgICAgICAgICAgICAgICAgICAgPSAweDg4MTQ7XG5jb25zdCBSR0JBOFVJICAgICAgICAgICAgICAgICAgICAgID0gMHg4RDdDO1xuY29uc3QgUkdCQThJICAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ4RTtcbmNvbnN0IFJHQjEwX0EyVUkgICAgICAgICAgICAgICAgICAgPSAweDkwNkY7XG5jb25zdCBSR0JBMTZVSSAgICAgICAgICAgICAgICAgICAgID0gMHg4RDc2O1xuY29uc3QgUkdCQTE2SSAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ4ODtcbmNvbnN0IFJHQkEzMkkgICAgICAgICAgICAgICAgICAgICAgPSAweDhEODI7XG5jb25zdCBSR0JBMzJVSSAgICAgICAgICAgICAgICAgICAgID0gMHg4RDcwO1xuXG5jb25zdCBERVBUSF9DT01QT05FTlQxNiQxICAgICAgICAgICAgPSAweDgxQTU7XG5jb25zdCBERVBUSF9DT01QT05FTlQyNCQxICAgICAgICAgICAgPSAweDgxQTY7XG5jb25zdCBERVBUSF9DT01QT05FTlQzMkYkMSAgICAgICAgICAgPSAweDhDQUM7XG5jb25zdCBERVBUSDMyRl9TVEVOQ0lMOCQxICAgICAgICAgICAgPSAweDhDQUQ7XG5jb25zdCBERVBUSDI0X1NURU5DSUw4JDEgICAgICAgICAgICAgPSAweDg4RjA7XG5cbi8qIERhdGFUeXBlICovXG5jb25zdCBCWVRFICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDAwO1xuY29uc3QgVU5TSUdORURfQllURSQxICAgICAgICAgICAgICAgID0gMHgxNDAxO1xuY29uc3QgU0hPUlQgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMjtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUJDEgICAgICAgICAgICAgICA9IDB4MTQwMztcbmNvbnN0IElOVCQxICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNDtcbmNvbnN0IFVOU0lHTkVEX0lOVCQxICAgICAgICAgICAgICAgICA9IDB4MTQwNTtcbmNvbnN0IEZMT0FUJDEgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNjtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgICAgICAgPSAweDgwMzM7XG5jb25zdCBVTlNJR05FRF9TSE9SVF81XzVfNV8xICAgICAgID0gMHg4MDM0O1xuY29uc3QgVU5TSUdORURfU0hPUlRfNV82XzUgICAgICAgICA9IDB4ODM2MztcbmNvbnN0IEhBTEZfRkxPQVQgICAgICAgICAgICAgICAgICAgPSAweDE0MEI7XG5jb25zdCBIQUxGX0ZMT0FUX09FUyAgICAgICAgICAgICAgID0gMHg4RDYxOyAgLy8gVGhhbmtzIEtocm9ub3MgZm9yIG1ha2luZyB0aGlzIGRpZmZlcmVudCA+OihcbmNvbnN0IFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViAgPSAweDgzNjg7XG5jb25zdCBVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWID0gMHg4QzNCO1xuY29uc3QgVU5TSUdORURfSU5UXzVfOV85XzlfUkVWICAgICA9IDB4OEMzRTtcbmNvbnN0IEZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFViA9IDB4OERBRDtcbmNvbnN0IFVOU0lHTkVEX0lOVF8yNF84ICAgICAgICAgICAgPSAweDg0RkE7XG5cbmNvbnN0IFJHICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMjc7XG5jb25zdCBSR19JTlRFR0VSICAgICAgICAgICAgICAgICAgID0gMHg4MjI4O1xuY29uc3QgUkVEICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTkwMztcbmNvbnN0IFJFRF9JTlRFR0VSICAgICAgICAgICAgICAgICAgPSAweDhEOTQ7XG5jb25zdCBSR0JfSU5URUdFUiAgICAgICAgICAgICAgICAgID0gMHg4RDk4O1xuY29uc3QgUkdCQV9JTlRFR0VSICAgICAgICAgICAgICAgICA9IDB4OEQ5OTtcblxuY29uc3QgZm9ybWF0SW5mbyA9IHt9O1xue1xuICAvLyBOT1RFOiB0aGlzIGlzIG5hbWVkIGBudW1Db2xvckNvbXBvbmVudHNgIHZzIGBudW1Db21wb25lbnRzYCBzbyB3ZSBjYW4gbGV0IFVnbGlmeSBtYW5nbGVcbiAgLy8gdGhlIG5hbWUuXG4gIGNvbnN0IGYgPSBmb3JtYXRJbmZvO1xuICBmW0FMUEhBXSAgICAgICAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogMSwgfTtcbiAgZltMVU1JTkFOQ0VdICAgICAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDEsIH07XG4gIGZbTFVNSU5BTkNFX0FMUEhBXSA9IHsgbnVtQ29sb3JDb21wb25lbnRzOiAyLCB9O1xuICBmW1JHQl0gICAgICAgICAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogMywgfTtcbiAgZltSR0JBJDFdICAgICAgICAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogNCwgfTtcbiAgZltSRURdICAgICAgICAgICAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDEsIH07XG4gIGZbUkVEX0lOVEVHRVJdICAgICA9IHsgbnVtQ29sb3JDb21wb25lbnRzOiAxLCB9O1xuICBmW1JHXSAgICAgICAgICAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogMiwgfTtcbiAgZltSR19JTlRFR0VSXSAgICAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDIsIH07XG4gIGZbUkdCXSAgICAgICAgICAgICA9IHsgbnVtQ29sb3JDb21wb25lbnRzOiAzLCB9O1xuICBmW1JHQl9JTlRFR0VSXSAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogMywgfTtcbiAgZltSR0JBJDFdICAgICAgICAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogNCwgfTtcbiAgZltSR0JBX0lOVEVHRVJdICAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDQsIH07XG4gIGZbREVQVEhfQ09NUE9ORU5UJDFdID0geyBudW1Db2xvckNvbXBvbmVudHM6IDEsIH07XG4gIGZbREVQVEhfU1RFTkNJTCQxXSAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDIsIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dHVyZUZvcm1hdERldGFpbHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXh0dXJlRm9ybWF0IGZvcm1hdCB0byBwYXNzIHRleEltYWdlMkQgYW5kIHNpbWlsYXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb2xvclJlbmRlcmFibGUgdHJ1ZSBpZiB5b3UgY2FuIHJlbmRlciB0byB0aGlzIGZvcm1hdCBvZiB0ZXh0dXJlLlxuICogQHByb3BlcnR5IHtib29sZWFufSB0ZXh0dXJlRmlsdGVyYWJsZSB0cnVlIGlmIHlvdSBjYW4gZmlsdGVyIHRoZSB0ZXh0dXJlLCBmYWxzZSBpZiB5b3UgY2FuIG9ueSB1c2UgYE5FQVJFU1RgLlxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gdHlwZSBBcnJheSBvZiBwb3NzaWJsZSB0eXBlcyB5b3UgY2FuIHBhc3MgdG8gdGV4SW1hZ2UyRCBhbmQgc2ltaWxhciBmdW5jdGlvblxuICogQHByb3BlcnR5IHtPYmplY3QuPG51bWJlcixudW1iZXI+fSBieXRlc1BlckVsZW1lbnRNYXAgQSBtYXAgb2YgdHlwZXMgdG8gYnl0ZXMgcGVyIGVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cblxubGV0IHNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mbztcbmZ1bmN0aW9uIGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpIHtcbiAgaWYgKCFzX3RleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8pIHtcbiAgICAvLyBOT1RFOiB0aGVzZSBwcm9wZXJ0aWVzIG5lZWQgdW5pcXVlIG5hbWVzIHNvIHdlIGNhbiBsZXQgVWdsaWZ5IG1hbmdsZSB0aGUgbmFtZS5cbiAgICBjb25zdCB0ID0ge307XG4gICAgLy8gdW5zaXplZCBmb3JtYXRzXG4gICAgdFtBTFBIQV0gICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBBTFBIQSwgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMSwgMiwgMiwgNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQxLCBIQUxGX0ZMT0FULCBIQUxGX0ZMT0FUX09FUywgRkxPQVQkMV0sIH07XG4gICAgdFtMVU1JTkFOQ0VdICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBMVU1JTkFOQ0UsICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMSwgMiwgMiwgNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQxLCBIQUxGX0ZMT0FULCBIQUxGX0ZMT0FUX09FUywgRkxPQVQkMV0sIH07XG4gICAgdFtMVU1JTkFOQ0VfQUxQSEFdICAgID0geyB0ZXh0dXJlRm9ybWF0OiBMVU1JTkFOQ0VfQUxQSEEsIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMiwgNCwgNCwgOF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQxLCBIQUxGX0ZMT0FULCBIQUxGX0ZMT0FUX09FUywgRkxPQVQkMV0sIH07XG4gICAgdFtSR0JdICAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMywgNiwgNiwgMTIsIDJdLCAgICB0eXBlOiBbVU5TSUdORURfQllURSQxLCBIQUxGX0ZMT0FULCBIQUxGX0ZMT0FUX09FUywgRkxPQVQkMSwgVU5TSUdORURfU0hPUlRfNV82XzVdLCB9O1xuICAgIHRbUkdCQSQxXSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBJDEsICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFs0LCA4LCA4LCAxNiwgMiwgMl0sIHR5cGU6IFtVTlNJR05FRF9CWVRFJDEsIEhBTEZfRkxPQVQsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVCQxLCBVTlNJR05FRF9TSE9SVF80XzRfNF80LCBVTlNJR05FRF9TSE9SVF81XzVfNV8xXSwgfTtcbiAgICB0W0RFUFRIX0NPTVBPTkVOVCQxXSAgICA9IHsgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5UJDEsIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMiwgNF0sICAgICAgICAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UJDEsIFVOU0lHTkVEX1NIT1JUJDFdLCB9O1xuXG4gICAgLy8gc2l6ZWQgZm9ybWF0c1xuICAgIHRbUjhdICAgICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkVELCAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzFdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMV0sIH07XG4gICAgdFtSOF9TTk9STV0gICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRUQsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMV0sICAgICAgICB0eXBlOiBbQllURV0sIH07XG4gICAgdFtSMTZGXSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRUQsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgMl0sICAgICB0eXBlOiBbRkxPQVQkMSwgSEFMRl9GTE9BVF0sIH07XG4gICAgdFtSMzJGXSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRUQsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbRkxPQVQkMV0sIH07XG4gICAgdFtSOFVJXSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUiwgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMV0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQxXSwgfTtcbiAgICB0W1I4SV0gICAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsxXSwgICAgICAgIHR5cGU6IFtCWVRFXSwgfTtcbiAgICB0W1IxNlVJXSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsyXSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVCQxXSwgfTtcbiAgICB0W1IxNkldICAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsyXSwgICAgICAgIHR5cGU6IFtTSE9SVF0sIH07XG4gICAgdFtSMzJVSV0gICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUiwgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UJDFdLCB9O1xuICAgIHRbUjMySV0gICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkVEX0lOVEVHRVIsICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzRdLCAgICAgICAgdHlwZTogW0lOVCQxXSwgfTtcbiAgICB0W1JHOF0gICAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHLCAgICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFsyXSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFJDFdLCB9O1xuICAgIHRbUkc4X1NOT1JNXSAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkcsICAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzJdLCAgICAgICAgdHlwZTogW0JZVEVdLCB9O1xuICAgIHRbUkcxNkZdICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkcsICAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzgsIDRdLCAgICAgdHlwZTogW0ZMT0FUJDEsIEhBTEZfRkxPQVRdLCB9O1xuICAgIHRbUkczMkZdICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkcsICAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzhdLCAgICAgICAgdHlwZTogW0ZMT0FUJDFdLCB9O1xuICAgIHRbUkc4VUldICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUiwgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzJdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMV0sIH07XG4gICAgdFtSRzhJXSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR19JTlRFR0VSLCAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMl0sICAgICAgICB0eXBlOiBbQllURV0sIH07XG4gICAgdFtSRzE2VUldICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR19JTlRFR0VSLCAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfU0hPUlQkMV0sIH07XG4gICAgdFtSRzE2SV0gICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR19JTlRFR0VSLCAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbU0hPUlRdLCB9O1xuICAgIHRbUkczMlVJXSAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUiwgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzhdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVCQxXSwgfTtcbiAgICB0W1JHMzJJXSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs4XSwgICAgICAgIHR5cGU6IFtJTlQkMV0sIH07XG4gICAgdFtSR0I4XSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbM10sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQxXSwgfTtcbiAgICB0W1NSR0I4XSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQiwgICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFszXSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFJDFdLCB9O1xuICAgIHRbUkdCNTY1JDFdICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMywgMl0sICAgICB0eXBlOiBbVU5TSUdORURfQllURSQxLCBVTlNJR05FRF9TSE9SVF81XzZfNV0sIH07XG4gICAgdFtSR0I4X1NOT1JNXSAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbM10sICAgICAgICB0eXBlOiBbQllURV0sIH07XG4gICAgdFtSMTFGX0cxMUZfQjEwRl0gICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMTIsIDYsIDRdLCB0eXBlOiBbRkxPQVQkMSwgSEFMRl9GTE9BVCwgVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFVl0sIH07XG4gICAgdFtSR0I5X0U1XSAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMTIsIDYsIDRdLCB0eXBlOiBbRkxPQVQkMSwgSEFMRl9GTE9BVCwgVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXSwgfTtcbiAgICB0W1JHQjE2Rl0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQiwgICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFsxMiwgNl0sICAgIHR5cGU6IFtGTE9BVCQxLCBIQUxGX0ZMT0FUXSwgfTtcbiAgICB0W1JHQjMyRl0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQiwgICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsxMl0sICAgICAgIHR5cGU6IFtGTE9BVCQxXSwgfTtcbiAgICB0W1JHQjhVSV0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFszXSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFJDFdLCB9O1xuICAgIHRbUkdCOEldICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzNdLCAgICAgICAgdHlwZTogW0JZVEVdLCB9O1xuICAgIHRbUkdCMTZVSV0gICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzZdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX1NIT1JUJDFdLCB9O1xuICAgIHRbUkdCMTZJXSAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzZdLCAgICAgICAgdHlwZTogW1NIT1JUXSwgfTtcbiAgICB0W1JHQjMyVUldICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsxMl0sICAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlQkMV0sIH07XG4gICAgdFtSR0IzMkldICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JfSU5URUdFUiwgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMTJdLCAgICAgICB0eXBlOiBbSU5UJDFdLCB9O1xuICAgIHRbUkdCQThdICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQSQxLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQxXSwgfTtcbiAgICB0W1NSR0I4X0FMUEhBOF0gICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkEkMSwgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzRdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMV0sIH07XG4gICAgdFtSR0JBOF9TTk9STV0gICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBJDEsICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtCWVRFXSwgfTtcbiAgICB0W1JHQjVfQTEkMV0gICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQSQxLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgMiwgNF0sICB0eXBlOiBbVU5TSUdORURfQllURSQxLCBVTlNJR05FRF9TSE9SVF81XzVfNV8xLCBVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZdLCB9O1xuICAgIHRbUkdCQTQkMV0gICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBJDEsICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFs0LCAyXSwgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFJDEsIFVOU0lHTkVEX1NIT1JUXzRfNF80XzRdLCB9O1xuICAgIHRbUkdCMTBfQTJdICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQSQxLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXSwgfTtcbiAgICB0W1JHQkExNkZdICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkEkMSwgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzE2LCA4XSwgICAgdHlwZTogW0ZMT0FUJDEsIEhBTEZfRkxPQVRdLCB9O1xuICAgIHRbUkdCQTMyRl0gICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQSQxLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMTZdLCAgICAgICB0eXBlOiBbRkxPQVQkMV0sIH07XG4gICAgdFtSR0JBOFVJXSAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQxXSwgfTtcbiAgICB0W1JHQkE4SV0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUiwgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtCWVRFXSwgfTtcbiAgICB0W1JHQjEwX0EyVUldICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUiwgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZdLCB9O1xuICAgIHRbUkdCQTE2VUldICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQV9JTlRFR0VSLCAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzhdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX1NIT1JUJDFdLCB9O1xuICAgIHRbUkdCQTE2SV0gICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQV9JTlRFR0VSLCAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzhdLCAgICAgICAgdHlwZTogW1NIT1JUXSwgfTtcbiAgICB0W1JHQkEzMkldICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUiwgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsxNl0sICAgICAgIHR5cGU6IFtJTlQkMV0sIH07XG4gICAgdFtSR0JBMzJVSV0gICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMTZdLCAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UJDFdLCB9O1xuICAgIC8vIFNpemVkIEludGVybmFsXG4gICAgdFtERVBUSF9DT01QT05FTlQxNiQxXSAgPSB7IHRleHR1cmVGb3JtYXQ6IERFUFRIX0NPTVBPTkVOVCQxLCBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzIsIDRdLCAgICAgdHlwZTogW1VOU0lHTkVEX1NIT1JUJDEsIFVOU0lHTkVEX0lOVCQxXSwgfTtcbiAgICB0W0RFUFRIX0NPTVBPTkVOVDI0JDFdICA9IHsgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5UJDEsIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UJDFdLCB9O1xuICAgIHRbREVQVEhfQ09NUE9ORU5UMzJGJDFdID0geyB0ZXh0dXJlRm9ybWF0OiBERVBUSF9DT01QT05FTlQkMSwgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtGTE9BVCQxXSwgfTtcbiAgICB0W0RFUFRIMjRfU1RFTkNJTDgkMV0gICA9IHsgdGV4dHVyZUZvcm1hdDogREVQVEhfU1RFTkNJTCQxLCAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UXzI0XzhdLCB9O1xuICAgIHRbREVQVEgzMkZfU1RFTkNJTDgkMV0gID0geyB0ZXh0dXJlRm9ybWF0OiBERVBUSF9TVEVOQ0lMJDEsICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZdLCB9O1xuXG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihpbnRlcm5hbEZvcm1hdCkge1xuICAgICAgY29uc3QgaW5mbyA9IHRbaW50ZXJuYWxGb3JtYXRdO1xuICAgICAgaW5mby5ieXRlc1BlckVsZW1lbnRNYXAgPSB7fTtcbiAgICAgIGluZm8uYnl0ZXNQZXJFbGVtZW50LmZvckVhY2goZnVuY3Rpb24oYnl0ZXNQZXJFbGVtZW50LCBuZHgpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGluZm8udHlwZVtuZHhdO1xuICAgICAgICBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcFt0eXBlXSA9IGJ5dGVzUGVyRWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyA9IHQ7XG4gIH1cbiAgcmV0dXJuIHNfdGV4dHVyZUludGVybmFsRm9ybWF0SW5mb1tpbnRlcm5hbEZvcm1hdF07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHBlciBlbGVtZW50IGZvciBhIGdpdmVuIGludGVybmFsRm9ybWF0IC8gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGludGVybmFsRm9ybWF0IFRoZSBpbnRlcm5hbEZvcm1hdCBwYXJhbWV0ZXIgZnJvbSB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgdHlwZSBwYXJhbWV0ZXIgZm9yIHRleEltYWdlMkQgZXRjLi5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBieXRlcyBwZXIgZWxlbWVudCBmb3IgdGhlIGdpdmVuIGludGVybmFsRm9ybWF0LCB0eXBlIGNvbWJvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQsIHR5cGUpIHtcbiAgY29uc3QgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gaW50ZXJuYWwgZm9ybWF0XCI7XG4gIH1cbiAgY29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gaW5mby5ieXRlc1BlckVsZW1lbnRNYXBbdHlwZV07XG4gIGlmIChieXRlc1BlckVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuICByZXR1cm4gYnl0ZXNQZXJFbGVtZW50O1xufVxuXG4vKipcbiAqIEluZm8gcmVsYXRlZCB0byBhIHNwZWNpZmljIHRleHR1cmUgaW50ZXJuYWxGb3JtYXQgYXMgcmV0dXJuZWRcbiAqIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsL3RleHR1cmVzLmdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdH0uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dHVyZUZvcm1hdEluZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmb3JtYXQgRm9ybWF0IHRvIHBhc3MgdG8gdGV4SW1hZ2UyRCBhbmQgcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlIFR5cGUgdG8gcGFzcyB0byB0ZXhJbWFnZTJEIGFuZCByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBmb3JtYXQgYW5kIHR5cGUgZm9yIGEgZ2l2ZW4gaW50ZXJuYWxGb3JtYXRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJuYWxGb3JtYXQgVGhlIGludGVybmFsIGZvcm1hdFxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdGV4dHVyZXMuVGV4dHVyZUZvcm1hdEluZm99IHRoZSBjb3JyZXNwb25kaW5nIGZvcm1hdCBhbmQgdHlwZSxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpIHtcbiAgY29uc3QgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gaW50ZXJuYWwgZm9ybWF0XCI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IGluZm8udGV4dHVyZUZvcm1hdCxcbiAgICB0eXBlOiBpbmZvLnR5cGVbMF0sXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIHBvd2VyIG9mIDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBudW1iZXIgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHRydWUgaWYgdmFsdWUgaXMgcG93ZXIgb2YgMlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNQb3dlck9mMih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYgKHZhbHVlIC0gMSkpID09PSAwO1xufVxuXG4vKipcbiAqIEdldHMgd2hldGhlciBvciBub3Qgd2UgY2FuIGdlbmVyYXRlIG1pcHMgZm9yIHRoZSBnaXZlblxuICogaW50ZXJuYWwgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIHdpZHRoIHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBwYXJhbWV0ZXIgZnJvbSB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJuYWxGb3JtYXQgVGhlIGludGVybmFsRm9ybWF0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgd2UgY2FuIGdlbmVyYXRlIG1pcHNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBjYW5HZW5lcmF0ZU1pcG1hcChnbCwgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQpIHtcbiAgaWYgKCFpc1dlYkdMMihnbCkpIHtcbiAgICByZXR1cm4gaXNQb3dlck9mMih3aWR0aCkgJiYgaXNQb3dlck9mMihoZWlnaHQpO1xuICB9XG4gIGNvbnN0IGluZm8gPSBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvKGludGVybmFsRm9ybWF0KTtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhyb3cgXCJ1bmtub3duIGludGVybmFsIGZvcm1hdFwiO1xuICB9XG4gIHJldHVybiBpbmZvLmNvbG9yUmVuZGVyYWJsZSAmJiBpbmZvLnRleHR1cmVGaWx0ZXJhYmxlO1xufVxuXG4vKipcbiAqIEdldHMgd2hldGhlciBvciBub3Qgd2UgY2FuIGdlbmVyYXRlIG1pcHMgZm9yIHRoZSBnaXZlbiBmb3JtYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcm5hbEZvcm1hdCBUaGUgaW50ZXJuYWxGb3JtYXQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSBjYW4gZ2VuZXJhdGUgbWlwc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIGNhbkZpbHRlcihpbnRlcm5hbEZvcm1hdCkge1xuICBjb25zdCBpbmZvID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyhpbnRlcm5hbEZvcm1hdCk7XG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuICByZXR1cm4gaW5mby50ZXh0dXJlRmlsdGVyYWJsZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBmb3IgYSBnaXZlbiBpbWFnZSBmb3JtYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZm9ybWF0IHRoZSBmb3JtYXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBmb3IgdGhlIGZvcm1hdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBnZXROdW1Db21wb25lbnRzRm9yRm9ybWF0KGZvcm1hdCkge1xuICBjb25zdCBpbmZvID0gZm9ybWF0SW5mb1tmb3JtYXRdO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gZm9ybWF0OiBcIiArIGZvcm1hdDtcbiAgfVxuICByZXR1cm4gaW5mby5udW1Db2xvckNvbXBvbmVudHM7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdGV4dHVyZSB0eXBlIGZvciBhIGdpdmVuIGFycmF5IHR5cGUuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZ2wgdGV4dHVyZSB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRUZXh0dXJlVHlwZUZvckFycmF5VHlwZShnbCwgc3JjLCBkZWZhdWx0VHlwZSkge1xuICBpZiAoaXNBcnJheUJ1ZmZlcihzcmMpKSB7XG4gICAgcmV0dXJuIGdldEdMVHlwZUZvclR5cGVkQXJyYXkoc3JjKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFR5cGUgfHwgVU5TSUdORURfQllURSQxO1xufVxuXG5mdW5jdGlvbiBndWVzc0RpbWVuc2lvbnMoZ2wsIHRhcmdldCwgd2lkdGgsIGhlaWdodCwgbnVtRWxlbWVudHMpIHtcbiAgaWYgKG51bUVsZW1lbnRzICUgMSAhPT0gMCkge1xuICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgZGltZW5zaW9uc1wiO1xuICB9XG4gIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLnNxcnQobnVtRWxlbWVudHMgLyAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQJDEgPyA2IDogMSkpO1xuICAgIGlmIChzaXplICUgMSA9PT0gMCkge1xuICAgICAgd2lkdGggPSBzaXplO1xuICAgICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBudW1FbGVtZW50cztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBudW1FbGVtZW50cyAvIHdpZHRoO1xuICAgIGlmIChoZWlnaHQgJSAxKSB7XG4gICAgICB0aHJvdyBcImNhbid0IGd1ZXNzIGRpbWVuc2lvbnNcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXdpZHRoKSB7XG4gICAgd2lkdGggPSBudW1FbGVtZW50cyAvIGhlaWdodDtcbiAgICBpZiAod2lkdGggJSAxKSB7XG4gICAgICB0aHJvdyBcImNhbid0IGd1ZXNzIGRpbWVuc2lvbnNcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gIH07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCB0ZXh0dXJlIGNvbG9yLlxuICpcbiAqIFRoZSBkZWZhdWx0IHRleHR1cmUgY29sb3IgaXMgdXNlZCB3aGVuIGxvYWRpbmcgdGV4dHVyZXMgZnJvbVxuICogdXJscy4gQmVjYXVzZSB0aGUgVVJMIHdpbGwgYmUgbG9hZGVkIGFzeW5jIHdlJ2QgbGlrZSB0byBiZVxuICogYWJsZSB0byB1c2UgdGhlIHRleHR1cmUgaW1tZWRpYXRlbHkuIEJ5IHB1dHRpbmcgYSAxeDEgcGl4ZWxcbiAqIGNvbG9yIGluIHRoZSB0ZXh0dXJlIHdlIGNhbiBzdGFydCB1c2luZyB0aGUgdGV4dHVyZSBiZWZvcmVcbiAqIHRoZSBVUkwgaGFzIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBjb2xvciBBcnJheSBvZiA0IHZhbHVlcyBpbiB0aGUgcmFuZ2UgMCB0byAxXG4gKiBAZGVwcmVjYXRlZCBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldERlZmF1bHRzfVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRUZXh0dXJlQ29sb3IoY29sb3IpIHtcbiAgZGVmYXVsdHMkMS50ZXh0dXJlQ29sb3IgPSBuZXcgVWludDhBcnJheShbY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSwgY29sb3JbM10gKiAyNTVdKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdHMkMShuZXdEZWZhdWx0cykge1xuICBjb3B5RXhpc3RpbmdQcm9wZXJ0aWVzKG5ld0RlZmF1bHRzLCBkZWZhdWx0cyQxKTtcbiAgaWYgKG5ld0RlZmF1bHRzLnRleHR1cmVDb2xvcikge1xuICAgIHNldERlZmF1bHRUZXh0dXJlQ29sb3IobmV3RGVmYXVsdHMudGV4dHVyZUNvbG9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIHNvdXJjZSBmb3IgYSB0ZXh0dXJlLlxuICogQGNhbGxiYWNrIFRleHR1cmVGdW5jXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgdGhlIHRleHR1cmUgb3B0aW9uc1xuICogQHJldHVybiB7Kn0gUmV0dXJucyBhbnkgb2YgdGhlIHRoaW5ncyBkb2N1bWVudGVkIGZvciBgc3JjYCBmb3Ige0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogVGV4dHVyZSBvcHRpb25zIHBhc3NlZCB0byBtb3N0IHRleHR1cmUgZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIHdpbGwgdXNlIHdoYXRldmVyIG9wdGlvbnNcbiAqIGFyZSBhcHByb3ByaWF0ZSBmb3IgaXRzIG5lZWRzLiBUaGlzIGxldHMgeW91IHBhc3MgdGhlIHNhbWUgb3B0aW9ucyB0byBhbGwgZnVuY3Rpb25zLlxuICpcbiAqIE5vdGU6IEEgYFRleEltYWdlU291cmNlYCBpcyBkZWZpbmVkIGluIHRoZSBXZWJHTCBzcGVjIGFzIGEgYEhUTUxJbWFnZUVsZW1lbnRgLCBgSFRNTFZpZGVvRWxlbWVudGAsXG4gKiBgSFRNTENhbnZhc0VsZW1lbnRgLCBgSW1hZ2VCaXRtYXBgLCBvciBgSW1hZ2VEYXRhYC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0dXJlT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRdIHRoZSB0eXBlIG9mIHRleHR1cmUgYGdsLlRFWFRVUkVfMkRgIG9yIGBnbC5URVhUVVJFX0NVQkVfTUFQYC4gRGVmYXVsdHMgdG8gYGdsLlRFWFRVUkVfMkRgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZXZlbF0gdGhlIG1pcCBsZXZlbCB0byBhZmZlY3QuIERlZmF1bHRzIHRvIDAuIE5vdGUsIGlmIHNldCBhdXRvIHdpbGwgYmUgY29uc2lkZXJlZCBmYWxzZSB1bmxlc3MgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIHRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS4gT25seSB1c2VkIGlmIHNyYyBpcyBhbiBhcnJheSBvciB0eXBlZCBhcnJheSBvciBudWxsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgb2YgYSB0ZXh0dXJlLiBPbmx5IHVzZWQgaWYgc3JjIGlzIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5IG9yIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlcHRoXSB0aGUgZGVwdGggb2YgYSB0ZXh0dXJlLiBPbmx5IHVzZWQgaWYgc3JjIGlzIGFuIGFycmF5IG9yIHR5cGUgYXJyYXkgb3IgbnVsbCBhbmQgdGFyZ2V0IGlzIGBURVhUVVJFXzNEYCAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbl0gdGhlIG1pbiBmaWx0ZXIgc2V0dGluZyAoZWcuIGBnbC5MSU5FQVJgKS4gRGVmYXVsdHMgdG8gYGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUmBcbiAqICAgICBvciBpZiB0ZXh0dXJlIGlzIG5vdCBhIHBvd2VyIG9mIDIgb24gYm90aCBkaW1lbnNpb25zIHRoZW4gZGVmYXVsdHMgdG8gYGdsLkxJTkVBUmAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21hZ10gdGhlIG1hZyBmaWx0ZXIgc2V0dGluZyAoZWcuIGBnbC5MSU5FQVJgKS4gRGVmYXVsdHMgdG8gYGdsLkxJTkVBUmBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluTWFnXSBib3RoIHRoZSBtaW4gYW5kIG1hZyBmaWx0ZXIgc2V0dGluZ3MuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ludGVybmFsRm9ybWF0XSBpbnRlcm5hbCBmb3JtYXQgZm9yIHRleHR1cmUuIERlZmF1bHRzIHRvIGBnbC5SR0JBYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb3JtYXRdIGZvcm1hdCBmb3IgdGV4dHVyZS4gRGVmYXVsdHMgdG8gYGdsLlJHQkFgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0eXBlXSB0eXBlIGZvciB0ZXh0dXJlLiBEZWZhdWx0cyB0byBgZ2wuVU5TSUdORURfQllURWAgdW5sZXNzIGBzcmNgIGlzIEFycmF5QnVmZmVyVmlldy4gSWYgYHNyY2BcbiAqICAgICBpcyBBcnJheUJ1ZmZlclZpZXcgZGVmYXVsdHMgdG8gdHlwZSB0aGF0IG1hdGNoZXMgQXJyYXlCdWZmZXJWaWV3IHR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyYXBdIFRleHR1cmUgd3JhcHBpbmcgZm9yIGJvdGggUyBhbmQgVCAoYW5kIFIgaWYgVEVYVFVSRV8zRCBvciBXZWJHTFNhbXBsZXIpLiBEZWZhdWx0cyB0byBgZ2wuUkVQRUFUYCBmb3IgMkQgdW5sZXNzIHNyYyBpcyBXZWJHTDEgYW5kIHNyYyBub3QgbnBvdCBhbmQgYGdsLkNMQU1QX1RPX0VER0VgIGZvciBjdWJlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyYXBTXSBUZXh0dXJlIHdyYXBwaW5nIGZvciBTLiBEZWZhdWx0cyB0byBgZ2wuUkVQRUFUYCBhbmQgYGdsLkNMQU1QX1RPX0VER0VgIGZvciBjdWJlLiBJZiBzZXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGB3cmFwYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd3JhcFRdIFRleHR1cmUgd3JhcHBpbmcgZm9yIFQuIERlZmF1bHRzIHRvIGBnbC5SRVBFQVRgIGFuZCBgZ2wuQ0xBTVBfVE9fRURHRWAgZm9yIGN1YmUuIElmIHNldCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHdyYXBgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3cmFwUl0gVGV4dHVyZSB3cmFwcGluZyBmb3IgUi4gRGVmYXVsdHMgdG8gYGdsLlJFUEVBVGAgYW5kIGBnbC5DTEFNUF9UT19FREdFYCBmb3IgY3ViZS4gSWYgc2V0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgd3JhcGAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbkxvZF0gVEVYVFVSRV9NSU5fTE9EIHNldHRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4TG9kXSBURVhUVVJFX01BWF9MT0Qgc2V0dGluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXNlTGV2ZWxdIFRFWFRVUkVfQkFTRV9MRVZFTCBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heExldmVsXSBURVhUVVJFX01BWF9MRVZFTCBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvbXBhcmVGdW5jXSBURVhUVVJFX0NPTVBBUkVfRlVOQyBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvbXBhcmVNb2RlXSBURVhUVVJFX0NPTVBBUkVfTU9ERSBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3VucGFja0FsaWdubWVudF0gVGhlIGBnbC5VTlBBQ0tfQUxJR05NRU5UYCB1c2VkIHdoZW4gdXBsb2FkaW5nIGFuIGFycmF5LiBEZWZhdWx0cyB0byAxLlxuICogQHByb3BlcnR5IHtudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd9IFtjb2xvcl0gQ29sb3IgdG8gaW5pdGlhbGl6ZSB0aGlzIHRleHR1cmUgd2l0aCBpZiBsb2FkaW5nIGFuIGltYWdlIGFzeW5jaHJvbm91c2x5LlxuICogICAgIFRoZSBkZWZhdWx0IHVzZSBhIGJsdWUgMXgxIHBpeGVsIHRleHR1cmUuIFlvdSBjYW4gc2V0IGFub3RoZXIgZGVmYXVsdCBieSBjYWxsaW5nIGB0d2dsLnNldERlZmF1bHRzYFxuICogICAgIG9yIHlvdSBjYW4gc2V0IGFuIGluZGl2aWR1YWwgdGV4dHVyZSdzIGluaXRpYWwgY29sb3IgYnkgc2V0dGluZyB0aGlzIHByb3BlcnR5LiBFeGFtcGxlOiBgWzEsIC41LCAuNSwgMV1gID0gcGlua1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmVtdWx0aXBseUFscGhhXSBXaGV0aGVyIG9yIG5vdCB0byBwcmVtdWx0aXBseSBhbHBoYS4gRGVmYXVsdHMgdG8gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgc2V0dGluZyBpcy5cbiAqICAgICBUaGlzIGxldHMgeW91IHNldCBpdCBvbmNlIGJlZm9yZSBjYWxsaW5nIGB0d2dsLmNyZWF0ZVRleHR1cmVgIG9yIGB0d2dsLmNyZWF0ZVRleHR1cmVzYCBhbmQgb25seSBvdmVycmlkZVxuICogICAgIHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIHNwZWNpZmljIHRleHR1cmVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmbGlwWV0gV2hldGhlciBvciBub3QgdG8gZmxpcCB0aGUgdGV4dHVyZSB2ZXJ0aWNhbGx5IG9uIHVwbG9hZC4gRGVmYXVsdHMgdG8gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgc2V0dGluZyBpcy5cbiAqICAgICBUaGlzIGxldHMgeW91IHNldCBpdCBvbmNlIGJlZm9yZSBjYWxsaW5nIGB0d2dsLmNyZWF0ZVRleHR1cmVgIG9yIGB0d2dsLmNyZWF0ZVRleHR1cmVzYCBhbmQgb25seSBvdmVycmlkZVxuICogICAgIHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIHNwZWNpZmljIHRleHR1cmVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb2xvcnNwYWNlQ29udmVyc2lvbl0gV2hldGhlciBvciBub3QgdG8gbGV0IHRoZSBicm93c2VyIGRvIGNvbG9yc3BhY2UgY29udmVyc2lvbiBvZiB0aGUgdGV4dHVyZSBvbiB1cGxvYWQuIERlZmF1bHRzIHRvIHdoYXRldmVyIHRoZSBjdXJyZW50IHNldHRpbmcgaXMuXG4gKiAgICAgVGhpcyBsZXRzIHlvdSBzZXQgaXQgb25jZSBiZWZvcmUgY2FsbGluZyBgdHdnbC5jcmVhdGVUZXh0dXJlYCBvciBgdHdnbC5jcmVhdGVUZXh0dXJlc2AgYW5kIG9ubHkgb3ZlcnJpZGVcbiAqICAgICB0aGUgY3VycmVudCBzZXR0aW5nIGZvciBzcGVjaWZpYyB0ZXh0dXJlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F1dG9dIElmIGB1bmRlZmluZWRgIG9yIGB0cnVlYCwgaW4gV2ViR0wxLCB0ZXh0dXJlIGZpbHRlcmluZyBpcyBzZXQgYXV0b21hdGljYWxseSBmb3Igbm9uLXBvd2VyIG9mIDIgaW1hZ2VzIGFuZFxuICogICAgbWlwcyBhcmUgZ2VuZXJhdGVkIGZvciBwb3dlciBvZiAyIGltYWdlcy4gSW4gV2ViR0wyIG1pcHMgYXJlIGdlbmVyYXRlZCBpZiB0aGV5IGNhbiBiZS4gTm90ZTogaWYgYGxldmVsYCBpcyBzZXQgYWJvdmVcbiAqICAgIHRoZW4gdGhlbiBgYXV0b2AgaXMgYXNzdW1lZCB0byBiZSBgZmFsc2VgIHVubGVzcyBleHBsaWNpdHkgc2V0IHRvIGB0cnVlYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IFtjdWJlRmFjZU9yZGVyXSBUaGUgb3JkZXIgdGhhdCBjdWJlIGZhY2VzIGFyZSBwdWxsZWQgb3V0IG9mIGFuIGltZyBvciBzZXQgb2YgaW1hZ2VzLiBUaGUgZGVmYXVsdCBpc1xuICpcbiAqICAgICBbZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSxcbiAqICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl1cbiAqXG4gKiBAcHJvcGVydHkgeyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8VGV4SW1hZ2VTb3VyY2V8VGV4SW1hZ2VTb3VyY2VbXXxzdHJpbmd8c3RyaW5nW118bW9kdWxlOnR3Z2wuVGV4dHVyZUZ1bmMpfSBbc3JjXSBzb3VyY2UgZm9yIHRleHR1cmVcbiAqXG4gKiAgICBJZiBgc3RyaW5nYCB0aGVuIGl0J3MgYXNzdW1lZCB0byBiZSBhIFVSTCB0byBhbiBpbWFnZS4gVGhlIGltYWdlIHdpbGwgYmUgZG93bmxvYWRlZCBhc3luYy4gQSB1c2FibGVcbiAqICAgIDF4MSBwaXhlbCB0ZXh0dXJlIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkuIFRoZSB0ZXh0dXJlIHdpbGwgYmUgdXBkYXRlZCBvbmNlIHRoZSBpbWFnZSBoYXMgZG93bmxvYWRlZC5cbiAqICAgIElmIGB0YXJnZXRgIGlzIGBnbC5URVhUVVJFX0NVQkVfTUFQYCB3aWxsIGF0dGVtcHQgdG8gZGl2aWRlIGltYWdlIGludG8gNiBzcXVhcmUgcGllY2VzLiAxeDYsIDZ4MSwgM3gyLCAyeDMuXG4gKiAgICBUaGUgcGllY2VzIHdpbGwgYmUgdXBsb2FkZWQgaW4gYGN1YmVGYWNlT3JkZXJgXG4gKlxuICogICAgSWYgYHN0cmluZ1tdYCBvciBgVGV4SW1hZ2VTb3VyY2VbXWAgYW5kIHRhcmdldCBpcyBgZ2wuVEVYVFVSRV9DVUJFX01BUGAgdGhlbiBpdCBtdXN0IGhhdmUgNiBlbnRyaWVzLCBvbmUgZm9yIGVhY2ggZmFjZSBvZiBhIGN1YmUgbWFwLlxuICpcbiAqICAgIElmIGBzdHJpbmdbXWAgb3IgYFRleEltYWdlU291cmNlW11gIGFuZCB0YXJnZXQgaXMgYGdsLlRFWFRVUkVfMkRfQVJSQVlgIHRoZW4gZWFjaCBlbnRyeSBpcyBhIHNsaWNlIG9mIHRoZSBhIDJkIGFycmF5IHRleHR1cmVcbiAqICAgIGFuZCB3aWxsIGJlIHNjYWxlZCB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQgT1IgdG8gdGhlIHNpemUgb2YgdGhlIGZpcnN0IGltYWdlIHRoYXQgbG9hZHMuXG4gKlxuICogICAgSWYgYFRleEltYWdlU291cmNlYCB0aGVuIGl0IHdpbCBiZSB1c2VkIGltbWVkaWF0ZWx5IHRvIGNyZWF0ZSB0aGUgY29udGVudHMgb2YgdGhlIHRleHR1cmUuIEV4YW1wbGVzIGBIVE1MSW1hZ2VFbGVtZW50YCxcbiAqICAgIGBIVE1MQ2FudmFzRWxlbWVudGAsIGBIVE1MVmlkZW9FbGVtZW50YC5cbiAqXG4gKiAgICBJZiBgbnVtYmVyW11gIG9yIGBBcnJheUJ1ZmZlclZpZXdgIGl0J3MgYXNzdW1lZCB0byBiZSBkYXRhIGZvciBhIHRleHR1cmUuIElmIGB3aWR0aGAgb3IgYGhlaWdodGAgaXNcbiAqICAgIG5vdCBzcGVjaWZpZWQgaXQgaXMgZ3Vlc3NlZCBhcyBmb2xsb3dzLiBGaXJzdCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIGNvbXB1dGVkIGJ5IGBzcmMubGVuZ3RoIC8gbnVtQ29tcG9uZW50c2BcbiAqICAgIHdoZXJlIGBudW1Db21wb25lbnRzYCBpcyBkZXJpdmVkIGZyb20gYGZvcm1hdGAuIElmIGB0YXJnZXRgIGlzIGBnbC5URVhUVVJFX0NVQkVfTUFQYCB0aGVuIGBudW1FbGVtZW50c2AgaXMgZGl2aWRlZFxuICogICAgYnkgNi4gVGhlblxuICpcbiAqICAgICogICBJZiBuZWl0aGVyIGB3aWR0aGAgbm9yIGBoZWlnaHRgIGFyZSBzcGVjaWZpZWQgYW5kIGBzcXJ0KG51bUVsZW1lbnRzKWAgaXMgYW4gaW50ZWdlciB0aGVuIHdpZHRoIGFuZCBoZWlnaHRcbiAqICAgICAgICBhcmUgc2V0IHRvIGBzcXJ0KG51bUVsZW1lbnRzKWAuIE90aGVyd2lzZSBgd2lkdGggPSBudW1FbGVtZW50c2AgYW5kIGBoZWlnaHQgPSAxYC5cbiAqXG4gKiAgICAqICAgSWYgb25seSBvbmUgb2YgYHdpZHRoYCBvciBgaGVpZ2h0YCBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgb3RoZXIgZXF1YWxzIGBudW1FbGVtZW50cyAvIHNwZWNpZmllZERpbWVuc2lvbmAuXG4gKlxuICogSWYgYG51bWJlcltdYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBgdHlwZWAuXG4gKlxuICogSWYgYHNyY2AgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgYFdlYkdMUmVuZGVyaW5nQ29udGV4dGAgYW5kIHRoZXNlIG9wdGlvbnMuXG4gKiBXaGF0ZXZlciBpdCByZXR1cm5zIGlzIHN1YmplY3QgdG8gdGhlc2UgcnVsZXMuIFNvIGl0IGNhbiByZXR1cm4gYSBzdHJpbmcgdXJsLCBhbiBgSFRNTEVsZW1lbnRgXG4gKiBhbiBhcnJheSBldGMuLi5cbiAqXG4gKiBJZiBgc3JjYCBpcyB1bmRlZmluZWQgdGhlbiBhbiBlbXB0eSB0ZXh0dXJlIHdpbGwgYmUgY3JlYXRlZCBvZiBzaXplIGB3aWR0aGAgYnkgYGhlaWdodGAuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjcm9zc09yaWdpbl0gV2hhdCB0byBzZXQgdGhlIGNyb3NzT3JpZ2luIHByb3BlcnR5IG9mIGltYWdlcyB3aGVuIHRoZXkgYXJlIGRvd25sb2FkZWQuXG4gKiAgICBkZWZhdWx0OiB1bmRlZmluZWQuIEFsc28gc2VlIHtAbGluayBtb2R1bGU6dHdnbC5zZXREZWZhdWx0c30uXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBTZXRzIGFueSBwYWNraW5nIHN0YXRlIHRoYXQgd2lsbCBiZSBzZXQgYmFzZWQgb24gdGhlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0UGFja1N0YXRlKGdsLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmNvbG9yc3BhY2VDb252ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBvcHRpb25zLmNvbG9yc3BhY2VDb252ZXJzaW9uKTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVtdWx0aXBseUFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZmxpcFkgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19GTElQX1lfV0VCR0wsIG9wdGlvbnMuZmxpcFkpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IHNraXAgc3RhdGUgdG8gZGVmYXVsdHNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRTa2lwU3RhdGVUb0RlZmF1bHQoZ2wpIHtcbiAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0FMSUdOTUVOVCwgNCk7XG4gIGlmIChpc1dlYkdMMihnbCkpIHtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfUk9XX0xFTkdUSCwgMCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0lNQUdFX0hFSUdIVCwgMCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1NLSVBfUElYRUxTLCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9ST1dTLCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9JTUFHRVMsIDApO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgcGFyYW1ldGVycyBvZiBhIHRleHR1cmUgb3Igc2FtcGxlclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfFdlYkdMU2FtcGxlcn0gdGFyZ2V0IHRleHR1cmUgdGFyZ2V0IG9yIHNhbXBsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW1ldGVyaUZuIHRleFBhcmFtZXRlcmkgb3Igc2FtcGxlclBhcmFtZXRlcmkgZm5cbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFRleHR1cmVTYW1wbGVyUGFyYW1ldGVycyhnbCwgdGFyZ2V0LCBwYXJhbWV0ZXJpRm4sIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubWluTWFnKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NSU5fRklMVEVSLCBvcHRpb25zLm1pbk1hZyk7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQUdfRklMVEVSLCBvcHRpb25zLm1pbk1hZyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWluKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NSU5fRklMVEVSLCBvcHRpb25zLm1pbik7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWFnKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQUdfRklMVEVSLCBvcHRpb25zLm1hZyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMud3JhcCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9TLCBvcHRpb25zLndyYXApO1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9ULCBvcHRpb25zLndyYXApO1xuICAgIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfM0QkMSB8fCBpc1NhbXBsZXIoZ2wsIHRhcmdldCkpIHtcbiAgICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9SLCBvcHRpb25zLndyYXApO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy53cmFwUikge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9SLCBvcHRpb25zLndyYXBSKTtcbiAgfVxuICBpZiAob3B0aW9ucy53cmFwUykge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9TLCBvcHRpb25zLndyYXBTKTtcbiAgfVxuICBpZiAob3B0aW9ucy53cmFwVCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9ULCBvcHRpb25zLndyYXBUKTtcbiAgfVxuICBpZiAob3B0aW9ucy5taW5Mb2QgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfTUlOX0xPRCwgb3B0aW9ucy5taW5Mb2QpO1xuICB9XG4gIGlmIChvcHRpb25zLm1heExvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQVhfTE9ELCBvcHRpb25zLm1heExvZCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYmFzZUxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX0JBU0VfTEVWRUwsIG9wdGlvbnMuYmFzZUxldmVsKTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXhMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9NQVhfTEVWRUwsIG9wdGlvbnMubWF4TGV2ZWwpO1xuICB9XG4gIGlmIChvcHRpb25zLmNvbXBhcmVGdW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX0NPTVBBUkVfRlVOQywgb3B0aW9ucy5jb21wYXJlRnVuYyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY29tcGFyZU1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfQ09NUEFSRV9NT0RFLCBvcHRpb25zLmNvbXBhcmVNb2RlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHRleHR1cmUgcGFyYW1ldGVycyBvZiBhIHRleHR1cmUuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKGdsLCB0ZXgsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRCQyO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIHNldFRleHR1cmVTYW1wbGVyUGFyYW1ldGVycyhnbCwgdGFyZ2V0LCBnbC50ZXhQYXJhbWV0ZXJpLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzYW1wbGVyIHBhcmFtZXRlcnMgb2YgYSBzYW1wbGVyLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xTYW1wbGVyfSBzYW1wbGVyIHRoZSBXZWJHTFNhbXBsZXIgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuZnVuY3Rpb24gc2V0U2FtcGxlclBhcmFtZXRlcnMoZ2wsIHNhbXBsZXIsIG9wdGlvbnMpIHtcbiAgc2V0VGV4dHVyZVNhbXBsZXJQYXJhbWV0ZXJzKGdsLCBzYW1wbGVyLCBnbC5zYW1wbGVyUGFyYW1ldGVyaSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzYW1wbGVyIG9iamVjdCBhbmQgc2V0cyBwYXJhbWV0ZXJzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzYW1wbGVyID0gdHdnbC5jcmVhdGVTYW1wbGVyKGdsLCB7XG4gKiAgICAgICAgbWluTWFnOiBnbC5ORUFSRVNULCAgICAgICAgIC8vIHNldHMgYm90aCBURVhUVVJFX01JTl9GSUxURVIgYW5kIFRFWFRVUkVfTUFHX0ZJTFRFUlxuICogICAgICAgIHdyYXA6IGdsLkNMQU1QX1RPX05FQVJFU1QsICAvLyBzZXRzIGJvdGggVEVYVFVSRV9XUkFQX1MgYW5kIFRFWFRVUkVfV1JBUF9UIGFuZCBURVhUVVJFX1dSQVBfUlxuICogICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9ucz59IG9wdGlvbnMgQSBvYmplY3Qgb2YgVGV4dHVyZU9wdGlvbnMgb25lIHBlciBzYW1wbGVyLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsV2ViR0xTYW1wbGVyPn0gdGhlIGNyZWF0ZWQgc2FtcGxlcnMgYnkgbmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2FtcGxlcihnbCwgb3B0aW9ucykge1xuICBjb25zdCBzYW1wbGVyID0gZ2wuY3JlYXRlU2FtcGxlcigpO1xuICBzZXRTYW1wbGVyUGFyYW1ldGVycyhnbCwgc2FtcGxlciwgb3B0aW9ucyk7XG4gIHJldHVybiBzYW1wbGVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtdWx0aXBsZSBzYW1wbGVyIG9iamVjdHMgYW5kIHNldHMgcGFyYW1ldGVycyBvbiBlYWNoLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzYW1wbGVycyA9IHR3Z2wuY3JlYXRlU2FtcGxlcnMoZ2wsIHtcbiAqICAgICAgICBuZWFyZXN0OiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBuZWFyZXN0Q2xhbXBTOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgICB3cmFwUzogZ2wuQ0xBTVBfVE9fTkVBUkVTVCxcbiAqICAgICAgICB9LFxuICogICAgICAgIGxpbmVhcjoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBuZWFyZXN0Q2xhbXA6IHtcbiAqICAgICAgICAgIG1pbk1hZzogZ2wuTkVBUkVTVCxcbiAqICAgICAgICAgIHdyYXA6IGdsLkNMQU1QX1RPX0VER0UsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBsaW5lYXJDbGFtcDoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgICB3cmFwOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgICAgbGluZWFyQ2xhbXBUOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLkxJTkVBUixcbiAqICAgICAgICAgIHdyYXBUOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldCBvbiB0aGUgc2FtcGxlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2FtcGxlcnMoZ2wsIHNhbXBsZXJPcHRpb25zKSB7XG4gIGNvbnN0IHNhbXBsZXJzID0ge307XG4gIE9iamVjdC5rZXlzKHNhbXBsZXJPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBzYW1wbGVyc1tuYW1lXSA9IGNyZWF0ZVNhbXBsZXIoZ2wsIHNhbXBsZXJPcHRpb25zW25hbWVdKTtcbiAgfSk7XG4gIHJldHVybiBzYW1wbGVycztcbn1cblxuLyoqXG4gKiBNYWtlcyBhIDF4MSBwaXhlbFxuICogSWYgbm8gY29sb3IgaXMgcGFzc2VkIGluIHVzZXMgdGhlIGRlZmF1bHQgY29sb3Igd2hpY2ggY2FuIGJlIHNldCBieSBjYWxsaW5nIGBzZXREZWZhdWx0VGV4dHVyZUNvbG9yYC5cbiAqIEBwYXJhbSB7KG51bWJlcltdfEFycmF5QnVmZmVyVmlldyl9IFtjb2xvcl0gVGhlIGNvbG9yIHVzaW5nIDAtMSB2YWx1ZXNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IFVuaXQ4QXJyYXkgd2l0aCBjb2xvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2UxUGl4ZWwoY29sb3IpIHtcbiAgY29sb3IgPSBjb2xvciB8fCBkZWZhdWx0cyQxLnRleHR1cmVDb2xvcjtcbiAgaWYgKGlzQXJyYXlCdWZmZXIoY29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShbY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSwgY29sb3JbM10gKiAyNTVdKTtcbn1cblxuLyoqXG4gKiBTZXRzIGZpbHRlcmluZyBvciBnZW5lcmF0ZXMgbWlwcyBmb3IgdGV4dHVyZSBiYXNlZCBvbiB3aWR0aCBvciBoZWlnaHRcbiAqIElmIHdpZHRoIG9yIGhlaWdodCBpcyBub3QgcGFzc2VkIGluIHVzZXMgYG9wdGlvbnMud2lkdGhgIGFuZC8vb3IgYG9wdGlvbnMuaGVpZ2h0YFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIHdpZHRoIG9mIHRleHR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSBoZWlnaHQgb2YgdGV4dHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlcm5hbEZvcm1hdF0gVGhlIGludGVybmFsRm9ybWF0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxLnRleHR1cmVPcHRpb25zO1xuICBpbnRlcm5hbEZvcm1hdCA9IGludGVybmFsRm9ybWF0IHx8IFJHQkEkMTtcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRCQyO1xuICB3aWR0aCA9IHdpZHRoIHx8IG9wdGlvbnMud2lkdGg7XG4gIGhlaWdodCA9IGhlaWdodCB8fCBvcHRpb25zLmhlaWdodDtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICBpZiAoY2FuR2VuZXJhdGVNaXBtYXAoZ2wsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0KSkge1xuICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlsdGVyaW5nID0gY2FuRmlsdGVyKGludGVybmFsRm9ybWF0KSA/IExJTkVBUiQxIDogTkVBUkVTVDtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJpbmcpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX01BR19GSUxURVIsIGZpbHRlcmluZyk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIFRFWFRVUkVfV1JBUF9TLCBDTEFNUF9UT19FREdFJDEpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX1dSQVBfVCwgQ0xBTVBfVE9fRURHRSQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5hdXRvID09PSB0cnVlIHx8IChvcHRpb25zLmF1dG8gPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEdldHMgYW4gYXJyYXkgb2YgY3ViZW1hcCBmYWNlIGVudW1zXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQHJldHVybiB7bnVtYmVyW119IGN1YmVtYXAgZmFjZSBlbnVtc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q3ViZUZhY2VPcmRlcihnbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIG9wdGlvbnMuY3ViZUZhY2VPcmRlciB8fCBbXG4gICAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsXG4gICAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsXG4gICAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksXG4gICAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksXG4gICAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osXG4gICAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1osXG4gICAgXTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGYWNlSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZhY2UgZ2wgZW51bSBmb3IgdGV4SW1hZ2UyRFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5keCBmYWNlIGluZGV4ICgwIC0gNSkgaW50byBzb3VyY2UgZGF0YVxuICogQGlnbm9yZVxuICovXG5cbi8qKlxuICogR2V0cyBhbiBhcnJheSBvZiBGYWNlSW5mb3NcbiAqIFRoZXJlJ3MgYSBidWcgaW4gc29tZSBOVmlkaWEgZHJpdmVycyB0aGF0IHdpbGwgY3Jhc2ggdGhlIGRyaXZlciBpZlxuICogYGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWGAgaXMgbm90IHVwbG9hZGVkIGZpcnN0LiBTbywgd2UgdGFrZVxuICogdGhlIHVzZXIncyBkZXNpcmVkIG9yZGVyIGZyb20gaGlzIGZhY2VzIHRvIFdlYkdMIGFuZCBtYWtlIHN1cmUgd2VcbiAqIGRvIHRoZSBmYWNlcyBpbiBXZWJHTCBvcmRlclxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcmV0dXJuIHtGYWNlSW5mb1tdfSBjdWJlbWFwIGZhY2UgaW5mb3MuIEFyZ3VhYmx5IHRoZSBgZmFjZWAgcHJvcGVydHkgb2YgZWFjaCBlbGVtZW50IGlzIHJlZHVuZGFudCBidXRcbiAqICAgIGl0J3MgbmVlZGVkIGludGVybmFsbHkgdG8gc29ydCB0aGUgYXJyYXkgb2YgYG5keGAgcHJvcGVydGllcyBieSBgZmFjZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRDdWJlRmFjZXNXaXRoTmR4KGdsLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZhY2VzID0gZ2V0Q3ViZUZhY2VPcmRlcihnbCwgb3B0aW9ucyk7XG4gIC8vIHdvcmsgYXJvdW5kIGJ1ZyBpbiBOVmlkaWEgZHJpdmVycy4gV2UgaGF2ZSB0byB1cGxvYWQgdGhlIGZpcnN0IGZhY2UgZmlyc3QgZWxzZSB0aGUgZHJpdmVyIGNyYXNoZXMgOihcbiAgY29uc3QgZmFjZXNXaXRoTmR4ID0gZmFjZXMubWFwKGZ1bmN0aW9uKGZhY2UsIG5keCkge1xuICAgIHJldHVybiB7IGZhY2U6IGZhY2UsIG5keDogbmR4IH07XG4gIH0pO1xuICBmYWNlc1dpdGhOZHguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmFjZSAtIGIuZmFjZTtcbiAgfSk7XG4gIHJldHVybiBmYWNlc1dpdGhOZHg7XG59XG5cbi8qKlxuICogU2V0IGEgdGV4dHVyZSBmcm9tIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LiBXaWxsIGFsc28gc2V0XG4gKiB0ZXh0dXJlIGZpbHRlcmluZyBvciBnZW5lcmF0ZSBtaXBzIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBlbGVtZW50XG4gKiB1bmxlc3MgYG9wdGlvbnMuYXV0byA9PT0gZmFsc2VgLiBJZiBgdGFyZ2V0ID09PSBnbC5URVhUVVJFX0NVQkVfTUFQYCB3aWxsXG4gKiBhdHRlbXB0IHRvIHNsaWNlIGltYWdlIGludG8gMXg2LCAyeDMsIDN4Miwgb3IgNngxIGltYWdlcywgb25lIGZvciBlYWNoIGZhY2UuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBhIGNhbnZhcywgaW1nLCBvciB2aWRlbyBlbGVtZW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqIEBraW5kIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHNldFRleHR1cmVGcm9tRWxlbWVudChnbCwgdGV4LCBlbGVtZW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDEudGV4dHVyZU9wdGlvbnM7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQkMjtcbiAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IDA7XG4gIGxldCB3aWR0aCA9IGVsZW1lbnQud2lkdGg7XG4gIGxldCBoZWlnaHQgPSBlbGVtZW50LmhlaWdodDtcbiAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IFJHQkEkMTtcbiAgY29uc3QgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlIHx8IGZvcm1hdFR5cGUudHlwZTtcbiAgc2V0UGFja1N0YXRlKGdsLCBvcHRpb25zKTtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQJDEpIHtcbiAgICAvLyBndWVzcyB0aGUgcGFydHNcbiAgICBjb25zdCBpbWdXaWR0aCAgPSBlbGVtZW50LndpZHRoO1xuICAgIGNvbnN0IGltZ0hlaWdodCA9IGVsZW1lbnQuaGVpZ2h0O1xuICAgIGxldCBzaXplO1xuICAgIGxldCBzbGljZXM7XG4gICAgaWYgKGltZ1dpZHRoIC8gNiA9PT0gaW1nSGVpZ2h0KSB7XG4gICAgICAvLyBJdCdzIDZ4MVxuICAgICAgc2l6ZSA9IGltZ0hlaWdodDtcbiAgICAgIHNsaWNlcyA9IFswLCAwLCAxLCAwLCAyLCAwLCAzLCAwLCA0LCAwLCA1LCAwXTtcbiAgICB9IGVsc2UgaWYgKGltZ0hlaWdodCAvIDYgPT09IGltZ1dpZHRoKSB7XG4gICAgICAvLyBJdCdzIDF4NlxuICAgICAgc2l6ZSA9IGltZ1dpZHRoO1xuICAgICAgc2xpY2VzID0gWzAsIDAsIDAsIDEsIDAsIDIsIDAsIDMsIDAsIDQsIDAsIDVdO1xuICAgIH0gZWxzZSBpZiAoaW1nV2lkdGggLyAzID09PSBpbWdIZWlnaHQgLyAyKSB7XG4gICAgICAvLyBJdCdzIDN4MlxuICAgICAgc2l6ZSA9IGltZ1dpZHRoIC8gMztcbiAgICAgIHNsaWNlcyA9IFswLCAwLCAxLCAwLCAyLCAwLCAwLCAxLCAxLCAxLCAyLCAxXTtcbiAgICB9IGVsc2UgaWYgKGltZ1dpZHRoIC8gMiA9PT0gaW1nSGVpZ2h0IC8gMykge1xuICAgICAgLy8gSXQncyAyeDNcbiAgICAgIHNpemUgPSBpbWdXaWR0aCAvIDI7XG4gICAgICBzbGljZXMgPSBbMCwgMCwgMSwgMCwgMCwgMSwgMSwgMSwgMCwgMiwgMSwgMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiY2FuJ3QgZmlndXJlIG91dCBjdWJlIG1hcCBmcm9tIGVsZW1lbnQ6IFwiICsgKGVsZW1lbnQuc3JjID8gZWxlbWVudC5zcmMgOiBlbGVtZW50Lm5vZGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gZ2V0U2hhcmVkMkRDb250ZXh0KCk7XG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IHNpemU7XG4gICAgICBjdHguY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgZ2V0Q3ViZUZhY2VzV2l0aE5keChnbCwgb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgIGNvbnN0IHhPZmZzZXQgPSBzbGljZXNbZi5uZHggKiAyICsgMF0gKiBzaXplO1xuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gc2xpY2VzW2YubmR4ICogMiArIDFdICogc2l6ZTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShlbGVtZW50LCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBzaXplLCAwLCAwLCBzaXplLCBzaXplKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChmLmZhY2UsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBjdHguY2FudmFzKTtcbiAgICAgIH0pO1xuICAgICAgLy8gRnJlZSB1cCB0aGUgY2FudmFzIG1lbW9yeVxuICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IDE7XG4gICAgICBjdHguY2FudmFzLmhlaWdodCA9IDE7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBOT1RFOiBJdCBzZWVtcyBsaWtlIHdlIHNob3VsZCBwcmVmZXIgSW1hZ2VCaXRtYXAgYmVjYXVzZSB1bmxpa2UgY2FudmFzIGl0J3NcbiAgICAgIC8vIG5vdGUgbG9zc3k/IChhbHBoYSBpcyBub3QgcHJlbXVsdGlwbGllZD8gYWx0aG91Z2ggSSdtIG5vdCBzdXJlIHdoYXRcbiAgICAgIHdpZHRoID0gc2l6ZTtcbiAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgICBnZXRDdWJlRmFjZXNXaXRoTmR4KGdsLCBvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAwXSAqIHNpemU7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSBzbGljZXNbZi5uZHggKiAyICsgMV0gKiBzaXplO1xuICAgICAgICAvLyBXZSBjYW4ndCBlYXNpbHkgdXNlIGEgZGVmYXVsdCB0ZXh0dXJlIGNvbG9yIGhlcmUgYXMgaXQgd291bGQgaGF2ZSB0byBtYXRjaFxuICAgICAgICAvLyB0aGUgdHlwZSBhY3Jvc3MgYWxsIGZhY2VzIHdoZXJlIGFzIHdpdGggYSAyRCBvbmUgdGhlcmUncyBvbmx5IG9uZSBmYWNlXG4gICAgICAgIC8vIHNvIHdlJ3JlIHJlcGxhY2luZyBldmVyeXRoaW5nIGFsbCBhdCBvbmNlLiBJdCBhbHNvIGhhcyB0byBiZSB0aGUgY29ycmVjdCBzaXplLlxuICAgICAgICAvLyBPbiB0aGUgb3RoZXIgaGFuZCB3ZSBuZWVkIGFsbCBmYWNlcyB0byBiZSB0aGUgc2FtZSBzaXplIHNvIGFzIG9uZSBmYWNlIGxvYWRzXG4gICAgICAgIC8vIHRoZSByZXN0IG1hdGNoIGVsc2UgdGhlIHRleHR1cmUgd2lsbCBiZSB1bi1yZW5kZXJhYmxlLlxuICAgICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBzaXplLCBzaXplLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChlbGVtZW50LCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBzaXplLCB7XG4gICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnLFxuICAgICAgICAgIGNvbG9yU3BhY2VDb252ZXJzaW9uOiAnbm9uZScsXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgc2V0UGFja1N0YXRlKGdsLCBvcHRpb25zKTtcbiAgICAgICAgICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChmLmZhY2UsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBpbWFnZUJpdG1hcCk7XG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9tYXRpY2FsbHlTZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShvcHRpb25zKSkge1xuICAgICAgICAgICAgc2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUoZ2wsIHRleCwgb3B0aW9ucywgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEJDEgfHwgdGFyZ2V0ID09PSBURVhUVVJFXzJEX0FSUkFZJDEpIHtcbiAgICBjb25zdCBzbWFsbGVzdCA9IE1hdGgubWluKGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0KTtcbiAgICBjb25zdCBsYXJnZXN0ID0gTWF0aC5tYXgoZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQpO1xuICAgIGNvbnN0IGRlcHRoID0gbGFyZ2VzdCAvIHNtYWxsZXN0O1xuICAgIGlmIChkZXB0aCAlIDEgIT09IDApIHtcbiAgICAgIHRocm93IFwiY2FuIG5vdCBjb21wdXRlIDNEIGRpbWVuc2lvbnMgb2YgZWxlbWVudFwiO1xuICAgIH1cbiAgICBjb25zdCB4TXVsdCA9IGVsZW1lbnQud2lkdGggID09PSBsYXJnZXN0ID8gMSA6IDA7XG4gICAgY29uc3QgeU11bHQgPSBlbGVtZW50LmhlaWdodCA9PT0gbGFyZ2VzdCA/IDEgOiAwO1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19BTElHTk1FTlQsIDEpO1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19ST1dfTEVOR1RILCBlbGVtZW50LndpZHRoKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfSU1BR0VfSEVJR0hULCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9JTUFHRVMsIDApO1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHNtYWxsZXN0LCBzbWFsbGVzdCwgc21hbGxlc3QsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkZXB0aDsgKytkKSB7XG4gICAgICBjb25zdCBzcmNYID0gZCAqIHNtYWxsZXN0ICogeE11bHQ7XG4gICAgICBjb25zdCBzcmNZID0gZCAqIHNtYWxsZXN0ICogeU11bHQ7XG4gICAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9QSVhFTFMsIHNyY1gpO1xuICAgICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1NLSVBfUk9XUywgc3JjWSk7XG4gICAgICBnbC50ZXhTdWJJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIDAsIDAsIGQsIHNtYWxsZXN0LCBzbWFsbGVzdCwgMSwgZm9ybWF0LCB0eXBlLCBlbGVtZW50KTtcbiAgICB9XG4gICAgc2V0U2tpcFN0YXRlVG9EZWZhdWx0KGdsKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpO1xuICB9XG4gIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCk7XG4gIH1cbiAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoZ2wsIHRleCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVybCdzIG9yaWdpbiBpcyB0aGUgc2FtZSBzbyB0aGF0IHdlIGNhbiBzZXQgdGhlIGBjcm9zc09yaWdpbmBcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdXJsIHRvIGltYWdlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgd2luZG93J3Mgb3JpZ2luIGlzIHRoZSBzYW1lIGFzIGltYWdlJ3MgdXJsXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cmxJc1NhbWVPcmlnaW4odXJsKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gZm9yIElFIHJlYWxseVxuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5ocmVmID0gdXJsO1xuICAgIHJldHVybiBhLmhvc3RuYW1lID09PSBsb2NhdGlvbi5ob3N0bmFtZSAmJlxuICAgICAgICAgICBhLnBvcnQgICAgID09PSBsb2NhdGlvbi5wb3J0ICYmXG4gICAgICAgICAgIGEucHJvdG9jb2wgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxvY2FsT3JpZ2luID0gKG5ldyBVUkwobG9jYXRpb24uaHJlZikpLm9yaWdpbjtcbiAgICBjb25zdCB1cmxPcmlnaW4gPSAobmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpKS5vcmlnaW47XG4gICAgcmV0dXJuIHVybE9yaWdpbiA9PT0gbG9jYWxPcmlnaW47XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VG9Bbm9ueW1vdXNJZlVuZGVmaW5lZEFuZFVSTElzTm90U2FtZU9yaWdpbih1cmwsIGNyb3NzT3JpZ2luKSB7XG4gIHJldHVybiBjcm9zc09yaWdpbiA9PT0gdW5kZWZpbmVkICYmICF1cmxJc1NhbWVPcmlnaW4odXJsKVxuICAgICA/ICdhbm9ueW1vdXMnXG4gICAgIDogY3Jvc3NPcmlnaW47XG59XG5cbi8qKlxuICogTG9hZHMgYW4gaW1hZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdXJsIHRvIGltYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gY3Jvc3NPcmlnaW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyLCBpbWcpfSBbY2FsbGJhY2tdIGEgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCBhbiBlcnJvciBhbmQgdGhlIGltYWdlLiBUaGUgZXJyb3Igd2lsbCBiZSBub24tbnVsbFxuICogICAgIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gdGhlIGltYWdlIGJlaW5nIGxvYWRlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwsIGNyb3NzT3JpZ2luLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIGxldCBpbWc7XG4gIGNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IGNyb3NzT3JpZ2luIDogZGVmYXVsdHMkMS5jcm9zc09yaWdpbjtcbiAgY3Jvc3NPcmlnaW4gPSBzZXRUb0Fub255bW91c0lmVW5kZWZpbmVkQW5kVVJMSXNOb3RTYW1lT3JpZ2luKHVybCwgY3Jvc3NPcmlnaW4pO1xuICBpZiAodHlwZW9mIEltYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGlmIChjcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9XG5cbiAgICBjb25zdCBjbGVhckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGltZy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGltZyA9IG51bGw7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgY29uc3QgbXNnID0gXCJjb3VsZG4ndCBsb2FkIGltYWdlOiBcIiArIHVybDtcbiAgICAgIGVycm9yJDEobXNnKTtcbiAgICAgIGNhbGxiYWNrKG1zZywgaW1nKTtcbiAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkxvYWQgPSBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBpbWcpO1xuICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfTtcblxuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBpbWcuc3JjID0gdXJsO1xuICAgIHJldHVybiBpbWc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxldCBlcnI7XG4gICAgbGV0IGJtO1xuICAgIGNvbnN0IGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIGJtKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgb3B0aW9ucy5tb2RlID0gJ2NvcnMnOyAvLyBUT0RPOiBub3Qgc3VyZSBob3cgdG8gdHJhbnNsYXRlIGltYWdlLmNyb3NzT3JpZ2luXG4gICAgfVxuICAgIGZldGNoKHVybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbihibG9iKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYiwge1xuICAgICAgICBwcmVtdWx0aXBseUFscGhhOiAnbm9uZScsXG4gICAgICAgIGNvbG9yU3BhY2VDb252ZXJzaW9uOiAnbm9uZScsXG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKGJpdG1hcCkge1xuICAgICAgLy8gbm90IHN1cmUgaWYgdGhpcyB3b3Jrcy4gV2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gY2F0Y2ggdGhlIHVzZXIncyBlcnJvci4gU28sIGNhbGxcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBpbiBhIHRpbWVvdXQgc28gd2UncmVcbiAgICAgIC8vIG5vdCBpbiB0aGlzIHNjb3BlIGluc2lkZSB0aGUgcHJvbWlzZS5cbiAgICAgIGJtID0gYml0bWFwO1xuICAgICAgc2V0VGltZW91dChjYik7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgZXJyID0gZTtcbiAgICAgIHNldFRpbWVvdXQoY2IpO1xuICAgIH0pO1xuICAgIGltZyA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGltZztcbn1cblxuLyoqXG4gKiBjaGVjayBpZiBvYmplY3QgaXMgYSBUZXhJbWFnZVNvdXJjZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGEgVGV4SW1hZ2VTb3VyY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVGV4SW1hZ2VTb3VyY2Uob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkgfHxcbiAgICAgICAgICh0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAgJiYgb2JqIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB8fFxuICAgICAgICAgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBpZiBvYmogaXMgYW4gVGV4SW1hZ2VTb3VyY2UgdGhlbiBqdXN0XG4gKiB1c2VzIGl0IG90aGVyd2lzZSBpZiBvYmogaXMgYSBzdHJpbmdcbiAqIHRoZW4gbG9hZCBpdCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xUZXhJbWFnZVNvdXJjZX0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3Jvc3NPcmlnaW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyLCBpbWcpfSBbY2FsbGJhY2tdIGEgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCBhbiBlcnJvciBhbmQgdGhlIGltYWdlLiBUaGUgZXJyb3Igd2lsbCBiZSBub24tbnVsbFxuICogICAgIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZEFuZFVzZUltYWdlKG9iaiwgY3Jvc3NPcmlnaW4sIGNhbGxiYWNrKSB7XG4gIGlmIChpc1RleEltYWdlU291cmNlKG9iaikpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgb2JqKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRJbWFnZShvYmosIGNyb3NzT3JpZ2luLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogU2V0cyBhIHRleHR1cmUgdG8gYSAxeDEgcGl4ZWwgY29sb3IuIElmIGBvcHRpb25zLmNvbG9yID09PSBmYWxzZWAgaXMgbm90aGluZyBoYXBwZW5zLiBJZiBpdCdzIG5vdCBzZXRcbiAqIHRoZSBkZWZhdWx0IHRleHR1cmUgY29sb3IgaXMgdXNlZCB3aGljaCBjYW4gYmUgc2V0IGJ5IGNhbGxpbmcgYHNldERlZmF1bHRUZXh0dXJlQ29sb3JgLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IFtvcHRpb25zXSBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRUZXh0dXJlVG8xUGl4ZWxDb2xvcihnbCwgdGV4LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDEudGV4dHVyZU9wdGlvbnM7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQkMjtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICBpZiAob3B0aW9ucy5jb2xvciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gQXNzdW1lIGl0J3MgYSBVUkxcbiAgLy8gUHV0IDF4MSBwaXhlbHMgaW4gdGV4dHVyZS4gVGhhdCBtYWtlcyBpdCByZW5kZXJhYmxlIGltbWVkaWF0ZWx5IHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nLlxuICBjb25zdCBjb2xvciA9IG1ha2UxUGl4ZWwob3B0aW9ucy5jb2xvcik7XG4gIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfQ1VCRV9NQVAkMSkge1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCA2OyArK2lpKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGlpLCAwLCBSR0JBJDEsIDEsIDEsIDAsIFJHQkEkMSwgVU5TSUdORURfQllURSQxLCBjb2xvcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCQxIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSQxKSB7XG4gICAgZ2wudGV4SW1hZ2UzRCh0YXJnZXQsIDAsIFJHQkEkMSwgMSwgMSwgMSwgMCwgUkdCQSQxLCBVTlNJR05FRF9CWVRFJDEsIGNvbG9yKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgMCwgUkdCQSQxLCAxLCAxLCAwLCBSR0JBJDEsIFVOU0lHTkVEX0JZVEUkMSwgY29sb3IpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHNyYyBpbWFnZShzKSB1c2VkIHRvIGNyZWF0ZSBhIHRleHR1cmUuXG4gKlxuICogV2hlbiB5b3UgY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVGV4dHVyZX0gb3Ige0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVRleHR1cmVzfVxuICogeW91IGNhbiBwYXNzIGluIHVybHMgZm9yIGltYWdlcyB0byBsb2FkIGludG8gdGhlIHRleHR1cmVzLiBJZiBpdCdzIGEgc2luZ2xlIHVybFxuICogdGhlbiB0aGlzIHdpbGwgYmUgYSBzaW5nbGUgSFRNTEltYWdlRWxlbWVudC4gSWYgaXQncyBhbiBhcnJheSBvZiB1cmxzIHVzZWQgZm9yIGEgY3ViZW1hcFxuICogdGhpcyB3aWxsIGJlIGEgY29ycmVzcG9uZGluZyBhcnJheSBvZiBpbWFnZXMgZm9yIHRoZSBjdWJlbWFwLlxuICpcbiAqIEB0eXBlZGVmIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnRbXX0gVGV4dHVyZVNyY1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZvciB3aGVuIGFuIGltYWdlIGZpbmlzaGVkIGRvd25sb2FkaW5nIGFuZCBiZWVuIHVwbG9hZGVkIGludG8gYSB0ZXh0dXJlXG4gKiBAY2FsbGJhY2sgVGV4dHVyZVJlYWR5Q2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gZXJyIElmIHRydXRoeSB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZSB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVNyY30gc291cmNlIGltYWdlKHMpIHVzZWQgdG8gYXMgdGhlIHNyYyBmb3IgdGhlIHRleHR1cmVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQSBjYWxsYmFjayBmb3Igd2hlbiBhbGwgaW1hZ2VzIGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byB0aGVpciByZXNwZWN0aXZlIHRleHR1cmVzXG4gKiBAY2FsbGJhY2sgVGV4dHVyZXNSZWFkeUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGVyciBJZiB0cnV0aHkgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgV2ViR0xUZXh0dXJlPn0gdGV4dHVyZXMgdGhlIGNyZWF0ZWQgdGV4dHVyZXMgYnkgbmFtZS4gU2FtZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVGV4dHVyZXN9LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuVGV4dHVyZVNyYz59IHNvdXJjZXMgdGhlIGltYWdlKHMpIHVzZWQgZm9yIHRoZSB0ZXh0dXJlIGJ5IG5hbWUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYW4gaW1hZ2UgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byBhIHRleHR1cmVcbiAqIEBjYWxsYmFjayBDdWJlbWFwUmVhZHlDYWxsYmFja1xuICogQHBhcmFtIHsqfSBlcnIgSWYgdHJ1dGh5IHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIHRleHR1cmUuXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnRbXX0gaW1ncyB0aGUgaW1hZ2VzIGZvciBlYWNoIGZhY2UuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYW4gaW1hZ2UgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byBhIHRleHR1cmVcbiAqIEBjYWxsYmFjayBUaHJlZURSZWFkeUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGVyciBJZiB0cnV0aHkgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudFtdfSBpbWdzIHRoZSBpbWFnZXMgZm9yIGVhY2ggc2xpY2UuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIExvYWRzIGEgdGV4dHVyZSBmcm9tIGFuIGltYWdlIGZyb20gYSBVcmwgYXMgc3BlY2lmaWVkIGluIGBvcHRpb25zLnNyY2BcbiAqIElmIGBvcHRpb25zLmNvbG9yICE9PSBmYWxzZWAgd2lsbCBzZXQgdGhlIHRleHR1cmUgdG8gYSAxeDEgcGl4ZWwgY29sb3Igc28gdGhhdCB0aGUgdGV4dHVyZSBpc1xuICogaW1tZWRpYXRlbHkgdXNlYWJsZS4gSXQgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZSBvbmNlIHRoZSBpbWFnZSBoYXMgZmluaXNoZWRcbiAqIGRvd25sb2FkaW5nLiBGaWx0ZXJpbmcgb3B0aW9ucyB3aWxsIGJlIHNldCBhcyBhcHByb3ByaWF0ZSBmb3IgaW1hZ2UgdW5sZXNzIGBvcHRpb25zLmF1dG8gPT09IGZhbHNlYC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGZpbmlzaGVkIGxvYWRpbmcuIGVyciB3aWxsXG4gKiAgICBiZSBub24gbnVsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSB0aGUgaW1hZ2UgYmVpbmcgZG93bmxvYWRlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBsb2FkVGV4dHVyZUZyb21VcmwoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxLnRleHR1cmVPcHRpb25zO1xuICBzZXRUZXh0dXJlVG8xUGl4ZWxDb2xvcihnbCwgdGV4LCBvcHRpb25zKTtcbiAgLy8gQmVjYXVzZSBpdCdzIGFzeW5jIHdlIG5lZWQgdG8gY29weSB0aGUgb3B0aW9ucy5cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICBjb25zdCBpbWcgPSBsb2FkQW5kVXNlSW1hZ2Uob3B0aW9ucy5zcmMsIG9wdGlvbnMuY3Jvc3NPcmlnaW4sIGZ1bmN0aW9uKGVyciwgaW1nKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCB0ZXgsIGltZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRleHR1cmVGcm9tRWxlbWVudChnbCwgdGV4LCBpbWcsIG9wdGlvbnMpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgdGV4LCBpbWcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbWc7XG59XG5cbi8qKlxuICogTG9hZHMgYSBjdWJlbWFwIGZyb20gNiB1cmxzIG9yIFRleEltYWdlU291cmNlcyBhcyBzcGVjaWZpZWQgaW4gYG9wdGlvbnMuc3JjYC4gV2lsbCBzZXQgdGhlIGN1YmVtYXAgdG8gYSAxeDEgcGl4ZWwgY29sb3JcbiAqIHNvIHRoYXQgaXQgaXMgdXNhYmxlIGltbWVkaWF0ZWx5IHVubGVzcyBgb3B0aW9uLmNvbG9yID09PSBmYWxzZWAuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5DdWJlbWFwUmVhZHlDYWxsYmFja30gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGFsbCB0aGUgaW1hZ2VzIGhhdmUgZmluaXNoZWQgbG9hZGluZy4gZXJyIHdpbGxcbiAqICAgIGJlIG5vbiBudWxsIGlmIHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZEN1YmVtYXBGcm9tVXJscyhnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIGNvbnN0IHVybHMgPSBvcHRpb25zLnNyYztcbiAgaWYgKHVybHMubGVuZ3RoICE9PSA2KSB7XG4gICAgdGhyb3cgXCJ0aGVyZSBtdXN0IGJlIDYgdXJscyBmb3IgYSBjdWJlbWFwXCI7XG4gIH1cbiAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IDA7XG4gIGNvbnN0IGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBJDE7XG4gIGNvbnN0IGZvcm1hdFR5cGUgPSBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpO1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBVTlNJR05FRF9CWVRFJDE7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQkMjtcbiAgaWYgKHRhcmdldCAhPT0gVEVYVFVSRV9DVUJFX01BUCQxKSB7XG4gICAgdGhyb3cgXCJ0YXJnZXQgbXVzdCBiZSBURVhUVVJFX0NVQkVfTUFQXCI7XG4gIH1cbiAgc2V0VGV4dHVyZVRvMVBpeGVsQ29sb3IoZ2wsIHRleCwgb3B0aW9ucyk7XG4gIC8vIEJlY2F1c2UgaXQncyBhc3luYyB3ZSBuZWVkIHRvIGNvcHkgdGhlIG9wdGlvbnMuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgbGV0IG51bVRvTG9hZCA9IDY7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCBmYWNlcyA9IGdldEN1YmVGYWNlT3JkZXIoZ2wsIG9wdGlvbnMpO1xuICBsZXQgaW1nczsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmdW5jdGlvbiB1cGxvYWRJbWcoZmFjZVRhcmdldCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIsIGltZykge1xuICAgICAgLS1udW1Ub0xvYWQ7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW1nLndpZHRoICE9PSBpbWcuaGVpZ2h0KSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJjdWJlbWFwIGZhY2UgaW1nIGlzIG5vdCBhIHNxdWFyZTogXCIgKyBpbWcuc3JjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcblxuICAgICAgICAgIC8vIFNvIGFzc3VtaW5nIHRoaXMgaXMgdGhlIGZpcnN0IGltYWdlIHdlIG5vdyBoYXZlIG9uZSBmYWNlIHRoYXQncyBpbWcgc2l6ZWRcbiAgICAgICAgICAvLyBhbmQgNSBmYWNlcyB0aGF0IGFyZSAxeDEgcGl4ZWwgc28gc2l6ZSB0aGUgb3RoZXIgZmFjZXNcbiAgICAgICAgICBpZiAobnVtVG9Mb2FkID09PSA1KSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIGRlZmF1bHQgb3JkZXJcbiAgICAgICAgICAgIGdldEN1YmVGYWNlT3JkZXIoKS5mb3JFYWNoKGZ1bmN0aW9uKG90aGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICAgIC8vIFNob3VsZCB3ZSByZS11c2UgdGhlIHNhbWUgZmFjZSBvciBhIGNvbG9yP1xuICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKG90aGVyVGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgaW1nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGZhY2VUYXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBpbWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1Ub0xvYWQgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHVuZGVmaW5lZCwgdGV4LCBpbWdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW1ncyA9IHVybHMubWFwKGZ1bmN0aW9uKHVybCwgbmR4KSB7XG4gICAgcmV0dXJuIGxvYWRBbmRVc2VJbWFnZSh1cmwsIG9wdGlvbnMuY3Jvc3NPcmlnaW4sIHVwbG9hZEltZyhmYWNlc1tuZHhdKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIExvYWRzIGEgMmQgYXJyYXkgb3IgM2QgdGV4dHVyZSBmcm9tIHVybHMgT1IgVGV4SW1hZ2VTb3VyY2VzIGFzIHNwZWNpZmllZCBpbiBgb3B0aW9ucy5zcmNgLlxuICogV2lsbCBzZXQgdGhlIHRleHR1cmUgdG8gYSAxeDEgcGl4ZWwgY29sb3JcbiAqIHNvIHRoYXQgaXQgaXMgdXNhYmxlIGltbWVkaWF0ZWx5IHVubGVzcyBgb3B0aW9uLmNvbG9yID09PSBmYWxzZWAuXG4gKlxuICogSWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgaXMgbm90IHNwZWNpZmllZCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZmlyc3RcbiAqIGltYWdlIGxvYWRlZCB3aWxsIGJlIHVzZWQuIE5vdGUgdGhhdCBzaW5jZSBpbWFnZXMgYXJlIGxvYWRlZCBhc3luY1xuICogd2hpY2ggaW1hZ2UgZG93bmxvYWRzIGZpcnN0IGlzIHVua25vd24uXG4gKlxuICogSWYgYW4gaW1hZ2UgaXMgbm90IHRoZSBzYW1lIHNpemUgYXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgaXQgd2lsbCBiZSBzY2FsZWRcbiAqIHRvIHRoYXQgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UaHJlZURSZWFkeUNhbGxiYWNrfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYWxsIHRoZSBpbWFnZXMgaGF2ZSBmaW5pc2hlZCBsb2FkaW5nLiBlcnIgd2lsbFxuICogICAgYmUgbm9uIG51bGwgaWYgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkU2xpY2VzRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICBjb25zdCB1cmxzID0gb3B0aW9ucy5zcmM7XG4gIGNvbnN0IGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBJDE7XG4gIGNvbnN0IGZvcm1hdFR5cGUgPSBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpO1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBVTlNJR05FRF9CWVRFJDE7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkRfQVJSQVkkMTtcbiAgaWYgKHRhcmdldCAhPT0gVEVYVFVSRV8zRCQxICYmIHRhcmdldCAhPT0gVEVYVFVSRV8yRF9BUlJBWSQxKSB7XG4gICAgdGhyb3cgXCJ0YXJnZXQgbXVzdCBiZSBURVhUVVJFXzNEIG9yIFRFWFRVUkVfMkRfQVJSQVlcIjtcbiAgfVxuICBzZXRUZXh0dXJlVG8xUGl4ZWxDb2xvcihnbCwgdGV4LCBvcHRpb25zKTtcbiAgLy8gQmVjYXVzZSBpdCdzIGFzeW5jIHdlIG5lZWQgdG8gY29weSB0aGUgb3B0aW9ucy5cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICBsZXQgbnVtVG9Mb2FkID0gdXJscy5sZW5ndGg7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBsZXQgaW1nczsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IDA7XG4gIGxldCB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gIGxldCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgY29uc3QgZGVwdGggPSB1cmxzLmxlbmd0aDtcbiAgbGV0IGZpcnN0SW1hZ2UgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHVwbG9hZEltZyhzbGljZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIsIGltZykge1xuICAgICAgLS1udW1Ub0xvYWQ7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG5cbiAgICAgICAgaWYgKGZpcnN0SW1hZ2UpIHtcbiAgICAgICAgICBmaXJzdEltYWdlID0gZmFsc2U7XG4gICAgICAgICAgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IGltZy53aWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBpbWcuaGVpZ2h0O1xuICAgICAgICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuXG4gICAgICAgICAgLy8gcHV0IGl0IGluIGV2ZXJ5IHNsaWNlIG90aGVyd2lzZSBzb21lIHNsaWNlcyB3aWxsIGJlIDAsMCwwLDBcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGRlcHRoOyArK3MpIHtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlM0QodGFyZ2V0LCBsZXZlbCwgMCwgMCwgcywgd2lkdGgsIGhlaWdodCwgMSwgZm9ybWF0LCB0eXBlLCBpbWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgc3JjID0gaW1nO1xuICAgICAgICAgIGxldCBjdHg7XG4gICAgICAgICAgaWYgKGltZy53aWR0aCAhPT0gd2lkdGggfHwgaW1nLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBTaXplIHRoZSBpbWFnZSB0byBmaXhcbiAgICAgICAgICAgIGN0eCA9IGdldFNoYXJlZDJEQ29udGV4dCgpO1xuICAgICAgICAgICAgc3JjID0gY3R4LmNhbnZhcztcbiAgICAgICAgICAgIGN0eC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGN0eC5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLnRleFN1YkltYWdlM0QodGFyZ2V0LCBsZXZlbCwgMCwgMCwgc2xpY2UsIHdpZHRoLCBoZWlnaHQsIDEsIGZvcm1hdCwgdHlwZSwgc3JjKTtcblxuICAgICAgICAgIC8vIGZyZWUgdGhlIGNhbnZhcyBtZW1vcnlcbiAgICAgICAgICBpZiAoY3R4ICYmIHNyYyA9PT0gY3R4LmNhbnZhcykge1xuICAgICAgICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IDA7XG4gICAgICAgICAgICBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9tYXRpY2FsbHlTZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShvcHRpb25zKSkge1xuICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG51bVRvTG9hZCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogdW5kZWZpbmVkLCB0ZXgsIGltZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbWdzID0gdXJscy5tYXAoZnVuY3Rpb24odXJsLCBuZHgpIHtcbiAgICByZXR1cm4gbG9hZEFuZFVzZUltYWdlKHVybCwgb3B0aW9ucy5jcm9zc09yaWdpbiwgdXBsb2FkSW1nKG5keCkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXRzIGEgdGV4dHVyZSBmcm9tIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5LiBJZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGlzIG5vdCBwcm92aWRlZCB3aWxsIGF0dGVtcHQgdG9cbiAqIGd1ZXNzIHRoZSBzaXplLiBTZWUge0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfS5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0geyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXcpfSBzcmMgQW4gYXJyYXkgb3IgdHlwZWQgYXJyeSB3aXRoIHRleHR1cmUgZGF0YS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IFtvcHRpb25zXSBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIHNldFRleHR1cmVGcm9tQXJyYXkoZ2wsIHRleCwgc3JjLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDEudGV4dHVyZU9wdGlvbnM7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQkMjtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICBsZXQgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICBsZXQgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIGxldCBkZXB0aCA9IG9wdGlvbnMuZGVwdGg7XG4gIGNvbnN0IGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQgfHwgUkdCQSQxO1xuICBjb25zdCBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZ2V0VGV4dHVyZVR5cGVGb3JBcnJheVR5cGUoZ2wsIHNyYywgZm9ybWF0VHlwZS50eXBlKTtcbiAgaWYgKCFpc0FycmF5QnVmZmVyKHNyYykpIHtcbiAgICBjb25zdCBUeXBlID0gZ2V0VHlwZWRBcnJheVR5cGVGb3JHTFR5cGUodHlwZSk7XG4gICAgc3JjID0gbmV3IFR5cGUoc3JjKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgIHNyYyA9IG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIpO1xuICB9XG5cbiAgY29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQsIHR5cGUpO1xuICBjb25zdCBudW1FbGVtZW50cyA9IHNyYy5ieXRlTGVuZ3RoIC8gYnl0ZXNQZXJFbGVtZW50OyAgLy8gVE9ETzogY2hlY2sgVU5QQUNLX0FMSUdOTUVOVD9cbiAgaWYgKG51bUVsZW1lbnRzICUgMSkge1xuICAgIHRocm93IFwibGVuZ3RoIHdyb25nIHNpemUgZm9yIGZvcm1hdDogXCIgKyBnbEVudW1Ub1N0cmluZyhnbCwgZm9ybWF0KTtcbiAgfVxuICBsZXQgZGltZW5zaW9ucztcbiAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCQxIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSQxKSB7XG4gICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0ICYmICFkZXB0aCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguY2JydChudW1FbGVtZW50cyk7XG4gICAgICBpZiAoc2l6ZSAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgXCJjYW4ndCBndWVzcyBjdWJlIHNpemUgb2YgYXJyYXkgb2YgbnVtRWxlbWVudHM6IFwiICsgbnVtRWxlbWVudHM7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgICAgZGVwdGggPSBzaXplO1xuICAgIH0gZWxzZSBpZiAod2lkdGggJiYgKCFoZWlnaHQgfHwgIWRlcHRoKSkge1xuICAgICAgZGltZW5zaW9ucyA9IGd1ZXNzRGltZW5zaW9ucyhnbCwgdGFyZ2V0LCBoZWlnaHQsIGRlcHRoLCBudW1FbGVtZW50cyAvIHdpZHRoKTtcbiAgICAgIGhlaWdodCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICBkZXB0aCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ICYmICghd2lkdGggfHwgIWRlcHRoKSkge1xuICAgICAgZGltZW5zaW9ucyA9IGd1ZXNzRGltZW5zaW9ucyhnbCwgdGFyZ2V0LCB3aWR0aCwgZGVwdGgsIG51bUVsZW1lbnRzIC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgIGRlcHRoID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbWVuc2lvbnMgPSBndWVzc0RpbWVuc2lvbnMoZ2wsIHRhcmdldCwgd2lkdGgsIGhlaWdodCwgbnVtRWxlbWVudHMgLyBkZXB0aCk7XG4gICAgICB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGltZW5zaW9ucyA9IGd1ZXNzRGltZW5zaW9ucyhnbCwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBudW1FbGVtZW50cyk7XG4gICAgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgIGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICB9XG4gIHNldFNraXBTdGF0ZVRvRGVmYXVsdChnbCk7XG4gIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19BTElHTk1FTlQsIG9wdGlvbnMudW5wYWNrQWxpZ25tZW50IHx8IDEpO1xuICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQJDEpIHtcbiAgICBjb25zdCBlbGVtZW50c1BlckVsZW1lbnQgPSBieXRlc1BlckVsZW1lbnQgLyBzcmMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgY29uc3QgZmFjZVNpemUgPSBudW1FbGVtZW50cyAvIDYgKiBlbGVtZW50c1BlckVsZW1lbnQ7XG5cbiAgICBnZXRDdWJlRmFjZXNXaXRoTmR4KGdsLCBvcHRpb25zKS5mb3JFYWNoKGYgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZmFjZVNpemUgKiBmLm5keDtcbiAgICAgIGNvbnN0IGRhdGEgPSBzcmMuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBmYWNlU2l6ZSk7XG4gICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCQxIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSQxKSB7XG4gICAgZ2wudGV4SW1hZ2UzRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIDAsIGZvcm1hdCwgdHlwZSwgc3JjKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIHNyYyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgZGVwdGg6IGRlcHRoLFxuICAgIHR5cGU6IHR5cGUsXG4gIH07XG59XG5cbi8qKlxuICogU2V0cyBhIHRleHR1cmUgd2l0aCBubyBjb250ZW50cyBvZiBhIGNlcnRhaW4gc2l6ZS4gSW4gb3RoZXIgd29yZHMgY2FsbHMgYGdsLnRleEltYWdlMkRgIHdpdGggYG51bGxgLlxuICogWW91IG11c3Qgc2V0IGBvcHRpb25zLndpZHRoYCBhbmQgYG9wdGlvbnMuaGVpZ2h0YC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuZnVuY3Rpb24gc2V0RW1wdHlUZXh0dXJlKGdsLCB0ZXgsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRCQyO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIGNvbnN0IGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQgfHwgUkdCQSQxO1xuICBjb25zdCBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZm9ybWF0VHlwZS50eXBlO1xuICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQJDEpIHtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgNjsgKytpaSkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpaSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEJDEgfHwgdGFyZ2V0ID09PSBURVhUVVJFXzJEX0FSUkFZJDEpIHtcbiAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgb3B0aW9ucy5kZXB0aCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbi5cbiAqXG4gKiBOb3RlOiBtYXkgcmVzZXQgVU5QQUNLX0FMSUdOTUVOVCwgVU5QQUNLX1JPV19MRU5HVEgsIFVOUEFDS19JTUFHRV9IRUlHSFQsIFVOUEFDS19TS0lQX0lNQUdFU1xuICogVU5QQUNLX1NLSVBfUElYRUxTLCBhbmQgVU5QQUNLX1NLSVBfUk9XU1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBjYWxsYmFjayBjYWxsZWQgd2hlbiBhbiBpbWFnZSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCB1cGxvYWRlZCB0byB0aGUgdGV4dHVyZS5cbiAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX0gdGhlIGNyZWF0ZWQgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDEudGV4dHVyZU9wdGlvbnM7XG4gIGNvbnN0IHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRCQyO1xuICBsZXQgd2lkdGggID0gb3B0aW9ucy53aWR0aCAgfHwgMTtcbiAgbGV0IGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDE7XG4gIGNvbnN0IGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBSR0JBJDE7XG4gIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcbiAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCQxKSB7XG4gICAgLy8gdGhpcyBzaG91bGQgaGF2ZSBiZWVuIHRoZSBkZWZhdWx0IGZvciBjdWJlbWFwcyA6KFxuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX1dSQVBfUywgQ0xBTVBfVE9fRURHRSQxKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgVEVYVFVSRV9XUkFQX1QsIENMQU1QX1RPX0VER0UkMSk7XG4gIH1cbiAgbGV0IHNyYyA9IG9wdGlvbnMuc3JjO1xuICBpZiAoc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgc3JjID0gc3JjKGdsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc3JjKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbG9hZFRleHR1cmVGcm9tVXJsKGdsLCB0ZXgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoc3JjKSB8fFxuICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoc3JjKSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzcmNbMF0gPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoc3JjWzBdKSB8fFxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5QnVmZmVyKHNyY1swXSkpXG4gICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICkge1xuICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHNldFRleHR1cmVGcm9tQXJyYXkoZ2wsIHRleCwgc3JjLCBvcHRpb25zKTtcbiAgICAgIHdpZHRoICA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSAmJiAodHlwZW9mIChzcmNbMF0pID09PSAnc3RyaW5nJyB8fCBpc1RleEltYWdlU291cmNlKHNyY1swXSkpKSB7XG4gICAgICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQJDEpIHtcbiAgICAgICAgbG9hZEN1YmVtYXBGcm9tVXJscyhnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkU2xpY2VzRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIGlmIChpc1RleEltYWdlU291cmNlKHNyYykpXG4gICAgICBzZXRUZXh0dXJlRnJvbUVsZW1lbnQoZ2wsIHRleCwgc3JjLCBvcHRpb25zKTtcbiAgICAgIHdpZHRoICA9IHNyYy53aWR0aDtcbiAgICAgIGhlaWdodCA9IHNyYy5oZWlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldEVtcHR5VGV4dHVyZShnbCwgdGV4LCBvcHRpb25zKTtcbiAgfVxuICBpZiAoc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpKSB7XG4gICAgc2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUoZ2wsIHRleCwgb3B0aW9ucywgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQpO1xuICB9XG4gIHNldFRleHR1cmVQYXJhbWV0ZXJzKGdsLCB0ZXgsIG9wdGlvbnMpO1xuICByZXR1cm4gdGV4O1xufVxuXG4vKipcbiAqIFJlc2l6ZXMgYSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbi5cbiAqXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhIGdlbmVyaWMgcmVzaXplIGFueXRoaW5nIGZ1bmN0aW9uLlxuICogSXQncyBtb3N0bHkgdXNlZCBieSB7QGxpbmsgbW9kdWxlOnR3Z2wucmVzaXplRnJhbWVidWZmZXJJbmZvfVxuICogSXQgd2lsbCB1c2UgYG9wdGlvbnMuc3JjYCBpZiBpdCBleGlzdHMgdG8gdHJ5IHRvIGRldGVybWluZSBhIGB0eXBlYFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGBnbC5VTlNJR05FRF9CWVRFYC4gTm8gZGF0YSBpcyBwcm92aWRlZFxuICogZm9yIHRoZSB0ZXh0dXJlLiBUZXh0dXJlIHBhcmFtZXRlcnMgd2lsbCBiZSBzZXQgYWNjb3JkaW5nbHlcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgdGV4dHVyZSB0byByZXNpemVcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIHRoZSBuZXcgd2lkdGguIElmIG5vdCBwYXNzZWQgaW4gd2lsbCB1c2UgYG9wdGlvbnMud2lkdGhgXG4gKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gdGhlIG5ldyBoZWlnaHQuIElmIG5vdCBwYXNzZWQgaW4gd2lsbCB1c2UgYG9wdGlvbnMuaGVpZ2h0YFxuICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aF0gdGhlIG5ldyBkZXB0aC4gSWYgbm90IHBhc3NlZCBpbiB3aWxsIHVzZSBgb3B0aW9ucy5kZXB0aGBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiByZXNpemVUZXh0dXJlKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSB7XG4gIHdpZHRoID0gd2lkdGggfHwgb3B0aW9ucy53aWR0aDtcbiAgaGVpZ2h0ID0gaGVpZ2h0IHx8IG9wdGlvbnMuaGVpZ2h0O1xuICBkZXB0aCA9IGRlcHRoIHx8IG9wdGlvbnMuZGVwdGg7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQkMjtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICBjb25zdCBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMDtcbiAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IFJHQkEkMTtcbiAgY29uc3QgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICBsZXQgdHlwZTtcbiAgY29uc3Qgc3JjID0gb3B0aW9ucy5zcmM7XG4gIGlmICghc3JjKSB7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihzcmMpIHx8IChBcnJheS5pc0FycmF5KHNyYykgJiYgdHlwZW9mIChzcmNbMF0pID09PSAnbnVtYmVyJykpIHtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlIHx8IGdldFRleHR1cmVUeXBlRm9yQXJyYXlUeXBlKGdsLCBzcmMsIGZvcm1hdFR5cGUudHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCQxKSB7XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IDY7ICsraWkpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaWksIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEJDEgfHwgdGFyZ2V0ID09PSBURVhUVVJFXzJEX0FSUkFZJDEpIHtcbiAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzcmMgaXMgYW4gYXN5bmMgcmVxdWVzdC5cbiAqIGlmIHNyYyBpcyBhIHN0cmluZyB3ZSdyZSBnb2luZyB0byBkb3dubG9hZCBhbiBpbWFnZVxuICogaWYgc3JjIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgd2UncmUgZ29pbmcgdG8gZG93bmxvYWQgY3ViZW1hcCBpbWFnZXNcbiAqIEBwYXJhbSB7Kn0gc3JjIFRoZSBzcmMgZnJvbSBhIFRleHR1cmVPcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBpZiBzcmMgaXMgYXN5bmMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0FzeW5jU3JjKHNyYykge1xuICByZXR1cm4gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIChBcnJheS5pc0FycmF5KHNyYykgJiYgdHlwZW9mIHNyY1swXSA9PT0gJ3N0cmluZycpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBidW5jaCBvZiB0ZXh0dXJlcyBiYXNlZCBvbiB0aGUgcGFzc2VkIGluIG9wdGlvbnMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdGV4dHVyZXMgPSB0d2dsLmNyZWF0ZVRleHR1cmVzKGdsLCB7XG4gKiAgICAgICAvLyBhIHBvd2VyIG9mIDIgaW1hZ2VcbiAqICAgICAgIGhmdEljb246IHsgc3JjOiBcImltYWdlcy9oZnQtaWNvbi0xNi5wbmdcIiwgbWFnOiBnbC5ORUFSRVNUIH0sXG4gKiAgICAgICAvLyBhIG5vbi1wb3dlciBvZiAyIGltYWdlXG4gKiAgICAgICBjbG92ZXI6IHsgc3JjOiBcImltYWdlcy9jbG92ZXIuanBnXCIgfSxcbiAqICAgICAgIC8vIEZyb20gYSBjYW52YXNcbiAqICAgICAgIGZyb21DYW52YXM6IHsgc3JjOiBjdHguY2FudmFzIH0sXG4gKiAgICAgICAvLyBBIGN1YmVtYXAgZnJvbSA2IGltYWdlc1xuICogICAgICAgeW9rb2hhbWE6IHtcbiAqICAgICAgICAgdGFyZ2V0OiBnbC5URVhUVVJFX0NVQkVfTUFQLFxuICogICAgICAgICBzcmM6IFtcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL3Bvc3guanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL25lZ3guanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL3Bvc3kuanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL25lZ3kuanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL3Bvc3ouanBnJyxcbiAqICAgICAgICAgICAnaW1hZ2VzL3lva29oYW1hL25lZ3ouanBnJyxcbiAqICAgICAgICAgXSxcbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBBIGN1YmVtYXAgZnJvbSAxIGltYWdlIChjYW4gYmUgMXg2LCAyeDMsIDN4MiwgNngxKVxuICogICAgICAgZ29sZGVuZ2F0ZToge1xuICogICAgICAgICB0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG4gKiAgICAgICAgIHNyYzogJ2ltYWdlcy9nb2xkZW5nYXRlLmpwZycsXG4gKiAgICAgICB9LFxuICogICAgICAgLy8gQSAyeDIgcGl4ZWwgdGV4dHVyZSBmcm9tIGEgSmF2YVNjcmlwdCBhcnJheVxuICogICAgICAgY2hlY2tlcjoge1xuICogICAgICAgICBtYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgIG1pbjogZ2wuTElORUFSLFxuICogICAgICAgICBzcmM6IFtcbiAqICAgICAgICAgICAyNTUsMjU1LDI1NSwyNTUsXG4gKiAgICAgICAgICAgMTkyLDE5MiwxOTIsMjU1LFxuICogICAgICAgICAgIDE5MiwxOTIsMTkyLDI1NSxcbiAqICAgICAgICAgICAyNTUsMjU1LDI1NSwyNTUsXG4gKiAgICAgICAgIF0sXG4gKiAgICAgICB9LFxuICogICAgICAgLy8gYSAxeDIgcGl4ZWwgdGV4dHVyZSBmcm9tIGEgdHlwZWQgYXJyYXkuXG4gKiAgICAgICBzdHJpcGU6IHtcbiAqICAgICAgICAgbWFnOiBnbC5ORUFSRVNULFxuICogICAgICAgICBtaW46IGdsLkxJTkVBUixcbiAqICAgICAgICAgZm9ybWF0OiBnbC5MVU1JTkFOQ0UsXG4gKiAgICAgICAgIHNyYzogbmV3IFVpbnQ4QXJyYXkoW1xuICogICAgICAgICAgIDI1NSxcbiAqICAgICAgICAgICAxMjgsXG4gKiAgICAgICAgICAgMjU1LFxuICogICAgICAgICAgIDEyOCxcbiAqICAgICAgICAgICAyNTUsXG4gKiAgICAgICAgICAgMTI4LFxuICogICAgICAgICAgIDI1NSxcbiAqICAgICAgICAgICAxMjgsXG4gKiAgICAgICAgIF0pLFxuICogICAgICAgICB3aWR0aDogMSxcbiAqICAgICAgIH0sXG4gKiAgICAgfSk7XG4gKlxuICogTm93XG4gKlxuICogKiAgIGB0ZXh0dXJlcy5oZnRJY29uYCB3aWxsIGJlIGEgMmQgdGV4dHVyZVxuICogKiAgIGB0ZXh0dXJlcy5jbG92ZXJgIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLmZyb21DYW52YXNgIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLnlvaG9oYW1hYCB3aWxsIGJlIGEgY3ViZW1hcCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLmdvbGRlbmdhdGVgIHdpbGwgYmUgYSBjdWJlbWFwIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuY2hlY2tlcmAgd2lsbCBiZSBhIDJkIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuc3RyaXBlYCB3aWxsIGJlIGEgMmQgdGV4dHVyZVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zPn0gb3B0aW9ucyBBIG9iamVjdCBvZiBUZXh0dXJlT3B0aW9ucyBvbmUgcGVyIHRleHR1cmUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVzUmVhZHlDYWxsYmFja30gW2NhbGxiYWNrXSBBIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGFsbCB0ZXh0dXJlcyBoYXZlIGJlZW4gZG93bmxvYWRlZC5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLFdlYkdMVGV4dHVyZT59IHRoZSBjcmVhdGVkIHRleHR1cmVzIGJ5IG5hbWVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlcyhnbCwgdGV4dHVyZU9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgbGV0IG51bURvd25sb2FkaW5nID0gMDtcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIGNvbnN0IHRleHR1cmVzID0ge307XG4gIGNvbnN0IGltYWdlcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNhbGxDYWxsYmFja0lmUmVhZHkoKSB7XG4gICAgaWYgKG51bURvd25sb2FkaW5nID09PSAwKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogdW5kZWZpbmVkLCB0ZXh0dXJlcywgaW1hZ2VzKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKHRleHR1cmVPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGV4dHVyZU9wdGlvbnNbbmFtZV07XG4gICAgbGV0IG9uTG9hZEZuO1xuICAgIGlmIChpc0FzeW5jU3JjKG9wdGlvbnMuc3JjKSkge1xuICAgICAgb25Mb2FkRm4gPSBmdW5jdGlvbihlcnIsIHRleCwgaW1nKSB7XG4gICAgICAgIGltYWdlc1tuYW1lXSA9IGltZztcbiAgICAgICAgLS1udW1Eb3dubG9hZGluZztcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbENhbGxiYWNrSWZSZWFkeSgpO1xuICAgICAgfTtcbiAgICAgICsrbnVtRG93bmxvYWRpbmc7XG4gICAgfVxuICAgIHRleHR1cmVzW25hbWVdID0gY3JlYXRlVGV4dHVyZShnbCwgb3B0aW9ucywgb25Mb2FkRm4pO1xuICB9KTtcblxuICAvLyBxdWV1ZSB0aGUgY2FsbGJhY2sgaWYgdGhlcmUgYXJlIG5vIGltYWdlcyB0byBkb3dubG9hZC5cbiAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIGlmIHlvdXIgY29kZSBpcyBzdHJ1Y3R1cmVkIHRvIHdhaXQgZm9yXG4gIC8vIGltYWdlcyB0byBkb3dubG9hZCBidXQgdGhlbiB5b3UgY29tbWVudCBvdXQgYWxsIHRoZSBhc3luY1xuICAvLyBpbWFnZXMgeW91ciBjb2RlIHdvdWxkIGJyZWFrLlxuICBjYWxsQ2FsbGJhY2tJZlJlYWR5KCk7XG5cbiAgcmV0dXJuIHRleHR1cmVzO1xufVxuXG52YXIgdGV4dHVyZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc2V0VGV4dHVyZURlZmF1bHRzXzogc2V0RGVmYXVsdHMkMSxcbiAgY3JlYXRlU2FtcGxlcjogY3JlYXRlU2FtcGxlcixcbiAgY3JlYXRlU2FtcGxlcnM6IGNyZWF0ZVNhbXBsZXJzLFxuICBzZXRTYW1wbGVyUGFyYW1ldGVyczogc2V0U2FtcGxlclBhcmFtZXRlcnMsXG4gIGNyZWF0ZVRleHR1cmU6IGNyZWF0ZVRleHR1cmUsXG4gIHNldEVtcHR5VGV4dHVyZTogc2V0RW1wdHlUZXh0dXJlLFxuICBzZXRUZXh0dXJlRnJvbUFycmF5OiBzZXRUZXh0dXJlRnJvbUFycmF5LFxuICBsb2FkVGV4dHVyZUZyb21Vcmw6IGxvYWRUZXh0dXJlRnJvbVVybCxcbiAgc2V0VGV4dHVyZUZyb21FbGVtZW50OiBzZXRUZXh0dXJlRnJvbUVsZW1lbnQsXG4gIHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplOiBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZSxcbiAgc2V0VGV4dHVyZVBhcmFtZXRlcnM6IHNldFRleHR1cmVQYXJhbWV0ZXJzLFxuICBzZXREZWZhdWx0VGV4dHVyZUNvbG9yOiBzZXREZWZhdWx0VGV4dHVyZUNvbG9yLFxuICBjcmVhdGVUZXh0dXJlczogY3JlYXRlVGV4dHVyZXMsXG4gIHJlc2l6ZVRleHR1cmU6IHJlc2l6ZVRleHR1cmUsXG4gIGNhbkdlbmVyYXRlTWlwbWFwOiBjYW5HZW5lcmF0ZU1pcG1hcCxcbiAgY2FuRmlsdGVyOiBjYW5GaWx0ZXIsXG4gIGdldE51bUNvbXBvbmVudHNGb3JGb3JtYXQ6IGdldE51bUNvbXBvbmVudHNGb3JGb3JtYXQsXG4gIGdldEJ5dGVzUGVyRWxlbWVudEZvckludGVybmFsRm9ybWF0OiBnZXRCeXRlc1BlckVsZW1lbnRGb3JJbnRlcm5hbEZvcm1hdCxcbiAgZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0OiBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXRcbn0pO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogTG93IGxldmVsIHNoYWRlciBwcm9ncmFtIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogWW91IHNob3VsZCBnZW5lcmFsbHkgbm90IG5lZWQgdG8gdXNlIHRoZXNlIGZ1bmN0aW9ucy4gVGhleSBhcmUgcHJvdmlkZWRcbiAqIGZvciB0aG9zZSBjYXNlcyB3aGVyZSB5b3UncmUgZG9pbmcgc29tZXRoaW5nIG91dCBvZiB0aGUgb3JkaW5hcnlcbiAqIGFuZCB5b3UgbmVlZCBsb3dlciBsZXZlbCBhY2Nlc3MuXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wucHJvZ3JhbXNgIGFuZCBgdHdnbGBcbiAqIGl0c2VsZlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOnR3Z2x9IGZvciBjb3JlIGZ1bmN0aW9uc1xuICpcbiAqIEBtb2R1bGUgdHdnbC9wcm9ncmFtc1xuICovXG5cbmNvbnN0IGVycm9yID0gZXJyb3IkMTtcbmNvbnN0IHdhcm4gPSB3YXJuJDE7XG5mdW5jdGlvbiBnZXRFbGVtZW50QnlJZChpZCkge1xuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQpXG4gICAgICA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxuICAgICAgOiBudWxsO1xufVxuXG5jb25zdCBURVhUVVJFMCAgICAgICAgICAgICAgICAgICAgICAgPSAweDg0YzA7XG5jb25zdCBEWU5BTUlDX0RSQVcgICAgICAgICAgICAgICAgICAgPSAweDg4ZTg7XG5cbmNvbnN0IEFSUkFZX0JVRkZFUiAgICAgICAgICAgICAgICAgICA9IDB4ODg5MjtcbmNvbnN0IEVMRU1FTlRfQVJSQVlfQlVGRkVSJDEgICAgICAgICAgID0gMHg4ODkzO1xuY29uc3QgVU5JRk9STV9CVUZGRVIgICAgICAgICAgICAgICAgID0gMHg4YTExO1xuY29uc3QgVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiAgICAgID0gMHg4YzhlO1xuXG5jb25zdCBUUkFOU0ZPUk1fRkVFREJBQ0sgICAgICAgICAgICAgPSAweDhlMjI7XG5cbmNvbnN0IENPTVBJTEVfU1RBVFVTICAgICAgICAgICAgICAgICA9IDB4OGI4MTtcbmNvbnN0IExJTktfU1RBVFVTICAgICAgICAgICAgICAgICAgICA9IDB4OGI4MjtcbmNvbnN0IEZSQUdNRU5UX1NIQURFUiAgICAgICAgICAgICAgICA9IDB4OGIzMDtcbmNvbnN0IFZFUlRFWF9TSEFERVIgICAgICAgICAgICAgICAgICA9IDB4OGIzMTtcbmNvbnN0IFNFUEFSQVRFX0FUVFJJQlMgICAgICAgICAgICAgICA9IDB4OGM4ZDtcblxuY29uc3QgQUNUSVZFX1VOSUZPUk1TICAgICAgICAgICAgICAgID0gMHg4Yjg2O1xuY29uc3QgQUNUSVZFX0FUVFJJQlVURVMgICAgICAgICAgICAgID0gMHg4Yjg5O1xuY29uc3QgVFJBTlNGT1JNX0ZFRURCQUNLX1ZBUllJTkdTICAgID0gMHg4YzgzO1xuY29uc3QgQUNUSVZFX1VOSUZPUk1fQkxPQ0tTICAgICAgICAgID0gMHg4YTM2O1xuY29uc3QgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVIgICA9IDB4OGE0NDtcbmNvbnN0IFVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9GUkFHTUVOVF9TSEFERVIgPSAweDhhNDY7XG5jb25zdCBVTklGT1JNX0JMT0NLX0RBVEFfU0laRSAgICAgICAgICAgICAgICAgICAgID0gMHg4YTQwO1xuY29uc3QgVU5JRk9STV9CTE9DS19BQ1RJVkVfVU5JRk9STV9JTkRJQ0VTICAgICAgICA9IDB4OGE0MztcblxuY29uc3QgRkxPQVQgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDY7XG5jb25zdCBGTE9BVF9WRUMyICAgICAgICAgICAgICAgICAgICA9IDB4OEI1MDtcbmNvbnN0IEZMT0FUX1ZFQzMgICAgICAgICAgICAgICAgICAgID0gMHg4QjUxO1xuY29uc3QgRkxPQVRfVkVDNCAgICAgICAgICAgICAgICAgICAgPSAweDhCNTI7XG5jb25zdCBJTlQgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNDtcbmNvbnN0IElOVF9WRUMyICAgICAgICAgICAgICAgICAgICAgID0gMHg4QjUzO1xuY29uc3QgSU5UX1ZFQzMgICAgICAgICAgICAgICAgICAgICAgPSAweDhCNTQ7XG5jb25zdCBJTlRfVkVDNCAgICAgICAgICAgICAgICAgICAgICA9IDB4OEI1NTtcbmNvbnN0IEJPT0wgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4QjU2O1xuY29uc3QgQk9PTF9WRUMyICAgICAgICAgICAgICAgICAgICAgPSAweDhCNTc7XG5jb25zdCBCT09MX1ZFQzMgICAgICAgICAgICAgICAgICAgICA9IDB4OEI1ODtcbmNvbnN0IEJPT0xfVkVDNCAgICAgICAgICAgICAgICAgICAgID0gMHg4QjU5O1xuY29uc3QgRkxPQVRfTUFUMiAgICAgICAgICAgICAgICAgICAgPSAweDhCNUE7XG5jb25zdCBGTE9BVF9NQVQzICAgICAgICAgICAgICAgICAgICA9IDB4OEI1QjtcbmNvbnN0IEZMT0FUX01BVDQgICAgICAgICAgICAgICAgICAgID0gMHg4QjVDO1xuY29uc3QgU0FNUExFUl8yRCAgICAgICAgICAgICAgICAgICAgPSAweDhCNUU7XG5jb25zdCBTQU1QTEVSX0NVQkUgICAgICAgICAgICAgICAgICA9IDB4OEI2MDtcbmNvbnN0IFNBTVBMRVJfM0QgICAgICAgICAgICAgICAgICAgID0gMHg4QjVGO1xuY29uc3QgU0FNUExFUl8yRF9TSEFET1cgICAgICAgICAgICAgPSAweDhCNjI7XG5jb25zdCBGTE9BVF9NQVQyeDMgICAgICAgICAgICAgICAgICA9IDB4OEI2NTtcbmNvbnN0IEZMT0FUX01BVDJ4NCAgICAgICAgICAgICAgICAgID0gMHg4QjY2O1xuY29uc3QgRkxPQVRfTUFUM3gyICAgICAgICAgICAgICAgICAgPSAweDhCNjc7XG5jb25zdCBGTE9BVF9NQVQzeDQgICAgICAgICAgICAgICAgICA9IDB4OEI2ODtcbmNvbnN0IEZMT0FUX01BVDR4MiAgICAgICAgICAgICAgICAgID0gMHg4QjY5O1xuY29uc3QgRkxPQVRfTUFUNHgzICAgICAgICAgICAgICAgICAgPSAweDhCNkE7XG5jb25zdCBTQU1QTEVSXzJEX0FSUkFZICAgICAgICAgICAgICA9IDB4OERDMTtcbmNvbnN0IFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XICAgICAgID0gMHg4REM0O1xuY29uc3QgU0FNUExFUl9DVUJFX1NIQURPVyAgICAgICAgICAgPSAweDhEQzU7XG5jb25zdCBVTlNJR05FRF9JTlQgICAgICAgICAgICAgICAgICA9IDB4MTQwNTtcbmNvbnN0IFVOU0lHTkVEX0lOVF9WRUMyICAgICAgICAgICAgID0gMHg4REM2O1xuY29uc3QgVU5TSUdORURfSU5UX1ZFQzMgICAgICAgICAgICAgPSAweDhEQzc7XG5jb25zdCBVTlNJR05FRF9JTlRfVkVDNCAgICAgICAgICAgICA9IDB4OERDODtcbmNvbnN0IElOVF9TQU1QTEVSXzJEICAgICAgICAgICAgICAgID0gMHg4RENBO1xuY29uc3QgSU5UX1NBTVBMRVJfM0QgICAgICAgICAgICAgICAgPSAweDhEQ0I7XG5jb25zdCBJTlRfU0FNUExFUl9DVUJFICAgICAgICAgICAgICA9IDB4OERDQztcbmNvbnN0IElOVF9TQU1QTEVSXzJEX0FSUkFZICAgICAgICAgID0gMHg4RENGO1xuY29uc3QgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQgICAgICAgPSAweDhERDI7XG5jb25zdCBVTlNJR05FRF9JTlRfU0FNUExFUl8zRCAgICAgICA9IDB4OEREMztcbmNvbnN0IFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkUgICAgID0gMHg4REQ0O1xuY29uc3QgVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVkgPSAweDhERDc7XG5cbmNvbnN0IFRFWFRVUkVfMkQkMSAgICAgICAgICAgICAgICAgICAgPSAweDBERTE7XG5jb25zdCBURVhUVVJFX0NVQkVfTUFQICAgICAgICAgICAgICA9IDB4ODUxMztcbmNvbnN0IFRFWFRVUkVfM0QgICAgICAgICAgICAgICAgICAgID0gMHg4MDZGO1xuY29uc3QgVEVYVFVSRV8yRF9BUlJBWSAgICAgICAgICAgICAgPSAweDhDMUE7XG5cbmNvbnN0IHR5cGVNYXAgPSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGJpbmQgcG9pbnQgZm9yIGEgZ2l2ZW4gc2FtcGxlciB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCaW5kUG9pbnRGb3JTYW1wbGVyVHlwZShnbCwgdHlwZSkge1xuICByZXR1cm4gdHlwZU1hcFt0eXBlXS5iaW5kUG9pbnQ7XG59XG5cbi8vIFRoaXMga2luZCBvZiBzdWNrcyEgSWYgeW91IGNvdWxkIGNvbXBvc2UgZnVuY3Rpb25zIGFzIGluIGB2YXIgZm4gPSBnbFtuYW1lXTtgXG4vLyB0aGlzIGNvZGUgY291bGQgYmUgYSBsb3Qgc21hbGxlciBidXQgdGhhdCBpcyBzYWRseSByZWFsbHkgc2xvdyAoVF9UKVxuXG5mdW5jdGlvbiBmbG9hdFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdEFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0VmVjM1NldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRWZWM0U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50QXJyYXlTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTF1aShsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRBcnJheVNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtMXVpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRWZWMyU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIGdsLnVuaWZvcm0ydWl2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdWludFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTN1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjNFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtNHVpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0M1NldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MjNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDJ4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MjRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDJ4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NDJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDR4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MzRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NDNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDR4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNhbXBsZXJTZXR0ZXIoZ2wsIHR5cGUsIHVuaXQsIGxvY2F0aW9uKSB7XG4gIGNvbnN0IGJpbmRQb2ludCA9IGdldEJpbmRQb2ludEZvclNhbXBsZXJUeXBlKGdsLCB0eXBlKTtcbiAgcmV0dXJuIGlzV2ViR0wyKGdsKSA/IGZ1bmN0aW9uKHRleHR1cmVPclBhaXIpIHtcbiAgICBsZXQgdGV4dHVyZTtcbiAgICBsZXQgc2FtcGxlcjtcbiAgICBpZiAoIXRleHR1cmVPclBhaXIgfHwgaXNUZXh0dXJlKGdsLCB0ZXh0dXJlT3JQYWlyKSkge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXI7XG4gICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXIudGV4dHVyZTtcbiAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgfVxuICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdW5pdCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShURVhUVVJFMCArIHVuaXQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGJpbmRQb2ludCwgdGV4dHVyZSk7XG4gICAgZ2wuYmluZFNhbXBsZXIodW5pdCwgc2FtcGxlcik7XG4gIH0gOiBmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bml0KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKFRFWFRVUkUwICsgdW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlckFycmF5U2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgc2l6ZSkge1xuICBjb25zdCBiaW5kUG9pbnQgPSBnZXRCaW5kUG9pbnRGb3JTYW1wbGVyVHlwZShnbCwgdHlwZSk7XG4gIGNvbnN0IHVuaXRzID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBzaXplOyArK2lpKSB7XG4gICAgdW5pdHNbaWldID0gdW5pdCArIGlpO1xuICB9XG5cbiAgcmV0dXJuIGlzV2ViR0wyKGdsKSA/IGZ1bmN0aW9uKHRleHR1cmVzKSB7XG4gICAgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdW5pdHMpO1xuICAgIHRleHR1cmVzLmZvckVhY2goZnVuY3Rpb24odGV4dHVyZU9yUGFpciwgaW5kZXgpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoVEVYVFVSRTAgKyB1bml0c1tpbmRleF0pO1xuICAgICAgbGV0IHRleHR1cmU7XG4gICAgICBsZXQgc2FtcGxlcjtcbiAgICAgIGlmICghdGV4dHVyZU9yUGFpciB8fCBpc1RleHR1cmUoZ2wsIHRleHR1cmVPclBhaXIpKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyO1xuICAgICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyLnRleHR1cmU7XG4gICAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgICB9XG4gICAgICBnbC5iaW5kU2FtcGxlcih1bml0LCBzYW1wbGVyKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGJpbmRQb2ludCwgdGV4dHVyZSk7XG4gICAgfSk7XG4gIH0gOiBmdW5jdGlvbih0ZXh0dXJlcykge1xuICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHVuaXRzKTtcbiAgICB0ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKHRleHR1cmUsIGluZGV4KSB7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKFRFWFRVUkUwICsgdW5pdHNbaW5kZXhdKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGJpbmRQb2ludCwgdGV4dHVyZSk7XG4gICAgfSk7XG4gIH07XG59XG5cbnR5cGVNYXBbRkxPQVRdICAgICAgICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6ICA0LCBzZXR0ZXI6IGZsb2F0U2V0dGVyLCAgICAgIGFycmF5U2V0dGVyOiBmbG9hdEFycmF5U2V0dGVyLCB9O1xudHlwZU1hcFtGTE9BVF9WRUMyXSAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogIDgsIHNldHRlcjogZmxvYXRWZWMyU2V0dGVyLCAgY29sczogMiwgfTtcbnR5cGVNYXBbRkxPQVRfVkVDM10gICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6IDEyLCBzZXR0ZXI6IGZsb2F0VmVjM1NldHRlciwgIGNvbHM6IDMsIH07XG50eXBlTWFwW0ZMT0FUX1ZFQzRdICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogRmxvYXQzMkFycmF5LCBzaXplOiAxNiwgc2V0dGVyOiBmbG9hdFZlYzRTZXR0ZXIsICBjb2xzOiA0LCB9O1xudHlwZU1hcFtJTlRdICAgICAgICAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEludDMyQXJyYXksICAgc2l6ZTogIDQsIHNldHRlcjogaW50U2V0dGVyLCAgICAgICAgYXJyYXlTZXR0ZXI6IGludEFycmF5U2V0dGVyLCB9O1xudHlwZU1hcFtJTlRfVkVDMl0gICAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEludDMyQXJyYXksICAgc2l6ZTogIDgsIHNldHRlcjogaW50VmVjMlNldHRlciwgICAgY29sczogMiwgfTtcbnR5cGVNYXBbSU5UX1ZFQzNdICAgICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBJbnQzMkFycmF5LCAgIHNpemU6IDEyLCBzZXR0ZXI6IGludFZlYzNTZXR0ZXIsICAgIGNvbHM6IDMsIH07XG50eXBlTWFwW0lOVF9WRUM0XSAgICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogSW50MzJBcnJheSwgICBzaXplOiAxNiwgc2V0dGVyOiBpbnRWZWM0U2V0dGVyLCAgICBjb2xzOiA0LCB9O1xudHlwZU1hcFtVTlNJR05FRF9JTlRdICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IFVpbnQzMkFycmF5LCAgc2l6ZTogIDQsIHNldHRlcjogdWludFNldHRlciwgICAgICAgYXJyYXlTZXR0ZXI6IHVpbnRBcnJheVNldHRlciwgfTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1ZFQzJdICAgICAgICAgICAgID0geyBUeXBlOiBVaW50MzJBcnJheSwgIHNpemU6ICA4LCBzZXR0ZXI6IHVpbnRWZWMyU2V0dGVyLCAgIGNvbHM6IDIsIH07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMzXSAgICAgICAgICAgICA9IHsgVHlwZTogVWludDMyQXJyYXksICBzaXplOiAxMiwgc2V0dGVyOiB1aW50VmVjM1NldHRlciwgICBjb2xzOiAzLCB9O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfVkVDNF0gICAgICAgICAgICAgPSB7IFR5cGU6IFVpbnQzMkFycmF5LCAgc2l6ZTogMTYsIHNldHRlcjogdWludFZlYzRTZXR0ZXIsICAgY29sczogNCwgfTtcbnR5cGVNYXBbQk9PTF0gICAgICAgICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBVaW50MzJBcnJheSwgIHNpemU6ICA0LCBzZXR0ZXI6IGludFNldHRlciwgICAgICAgIGFycmF5U2V0dGVyOiBpbnRBcnJheVNldHRlciwgfTtcbnR5cGVNYXBbQk9PTF9WRUMyXSAgICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBVaW50MzJBcnJheSwgIHNpemU6ICA4LCBzZXR0ZXI6IGludFZlYzJTZXR0ZXIsICAgIGNvbHM6IDIsIH07XG50eXBlTWFwW0JPT0xfVkVDM10gICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogVWludDMyQXJyYXksICBzaXplOiAxMiwgc2V0dGVyOiBpbnRWZWMzU2V0dGVyLCAgICBjb2xzOiAzLCB9O1xudHlwZU1hcFtCT09MX1ZFQzRdICAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IFVpbnQzMkFycmF5LCAgc2l6ZTogMTYsIHNldHRlcjogaW50VmVjNFNldHRlciwgICAgY29sczogNCwgfTtcbnR5cGVNYXBbRkxPQVRfTUFUMl0gICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6IDMyLCBzZXR0ZXI6IGZsb2F0TWF0MlNldHRlciwgIHJvd3M6IDIsIGNvbHM6IDIsIH07XG50eXBlTWFwW0ZMT0FUX01BVDNdICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogRmxvYXQzMkFycmF5LCBzaXplOiA0OCwgc2V0dGVyOiBmbG9hdE1hdDNTZXR0ZXIsICByb3dzOiAzLCBjb2xzOiAzLCB9O1xudHlwZU1hcFtGTE9BVF9NQVQ0XSAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogNjQsIHNldHRlcjogZmxvYXRNYXQ0U2V0dGVyLCAgcm93czogNCwgY29sczogNCwgfTtcbnR5cGVNYXBbRkxPQVRfTUFUMngzXSAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6IDMyLCBzZXR0ZXI6IGZsb2F0TWF0MjNTZXR0ZXIsIHJvd3M6IDIsIGNvbHM6IDMsIH07XG50eXBlTWFwW0ZMT0FUX01BVDJ4NF0gICAgICAgICAgICAgICAgICA9IHsgVHlwZTogRmxvYXQzMkFycmF5LCBzaXplOiAzMiwgc2V0dGVyOiBmbG9hdE1hdDI0U2V0dGVyLCByb3dzOiAyLCBjb2xzOiA0LCB9O1xudHlwZU1hcFtGTE9BVF9NQVQzeDJdICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogNDgsIHNldHRlcjogZmxvYXRNYXQzMlNldHRlciwgcm93czogMywgY29sczogMiwgfTtcbnR5cGVNYXBbRkxPQVRfTUFUM3g0XSAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6IDQ4LCBzZXR0ZXI6IGZsb2F0TWF0MzRTZXR0ZXIsIHJvd3M6IDMsIGNvbHM6IDQsIH07XG50eXBlTWFwW0ZMT0FUX01BVDR4Ml0gICAgICAgICAgICAgICAgICA9IHsgVHlwZTogRmxvYXQzMkFycmF5LCBzaXplOiA2NCwgc2V0dGVyOiBmbG9hdE1hdDQyU2V0dGVyLCByb3dzOiA0LCBjb2xzOiAyLCB9O1xudHlwZU1hcFtGTE9BVF9NQVQ0eDNdICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogNjQsIHNldHRlcjogZmxvYXRNYXQ0M1NldHRlciwgcm93czogNCwgY29sczogMywgfTtcbnR5cGVNYXBbU0FNUExFUl8yRF0gICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV8yRCQxLCAgICAgICB9O1xudHlwZU1hcFtTQU1QTEVSX0NVQkVdICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFX0NVQkVfTUFQLCB9O1xudHlwZU1hcFtTQU1QTEVSXzNEXSAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFXzNELCAgICAgICB9O1xudHlwZU1hcFtTQU1QTEVSXzJEX1NIQURPV10gICAgICAgICAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFXzJEJDEsICAgICAgIH07XG50eXBlTWFwW1NBTVBMRVJfMkRfQVJSQVldICAgICAgICAgICAgICA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfMkRfQVJSQVksIH07XG50eXBlTWFwW1NBTVBMRVJfMkRfQVJSQVlfU0hBRE9XXSAgICAgICA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfMkRfQVJSQVksIH07XG50eXBlTWFwW1NBTVBMRVJfQ1VCRV9TSEFET1ddICAgICAgICAgICA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfQ1VCRV9NQVAsIH07XG50eXBlTWFwW0lOVF9TQU1QTEVSXzJEXSAgICAgICAgICAgICAgICA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfMkQkMSwgICAgICAgfTtcbnR5cGVNYXBbSU5UX1NBTVBMRVJfM0RdICAgICAgICAgICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV8zRCwgICAgICAgfTtcbnR5cGVNYXBbSU5UX1NBTVBMRVJfQ1VCRV0gICAgICAgICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV9DVUJFX01BUCwgfTtcbnR5cGVNYXBbSU5UX1NBTVBMRVJfMkRfQVJSQVldICAgICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV8yRF9BUlJBWSwgfTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfMkRdICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV8yRCQxLCAgICAgICB9O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfU0FNUExFUl8zRF0gICAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFXzNELCAgICAgICB9O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFXSAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFX0NVQkVfTUFQLCB9O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWV0gPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZLCB9O1xuXG5mdW5jdGlvbiBmbG9hdEF0dHJpYlNldHRlcihnbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICBpZiAoYi52YWx1ZSkge1xuICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgIHN3aXRjaCAoYi52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjRmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIzZnYoaW5kZXgsIGIudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZ2wudmVydGV4QXR0cmliMmZ2KGluZGV4LCBiLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjFmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgbGVuZ3RoIG9mIGEgZmxvYXQgY29uc3RhbnQgdmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDQhJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBiLmJ1ZmZlcik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgIGluZGV4LCBiLm51bUNvbXBvbmVudHMgfHwgYi5zaXplLCBiLnR5cGUgfHwgRkxPQVQsIGIubm9ybWFsaXplIHx8IGZhbHNlLCBiLnN0cmlkZSB8fCAwLCBiLm9mZnNldCB8fCAwKTtcbiAgICAgIGlmIChnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKSB7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoaW5kZXgsIGIuZGl2aXNvciB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludEF0dHJpYlNldHRlcihnbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICBpZiAoYi52YWx1ZSkge1xuICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgIGlmIChiLnZhbHVlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0aXYoaW5kZXgsIGIudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGVuZ3RoIG9mIGFuIGludGVnZXIgY29uc3RhbnQgdmFsdWUgbXVzdCBiZSA0IScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgYi5idWZmZXIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgZ2wudmVydGV4QXR0cmliSVBvaW50ZXIoXG4gICAgICAgICAgaW5kZXgsIGIubnVtQ29tcG9uZW50cyB8fCBiLnNpemUsIGIudHlwZSB8fCBJTlQsIGIuc3RyaWRlIHx8IDAsIGIub2Zmc2V0IHx8IDApO1xuICAgICAgaWYgKGdsLnZlcnRleEF0dHJpYkRpdmlzb3IpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCwgYi5kaXZpc29yIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdWludEF0dHJpYlNldHRlcihnbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICBpZiAoYi52YWx1ZSkge1xuICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgIGlmIChiLnZhbHVlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0dWl2KGluZGV4LCBiLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxlbmd0aCBvZiBhbiB1bnNpZ25lZCBpbnRlZ2VyIGNvbnN0YW50IHZhbHVlIG11c3QgYmUgNCEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIsIGIuYnVmZmVyKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYklQb2ludGVyKFxuICAgICAgICAgIGluZGV4LCBiLm51bUNvbXBvbmVudHMgfHwgYi5zaXplLCBiLnR5cGUgfHwgVU5TSUdORURfSU5ULCBiLnN0cmlkZSB8fCAwLCBiLm9mZnNldCB8fCAwKTtcbiAgICAgIGlmIChnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKSB7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoaW5kZXgsIGIuZGl2aXNvciB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hdEF0dHJpYlNldHRlcihnbCwgaW5kZXgsIHR5cGVJbmZvKSB7XG4gIGNvbnN0IGRlZmF1bHRTaXplID0gdHlwZUluZm8uc2l6ZTtcbiAgY29uc3QgY291bnQgPSB0eXBlSW5mby5jb3VudDtcblxuICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBiLmJ1ZmZlcik7XG4gICAgY29uc3QgbnVtQ29tcG9uZW50cyA9IGIuc2l6ZSB8fCBiLm51bUNvbXBvbmVudHMgfHwgZGVmYXVsdFNpemU7XG4gICAgY29uc3Qgc2l6ZSA9IG51bUNvbXBvbmVudHMgLyBjb3VudDtcbiAgICBjb25zdCB0eXBlID0gYi50eXBlIHx8IEZMT0FUO1xuICAgIGNvbnN0IHR5cGVJbmZvID0gdHlwZU1hcFt0eXBlXTtcbiAgICBjb25zdCBzdHJpZGUgPSB0eXBlSW5mby5zaXplICogbnVtQ29tcG9uZW50cztcbiAgICBjb25zdCBub3JtYWxpemUgPSBiLm5vcm1hbGl6ZSB8fCBmYWxzZTtcbiAgICBjb25zdCBvZmZzZXQgPSBiLm9mZnNldCB8fCAwO1xuICAgIGNvbnN0IHJvd09mZnNldCA9IHN0cmlkZSAvIGNvdW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXggKyBpKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgaW5kZXggKyBpLCBzaXplLCB0eXBlLCBub3JtYWxpemUsIHN0cmlkZSwgb2Zmc2V0ICsgcm93T2Zmc2V0ICogaSk7XG4gICAgICBpZiAoZ2wudmVydGV4QXR0cmliRGl2aXNvcikge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGluZGV4ICsgaSwgYi5kaXZpc29yIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuXG5cbmNvbnN0IGF0dHJUeXBlTWFwID0ge307XG5hdHRyVHlwZU1hcFtGTE9BVF0gICAgICAgICAgICAgPSB7IHNpemU6ICA0LCBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyLCB9O1xuYXR0clR5cGVNYXBbRkxPQVRfVkVDMl0gICAgICAgID0geyBzaXplOiAgOCwgc2V0dGVyOiBmbG9hdEF0dHJpYlNldHRlciwgfTtcbmF0dHJUeXBlTWFwW0ZMT0FUX1ZFQzNdICAgICAgICA9IHsgc2l6ZTogMTIsIHNldHRlcjogZmxvYXRBdHRyaWJTZXR0ZXIsIH07XG5hdHRyVHlwZU1hcFtGTE9BVF9WRUM0XSAgICAgICAgPSB7IHNpemU6IDE2LCBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyLCB9O1xuYXR0clR5cGVNYXBbSU5UXSAgICAgICAgICAgICAgID0geyBzaXplOiAgNCwgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXIsICAgfTtcbmF0dHJUeXBlTWFwW0lOVF9WRUMyXSAgICAgICAgICA9IHsgc2l6ZTogIDgsIHNldHRlcjogaW50QXR0cmliU2V0dGVyLCAgIH07XG5hdHRyVHlwZU1hcFtJTlRfVkVDM10gICAgICAgICAgPSB7IHNpemU6IDEyLCBzZXR0ZXI6IGludEF0dHJpYlNldHRlciwgICB9O1xuYXR0clR5cGVNYXBbSU5UX1ZFQzRdICAgICAgICAgID0geyBzaXplOiAxNiwgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXIsICAgfTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF0gICAgICA9IHsgc2l6ZTogIDQsIHNldHRlcjogdWludEF0dHJpYlNldHRlciwgIH07XG5hdHRyVHlwZU1hcFtVTlNJR05FRF9JTlRfVkVDMl0gPSB7IHNpemU6ICA4LCBzZXR0ZXI6IHVpbnRBdHRyaWJTZXR0ZXIsICB9O1xuYXR0clR5cGVNYXBbVU5TSUdORURfSU5UX1ZFQzNdID0geyBzaXplOiAxMiwgc2V0dGVyOiB1aW50QXR0cmliU2V0dGVyLCAgfTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF9WRUM0XSA9IHsgc2l6ZTogMTYsIHNldHRlcjogdWludEF0dHJpYlNldHRlciwgIH07XG5hdHRyVHlwZU1hcFtCT09MXSAgICAgICAgICAgICAgPSB7IHNpemU6ICA0LCBzZXR0ZXI6IGludEF0dHJpYlNldHRlciwgICB9O1xuYXR0clR5cGVNYXBbQk9PTF9WRUMyXSAgICAgICAgID0geyBzaXplOiAgOCwgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXIsICAgfTtcbmF0dHJUeXBlTWFwW0JPT0xfVkVDM10gICAgICAgICA9IHsgc2l6ZTogMTIsIHNldHRlcjogaW50QXR0cmliU2V0dGVyLCAgIH07XG5hdHRyVHlwZU1hcFtCT09MX1ZFQzRdICAgICAgICAgPSB7IHNpemU6IDE2LCBzZXR0ZXI6IGludEF0dHJpYlNldHRlciwgICB9O1xuYXR0clR5cGVNYXBbRkxPQVRfTUFUMl0gICAgICAgID0geyBzaXplOiAgNCwgc2V0dGVyOiBtYXRBdHRyaWJTZXR0ZXIsICAgY291bnQ6IDIsIH07XG5hdHRyVHlwZU1hcFtGTE9BVF9NQVQzXSAgICAgICAgPSB7IHNpemU6ICA5LCBzZXR0ZXI6IG1hdEF0dHJpYlNldHRlciwgICBjb3VudDogMywgfTtcbmF0dHJUeXBlTWFwW0ZMT0FUX01BVDRdICAgICAgICA9IHsgc2l6ZTogMTYsIHNldHRlcjogbWF0QXR0cmliU2V0dGVyLCAgIGNvdW50OiA0LCB9O1xuXG5jb25zdCBlcnJvclJFID0gL0VSUk9SOlxccypcXGQrOihcXGQrKS9naTtcbmZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzV2l0aEVycm9yKHNyYywgbG9nID0gJycsIGxpbmVPZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEVycm9yIG1lc3NhZ2UgZm9ybWF0cyBhcmUgbm90IGRlZmluZWQgYnkgYW55IHNwZWMgc28gdGhpcyBtYXkgb3IgbWF5IG5vdCB3b3JrLlxuICBjb25zdCBtYXRjaGVzID0gWy4uLmxvZy5tYXRjaEFsbChlcnJvclJFKV07XG4gIGNvbnN0IGxpbmVOb1RvRXJyb3JNYXAgPSBuZXcgTWFwKG1hdGNoZXMubWFwKChtLCBuZHgpID0+IHtcbiAgICBjb25zdCBsaW5lTm8gPSBwYXJzZUludChtWzFdKTtcbiAgICBjb25zdCBuZXh0ID0gbWF0Y2hlc1tuZHggKyAxXTtcbiAgICBjb25zdCBlbmQgPSBuZXh0ID8gbmV4dC5pbmRleCA6IGxvZy5sZW5ndGg7XG4gICAgY29uc3QgbXNnID0gbG9nLnN1YnN0cmluZyhtLmluZGV4LCBlbmQpO1xuICAgIHJldHVybiBbbGluZU5vIC0gMSwgbXNnXTtcbiAgfSkpO1xuICByZXR1cm4gc3JjLnNwbGl0KCdcXG4nKS5tYXAoKGxpbmUsIGxpbmVObykgPT4ge1xuICAgIGNvbnN0IGVyciA9IGxpbmVOb1RvRXJyb3JNYXAuZ2V0KGxpbmVObyk7XG4gICAgcmV0dXJuIGAke2xpbmVObyArIDEgKyBsaW5lT2Zmc2V0fTogJHtsaW5lfSR7ZXJyID8gYFxcblxcbl5eXiAke2Vycn1gIDogJyd9YDtcbiAgfSkuam9pbignXFxuJyk7XG59XG5cbi8qKlxuICogRXJyb3IgQ2FsbGJhY2tcbiAqIEBjYWxsYmFjayBFcnJvckNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xpbmVPZmZzZXRdIGFtb3VudCB0byBhZGQgdG8gbGluZSBudW1iZXJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogUHJvZ3JhbSBDYWxsYmFja1xuICogQGNhbGxiYWNrIFByb2dyYW1DYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IFtlcnJdIGVycm9yIG1lc3NhZ2UsIGZhbHN5IGlmIG5vIGVycm9yXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbXxtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb30gW3Jlc3VsdF0gdGhlIHByb2dyYW0gb3IgcHJvZ3JhbUluZm9cbiAqL1xuXG5jb25zdCBzcGFjZVJFID0gL15bIFxcdF0qXFxuLztcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGZpcnN0IGVuZCBvZiBsaW5lIGJlY2F1c2UgV2ViR0wgMi4wIHJlcXVpcmVzXG4gKiAjdmVyc2lvbiAzMDAgZXNcbiAqIGFzIHRoZSBmaXJzdCBsaW5lLiBObyB3aGl0ZXNwYWNlIGFsbG93ZWQgYmVmb3JlIHRoYXQgbGluZVxuICogc29cbiAqXG4gKiA8c2NyaXB0PlxuICogI3ZlcnNpb24gMzAwIGVzXG4gKiA8L3NjcmlwdD5cbiAqXG4gKiBIYXMgb25lIGxpbmUgYmVmb3JlIGl0IHdoaWNoIGlzIGludmFsaWQgYWNjb3JkaW5nIHRvIEdMU0wgRVMgMy4wMFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXJTb3VyY2UgVGhlIHNvdXJjZSBvZiB0aGUgc2hhZGVyXG4gKiBAcmV0dXJucyB7e3NoYWRlclNvdXJjZTogc3RyaW5nLCBsaW5lT2Zmc2V0OiBudW1iZXJ9fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJlcFNoYWRlclNvdXJjZShzaGFkZXJTb3VyY2UpIHtcbiAgbGV0IGxpbmVPZmZzZXQgPSAwO1xuICBpZiAoc3BhY2VSRS50ZXN0KHNoYWRlclNvdXJjZSkpIHtcbiAgICBsaW5lT2Zmc2V0ID0gMTtcbiAgICBzaGFkZXJTb3VyY2UgPSBzaGFkZXJTb3VyY2UucmVwbGFjZShzcGFjZVJFLCAnJyk7XG4gIH1cbiAgcmV0dXJuIHtsaW5lT2Zmc2V0LCBzaGFkZXJTb3VyY2V9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN9IHByb2dPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gKiBAcmV0dXJuIG51bGxcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlcG9ydEVycm9yKHByb2dPcHRpb25zLCBtc2cpIHtcbiAgcHJvZ09wdGlvbnMuZXJyb3JDYWxsYmFjayhtc2cpO1xuICBpZiAocHJvZ09wdGlvbnMuY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHByb2dPcHRpb25zLmNhbGxiYWNrKGAke21zZ31cXG4ke3Byb2dPcHRpb25zLmVycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVjayBTaGFkZXIgc3RhdHVzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc2hhZGVyVHlwZSBUaGUgc2hhZGVyIHR5cGVcbiAqIEBwYXJhbSB7V2ViR0xTaGFkZXJ9IHNoYWRlciBUaGUgc2hhZGVyXG4gKiBAcGFyYW0ge0Vycm9yQ2FsbGJhY2t9IFtlcnJGbl0gZnVuY3Rpb24gdG8gcmVjZWl2ZSBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7c3RyaW5nfSBlcnJvcnMgb3IgZW1wdHkgc3RyaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1NoYWRlclN0YXR1cyhnbCwgc2hhZGVyVHlwZSwgc2hhZGVyLCBlcnJGbikge1xuICBlcnJGbiA9IGVyckZuIHx8IGVycm9yO1xuICAvLyBDaGVjayB0aGUgY29tcGlsZSBzdGF0dXNcbiAgY29uc3QgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBDT01QSUxFX1NUQVRVUyk7XG4gIGlmICghY29tcGlsZWQpIHtcbiAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgY29tcGlsYXRpb247IGdldCB0aGUgZXJyb3JcbiAgICBjb25zdCBsYXN0RXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgY29uc3Qge2xpbmVPZmZzZXQsIHNoYWRlclNvdXJjZX0gPSBwcmVwU2hhZGVyU291cmNlKGdsLmdldFNoYWRlclNvdXJjZShzaGFkZXIpKTtcbiAgICBjb25zdCBlcnJvciA9IGAke2FkZExpbmVOdW1iZXJzV2l0aEVycm9yKHNoYWRlclNvdXJjZSwgbGFzdEVycm9yLCBsaW5lT2Zmc2V0KX1cXG5FcnJvciBjb21waWxpbmcgJHtnbEVudW1Ub1N0cmluZyhnbCwgc2hhZGVyVHlwZSl9OiAke2xhc3RFcnJvcn1gO1xuICAgIGVyckZuKGVycm9yKTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZ1bGxQcm9ncmFtU3BlY1xuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gc2hhZGVycyB0aGUgc2hhZGVyIHNvdXJjZSBvciBlbGVtZW50IGlkcy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oc3RyaW5nKX0gW2Vycm9yQ2FsbGJhY2tdIGNhbGxiYWNrIGZvciBlcnJvcnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPnxzdHJpbmdbXX0gW2F0dHJpYkxvY2F0aW9uc10gYSBhdHRyaWJ1dGUgbmFtZSB0byBsb2NhdGlvbiBtYXAsIG9yIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyB3aGVyZSBpbmRleCA9IGxvY2F0aW9uLlxuICogQHByb3BlcnR5IHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3QuPHN0cmluZyxtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPnxzdHJpbmdbXSl9IFt0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzXSBJZiBwYXNzZWRcbiAqICAgYSBCdWZmZXJJbmZvIHdpbGwgdXNlIHRoZSBhdHRyaWJzIG5hbWVzIGluc2lkZS4gSWYgcGFzc2VkIGFuIG9iamVjdCBvZiBBdHRyaWJJbmZvcyB3aWxsIHVzZSB0aGUgbmFtZXMgZnJvbSB0aGF0IG9iamVjdC4gT3RoZXJ3aXNlXG4gKiAgIHlvdSBjYW4gcGFzcyBhbiBhcnJheSBvZiBuYW1lcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNmb3JtRmVlZGJhY2tNb2RlXSB0aGUgbW9kZSB0byBwYXNzIGBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzYC4gRGVmYXVsdHMgdG8gYFNFUEFSQVRFX0FUVFJJQlNgLlxuICogQHByb3BlcnR5IHtQcm9ncmFtQ2FsbGJhY2t9IFtjYWxsYmFja10gY2FsbGJhY2sgZm9yIGFzeW5jIHByb2dyYW0gY29tcGlsYXRpb24uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmdbXXxtb2R1bGU6dHdnbC5GdWxsUHJvZ3JhbVNwZWN9IFByb2dyYW1TcGVjXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1PcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHN0cmluZyl9IFtlcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLG51bWJlcj58c3RyaW5nW119IFthdHRyaWJMb2NhdGlvbnNdIGEgYXR0cmlidXRlIG5hbWUgdG8gbG9jYXRpb24gbWFwLCBvciBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgd2hlcmUgaW5kZXggPSBsb2NhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7KG1vZHVsZTp0d2dsLkJ1ZmZlckluZm98T2JqZWN0LjxzdHJpbmcsbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz58c3RyaW5nW10pfSBbdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nc10gSWYgcGFzc2VkXG4gKiAgIGEgQnVmZmVySW5mbyB3aWxsIHVzZSB0aGUgYXR0cmlicyBuYW1lcyBpbnNpZGUuIElmIHBhc3NlZCBhbiBvYmplY3Qgb2YgQXR0cmliSW5mb3Mgd2lsbCB1c2UgdGhlIG5hbWVzIGZyb20gdGhhdCBvYmplY3QuIE90aGVyd2lzZVxuICogICB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgb2YgbmFtZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zZm9ybUZlZWRiYWNrTW9kZV0gdGhlIG1vZGUgdG8gcGFzcyBgZ2wudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nc2AuIERlZmF1bHRzIHRvIGBTRVBBUkFURV9BVFRSSUJTYC5cbiAqIEBwcm9wZXJ0eSB7UHJvZ3JhbUNhbGxiYWNrfSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZvciBhc3luYyBwcm9ncmFtIGNvbXBpbGF0aW9uLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9ncmFtIG9wdGlvbnMgYmFzZWQgb24gYWxsIHRoZXNlIG9wdGlvbmFsIGFyZ3VtZW50c1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc3xzdHJpbmdbXX0gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfSBbb3B0X2xvY2F0aW9uc10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN9IGFuIGluc3RhbmNlIG9mIFByb2dyYW1PcHRpb25zIGJhc2VkIG9uIHRoZSBhcmd1bWVudHMgcGFzc2VkIGluXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgbGV0IHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M7XG4gIGxldCB0cmFuc2Zvcm1GZWVkYmFja01vZGU7XG4gIGxldCBjYWxsYmFjaztcbiAgaWYgKHR5cGVvZiBvcHRfbG9jYXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0X2Vycm9yQ2FsbGJhY2sgPSBvcHRfbG9jYXRpb25zO1xuICAgIG9wdF9sb2NhdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRfYXR0cmlicyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdF9lcnJvckNhbGxiYWNrID0gb3B0X2F0dHJpYnM7XG4gICAgb3B0X2F0dHJpYnMgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAob3B0X2F0dHJpYnMgJiYgIUFycmF5LmlzQXJyYXkob3B0X2F0dHJpYnMpKSB7XG4gICAgY29uc3Qgb3B0ID0gb3B0X2F0dHJpYnM7XG4gICAgb3B0X2Vycm9yQ2FsbGJhY2sgPSBvcHQuZXJyb3JDYWxsYmFjaztcbiAgICBvcHRfYXR0cmlicyA9IG9wdC5hdHRyaWJMb2NhdGlvbnM7XG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyA9IG9wdC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzO1xuICAgIHRyYW5zZm9ybUZlZWRiYWNrTW9kZSA9IG9wdC50cmFuc2Zvcm1GZWVkYmFja01vZGU7XG4gICAgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2s7XG4gIH1cblxuICBjb25zdCBlcnJvckNhbGxiYWNrID0gb3B0X2Vycm9yQ2FsbGJhY2sgfHwgZXJyb3I7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGVycm9yQ2FsbGJhY2sobXNnLCAuLi5hcmdzKSB7XG4gICAgICBlcnJvcnMucHVzaChtc2cpO1xuICAgICAgZXJyb3JDYWxsYmFjayhtc2csIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyxcbiAgICB0cmFuc2Zvcm1GZWVkYmFja01vZGUsXG4gICAgY2FsbGJhY2ssXG4gICAgZXJyb3JzLFxuICB9O1xuXG4gIHtcbiAgICBsZXQgYXR0cmliTG9jYXRpb25zID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0X2F0dHJpYnMpKSB7XG4gICAgICBvcHRfYXR0cmlicy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYiwgIG5keCkge1xuICAgICAgICBhdHRyaWJMb2NhdGlvbnNbYXR0cmliXSA9IG9wdF9sb2NhdGlvbnMgPyBvcHRfbG9jYXRpb25zW25keF0gOiBuZHg7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmliTG9jYXRpb25zID0gb3B0X2F0dHJpYnMgfHwge307XG4gICAgfVxuICAgIG9wdGlvbnMuYXR0cmliTG9jYXRpb25zID0gYXR0cmliTG9jYXRpb25zO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmNvbnN0IGRlZmF1bHRTaGFkZXJUeXBlID0gW1xuICBcIlZFUlRFWF9TSEFERVJcIixcbiAgXCJGUkFHTUVOVF9TSEFERVJcIixcbl07XG5cbmZ1bmN0aW9uIGdldFNoYWRlclR5cGVGcm9tU2NyaXB0VHlwZShnbCwgc2NyaXB0VHlwZSkge1xuICBpZiAoc2NyaXB0VHlwZS5pbmRleE9mKFwiZnJhZ1wiKSA+PSAwKSB7XG4gICAgcmV0dXJuIEZSQUdNRU5UX1NIQURFUjtcbiAgfSBlbHNlIGlmIChzY3JpcHRUeXBlLmluZGV4T2YoXCJ2ZXJ0XCIpID49IDApIHtcbiAgICByZXR1cm4gVkVSVEVYX1NIQURFUjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWxldGVQcm9ncmFtQW5kU2hhZGVycyhnbCwgcHJvZ3JhbSwgbm90VGhlc2UpIHtcbiAgY29uc3Qgc2hhZGVycyA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhwcm9ncmFtKTtcbiAgZm9yIChjb25zdCBzaGFkZXIgb2Ygc2hhZGVycykge1xuICAgIGlmIChub3RUaGVzZS5oYXMoc2hhZGVyKSkge1xuICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgfVxuICB9XG4gIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG59XG5cbmNvbnN0IHdhaXQgPSAobXMgPSAwKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbU5vQ2hlY2soZ2wsIHNoYWRlcnMsIHByb2dyYW1PcHRpb25zKSB7XG4gIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGNvbnN0IHtcbiAgICBhdHRyaWJMb2NhdGlvbnMsXG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyxcbiAgICB0cmFuc2Zvcm1GZWVkYmFja01vZGUsXG4gIH0gPSBnZXRQcm9ncmFtT3B0aW9ucyhwcm9ncmFtT3B0aW9ucyk7XG5cbiAgZm9yIChsZXQgbmR4ID0gMDsgbmR4IDwgc2hhZGVycy5sZW5ndGg7ICsrbmR4KSB7XG4gICAgbGV0IHNoYWRlciA9IHNoYWRlcnNbbmR4XTtcbiAgICBpZiAodHlwZW9mIHNoYWRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBnZXRFbGVtZW50QnlJZChzaGFkZXIpO1xuICAgICAgY29uc3Qgc3JjID0gZWxlbSA/IGVsZW0udGV4dCA6IHNoYWRlcjtcbiAgICAgIGxldCB0eXBlID0gZ2xbZGVmYXVsdFNoYWRlclR5cGVbbmR4XV07XG4gICAgICBpZiAoZWxlbSAmJiBlbGVtLnR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGdldFNoYWRlclR5cGVGcm9tU2NyaXB0VHlwZShnbCwgZWxlbS50eXBlKSB8fCB0eXBlO1xuICAgICAgfVxuICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgcHJlcFNoYWRlclNvdXJjZShzcmMpLnNoYWRlclNvdXJjZSk7XG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZW50cmllcyhhdHRyaWJMb2NhdGlvbnMpLmZvckVhY2goKFthdHRyaWIsIGxvY10pID0+IGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBsb2MsIGF0dHJpYikpO1xuXG4gIHtcbiAgICBsZXQgdmFyeWluZ3MgPSB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzO1xuICAgIGlmICh2YXJ5aW5ncykge1xuICAgICAgaWYgKHZhcnlpbmdzLmF0dHJpYnMpIHtcbiAgICAgICAgdmFyeWluZ3MgPSB2YXJ5aW5ncy5hdHRyaWJzO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhcnlpbmdzKSkge1xuICAgICAgICB2YXJ5aW5ncyA9IE9iamVjdC5rZXlzKHZhcnlpbmdzKTtcbiAgICAgIH1cbiAgICAgIGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MocHJvZ3JhbSwgdmFyeWluZ3MsIHRyYW5zZm9ybUZlZWRiYWNrTW9kZSB8fCBTRVBBUkFURV9BVFRSSUJTKTtcbiAgICB9XG4gIH1cblxuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgcmV0dXJuIHByb2dyYW07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb2dyYW0sIGF0dGFjaGVzIChhbmQvb3IgY29tcGlsZXMpIHNoYWRlcnMsIGJpbmRzIGF0dHJpYiBsb2NhdGlvbnMsIGxpbmtzIHRoZVxuICogcHJvZ3JhbS5cbiAqXG4gKiBOT1RFOiBUaGVyZSBhcmUgNCBzaWduYXR1cmVzIGZvciB0aGlzIGZ1bmN0aW9uXG4gKlxuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtXZWJHTFNoYWRlcltdfHN0cmluZ1tdfSBzaGFkZXJzIFRoZSBzaGFkZXJzIHRvIGF0dGFjaCwgb3IgZWxlbWVudCBpZHMgZm9yIHRoZWlyIHNvdXJjZSwgb3Igc3RyaW5ncyB0aGF0IGNvbnRhaW4gdGhlaXIgc291cmNlXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfYXR0cmlic10gT3B0aW9ucyBmb3IgdGhlIHByb2dyYW0gb3IgYW4gYXJyYXkgb2YgYXR0cmlicyBuYW1lcyBvciBhbiBlcnJvciBjYWxsYmFjay4gTG9jYXRpb25zIHdpbGwgYmUgYXNzaWduZWQgYnkgaW5kZXggaWYgbm90IHBhc3NlZCBpblxuICogQHBhcmFtIHtudW1iZXJbXXxtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2xvY2F0aW9uc10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMgb3IgYW4gZXJyb3IgY2FsbGJhY2suXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7V2ViR0xQcm9ncmFtP30gdGhlIGNyZWF0ZWQgcHJvZ3JhbSBvciBudWxsIGlmIGVycm9yIG9mIGEgY2FsbGJhY2sgd2FzIHByb3ZpZGVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oXG4gICAgZ2wsIHNoYWRlcnMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICAvLyBUaGlzIGNvZGUgaXMgcmVhbGx5IGNvbnZvbHV0ZWQsIGJlY2F1c2UgaXQgbWF5IG9yIG1heSBub3QgYmUgYXN5bmNcbiAgLy8gTWF5YmUgaXQgd291bGQgYmUgYmV0dGVyIHRvIGhhdmUgYSBzZXBhcmF0ZSBmdW5jdGlvblxuICBjb25zdCBwcm9nT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIGNvbnN0IHNoYWRlclNldCA9IG5ldyBTZXQoc2hhZGVycyk7XG4gIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtTm9DaGVjayhnbCwgc2hhZGVycywgcHJvZ09wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIGhhc0Vycm9ycyhnbCwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGVycm9ycyA9IGdldFByb2dyYW1FcnJvcnMoZ2wsIHByb2dyYW0sIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2spO1xuICAgIGlmIChlcnJvcnMpIHtcbiAgICAgIGRlbGV0ZVByb2dyYW1BbmRTaGFkZXJzKGdsLCBwcm9ncmFtLCBzaGFkZXJTZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgaWYgKHByb2dPcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgd2FpdEZvclByb2dyYW1MaW5rQ29tcGxldGlvbkFzeW5jKGdsLCBwcm9ncmFtKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IGhhc0Vycm9ycyhnbCwgcHJvZ3JhbSk7XG4gICAgICBwcm9nT3B0aW9ucy5jYWxsYmFjayhlcnJvcnMsIGVycm9ycyA/IHVuZGVmaW5lZCA6IHByb2dyYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gaGFzRXJyb3JzKGdsLCBwcm9ncmFtKSA/IHVuZGVmaW5lZCA6IHByb2dyYW07XG59XG5cbi8qKlxuICogVGhpcyBvbmx5IHdvcmtzIGJlY2F1c2UgdGhlIGZ1bmN0aW9ucyBpdCB3cmFwcyB0aGUgZmlyc3QgMiBhcmd1bWVudHNcbiAqIGFyZSBnbCBhbmQgYW55LCBmb2xsb3dlZCBieSB0aGluZ3MgdGhhdCBiZWNvbWUgcHJvZ3JhbU9wdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdyYXBDYWxsYmFja0ZuVG9Bc3luY0ZuKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbihnbCwgYXJnMSwgLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBwcm9ncmFtT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKC4uLmFyZ3MpO1xuICAgICAgcHJvZ3JhbU9wdGlvbnMuY2FsbGJhY2sgPSAoZXJyLCBwcm9ncmFtKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm4oZ2wsIGFyZzEsIHByb2dyYW1PcHRpb25zKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTYW1lIGFzIGNyZWF0ZVByb2dyYW0gYnV0IHJldHVybnMgYSBwcm9taXNlXG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Bc3luYyhnbCwgW3ZzLCBmc10sIG9wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUFzeW5jKGdsLCBbdnMsIGZzXSwgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUFzeW5jKGdsLCBbdnMsIGZzXSwgb3B0X2F0dHJpYnMsIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Bc3luYyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMU2hhZGVyW118c3RyaW5nW119IHNoYWRlcnMgVGhlIHNoYWRlcnMgdG8gYXR0YWNoLCBvciBlbGVtZW50IGlkcyBmb3IgdGhlaXIgc291cmNlLCBvciBzdHJpbmdzIHRoYXQgY29udGFpbiB0aGVpciBzb3VyY2VcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN8c3RyaW5nW118bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzIG9yIGFuIGVycm9yIGNhbGxiYWNrLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfbG9jYXRpb25zXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucyBvciBhbiBlcnJvciBjYWxsYmFjay5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtQcm9taXNlPFdlYkdMUHJvZ3JhbT59IFRoZSBjcmVhdGVkIHByb2dyYW1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5jb25zdCBjcmVhdGVQcm9ncmFtQXN5bmMgPSB3cmFwQ2FsbGJhY2tGblRvQXN5bmNGbihjcmVhdGVQcm9ncmFtKTtcblxuLyoqXG4gKiBTYW1lIGFzIGNyZWF0ZVByb2dyYW1JbmZvIGJ1dCByZXR1cm5zIGEgcHJvbWlzZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHNoYWRlclNvdXJjZXMgQXJyYXkgb2Ygc291cmNlcyBmb3IgdGhlXG4gKiAgICAgICAgc2hhZGVycyBvciBpZHMuIFRoZSBmaXJzdCBpcyBhc3N1bWVkIHRvIGJlIHRoZSB2ZXJ0ZXggc2hhZGVyLFxuICogICAgICAgIHRoZSBzZWNvbmQgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN8c3RyaW5nW118bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzIG9yIGFuIGVycm9yIGNhbGxiYWNrLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfbG9jYXRpb25zXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucyBvciBhbiBlcnJvciBjYWxsYmFjay5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtQcm9taXNlPG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvPn0gVGhlIGNyZWF0ZWQgUHJvZ3JhbUluZm9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5jb25zdCBjcmVhdGVQcm9ncmFtSW5mb0FzeW5jID0gd3JhcENhbGxiYWNrRm5Ub0FzeW5jRm4oY3JlYXRlUHJvZ3JhbUluZm8pO1xuXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yUHJvZ3JhbUxpbmtDb21wbGV0aW9uQXN5bmMoZ2wsIHByb2dyYW0pIHtcbiAgY29uc3QgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdLSFJfcGFyYWxsZWxfc2hhZGVyX2NvbXBpbGUnKTtcbiAgY29uc3QgY2hlY2tGbiA9IGV4dFxuICAgICAgPyAoZ2wsIHByb2dyYW0pID0+IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZXh0LkNPTVBMRVRJT05fU1RBVFVTX0tIUilcbiAgICAgIDogKCkgPT4gdHJ1ZTtcblxuICBsZXQgd2FpdFRpbWUgPSAwO1xuICBkbyB7XG4gICAgYXdhaXQgd2FpdCh3YWl0VGltZSk7ICAvLyBtdXN0IHdhaXQgYXQgbGVhc3Qgb25jZVxuICAgIHdhaXRUaW1lID0gMTAwMCAvIDYwO1xuICB9IHdoaWxlICghY2hlY2tGbihnbCwgcHJvZ3JhbSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yQWxsUHJvZ3JhbXNMaW5rQ29tcGxldGlvbkFzeW5jKGdsLCBwcm9ncmFtcykge1xuICBmb3IgKGNvbnN0IHByb2dyYW0gb2YgT2JqZWN0LnZhbHVlcyhwcm9ncmFtcykpIHtcbiAgICBhd2FpdCB3YWl0Rm9yUHJvZ3JhbUxpbmtDb21wbGV0aW9uQXN5bmMoZ2wsIHByb2dyYW0pO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgYSBwcm9ncmFtJ3MgbGluayBzdGF0dXNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIFByb2dyYW0gdG8gY2hlY2tcbiAqIEBwYXJhbSB7RXJyb3JDYWxsYmFja30gW2VyckZuXSBmdW5jIGZvciBlcnJvcnNcbiAqIEByZXR1cm4ge3N0cmluZz99IGVycm9ycyBpZiBwcm9ncmFtIGlzIGZhaWxlZCwgZWxzZSB1bmRlZmluZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFByb2dyYW1FcnJvcnMoZ2wsIHByb2dyYW0sIGVyckZuKSB7XG4gIGVyckZuID0gZXJyRm4gfHwgZXJyb3I7XG4gIC8vIENoZWNrIHRoZSBsaW5rIHN0YXR1c1xuICBjb25zdCBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIExJTktfU1RBVFVTKTtcbiAgaWYgKCFsaW5rZWQpIHtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHRoZSBsaW5rXG4gICAgY29uc3QgbGFzdEVycm9yID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XG4gICAgZXJyRm4oYEVycm9yIGluIHByb2dyYW0gbGlua2luZzogJHtsYXN0RXJyb3J9YCk7XG4gICAgLy8gcHJpbnQgYW55IGVycm9ycyBmcm9tIHRoZXNlIHNoYWRlcnNcbiAgICBjb25zdCBzaGFkZXJzID0gZ2wuZ2V0QXR0YWNoZWRTaGFkZXJzKHByb2dyYW0pO1xuICAgIGNvbnN0IGVycm9ycyA9IHNoYWRlcnMubWFwKHNoYWRlciA9PiBjaGVja1NoYWRlclN0YXR1cyhnbCwgZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuU0hBREVSX1RZUEUpLCBzaGFkZXIsIGVyckZuKSk7XG4gICAgcmV0dXJuIGAke2xhc3RFcnJvcn1cXG4ke2Vycm9ycy5maWx0ZXIoXyA9PiBfKS5qb2luKCdcXG4nKX1gO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb2dyYW0gZnJvbSAyIHNjcmlwdCB0YWdzLlxuICpcbiAqIE5PVEU6IFRoZXJlIGFyZSA0IHNpZ25hdHVyZXMgZm9yIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNjcmlwdHMoZ2wsIFt2cywgZnNdLCBvcHRfb3B0aW9ucyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNjcmlwdHMoZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNjcmlwdHMoZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKGdsLCBbdnMsIGZzXSwgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJGdW5jKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHNoYWRlclNjcmlwdElkcyBBcnJheSBvZiBpZHMgb2YgdGhlIHNjcmlwdFxuICogICAgICAgIHRhZ3MgZm9yIHRoZSBzaGFkZXJzLiBUaGUgZmlyc3QgaXMgYXNzdW1lZCB0byBiZSB0aGVcbiAqICAgICAgICB2ZXJ0ZXggc2hhZGVyLCB0aGUgc2Vjb25kIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfYXR0cmlic10gT3B0aW9ucyBmb3IgdGhlIHByb2dyYW0gb3IgYW4gYXJyYXkgb2YgYXR0cmlicyBuYW1lcyBvciBhbiBlcnJvciBjYWxsYmFjay4gTG9jYXRpb25zIHdpbGwgYmUgYXNzaWduZWQgYnkgaW5kZXggaWYgbm90IHBhc3NlZCBpblxuICogQHBhcmFtIHtudW1iZXJbXXxtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2xvY2F0aW9uc10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMgb3IgYW4gZXJyb3IgY2FsbGJhY2suXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7V2ViR0xQcm9ncmFtP30gdGhlIGNyZWF0ZWQgcHJvZ3JhbSBvciBudWxsIGlmIGVycm9yIG9yIGEgY2FsbGJhY2sgd2FzIHByb3ZpZGVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhcbiAgICBnbCwgc2hhZGVyU2NyaXB0SWRzLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgY29uc3QgcHJvZ09wdGlvbnMgPSBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICBjb25zdCBzaGFkZXJzID0gW107XG4gIGZvciAoY29uc3Qgc2NyaXB0SWQgb2Ygc2hhZGVyU2NyaXB0SWRzKSB7XG4gICAgY29uc3Qgc2hhZGVyU2NyaXB0ID0gZ2V0RWxlbWVudEJ5SWQoc2NyaXB0SWQpO1xuICAgIGlmICghc2hhZGVyU2NyaXB0KSB7XG4gICAgICByZXR1cm4gcmVwb3J0RXJyb3IocHJvZ09wdGlvbnMsIGB1bmtub3duIHNjcmlwdCBlbGVtZW50OiAke3NjcmlwdElkfWApO1xuICAgIH1cbiAgICBzaGFkZXJzLnB1c2goc2hhZGVyU2NyaXB0LnRleHQpO1xuICB9XG4gIHJldHVybiBjcmVhdGVQcm9ncmFtKGdsLCBzaGFkZXJzLCBwcm9nT3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb2dyYW0gZnJvbSAyIHNvdXJjZXMuXG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU291cmNlKGdsLCBbdnMsIGZzXSwgb3B0X29wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UoZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNvdXJjZShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNvdXJjZShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMgZm9yIHRoZVxuICogICAgICAgIHNoYWRlcnMuIFRoZSBmaXJzdCBpcyBhc3N1bWVkIHRvIGJlIHRoZSB2ZXJ0ZXggc2hhZGVyLFxuICogICAgICAgIHRoZSBzZWNvbmQgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN8c3RyaW5nW118bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzIG9yIGFuIGVycm9yIGNhbGxiYWNrLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfbG9jYXRpb25zXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucyBvciBhbiBlcnJvciBjYWxsYmFjay5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW0/fSB0aGUgY3JlYXRlZCBwcm9ncmFtIG9yIG51bGwgaWYgZXJyb3Igb3IgYSBjYWxsYmFjayB3YXMgcHJvdmlkZWQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzKFxuICAgIGdsLCBzaGFkZXJTb3VyY2VzLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgcmV0dXJuIGNyZWF0ZVByb2dyYW0oZ2wsIHNoYWRlclNvdXJjZXMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGF0dHJpYnV0ZS91bmlmb3JtIGlzIGEgcmVzZXJ2ZWQvYnVpbHQgaW5cbiAqXG4gKiBJdCBtYWtlcyBubyBzZW5zZSB0byBtZSB3aHkgR0wgcmV0dXJucyB0aGVzZSBiZWNhdXNlIGl0J3NcbiAqIGlsbGVnYWwgdG8gY2FsbCBgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uYCBhbmQgYGdsLmdldEF0dHJpYkxvY2F0aW9uYFxuICogd2l0aCBuYW1lcyB0aGF0IHN0YXJ0IHdpdGggYGdsX2AgKGFuZCBgd2ViZ2xfYCBpbiBXZWJHTClcbiAqXG4gKiBJIGNhbiBvbmx5IGFzc3VtZSB0aGV5IGFyZSB0aGVyZSBiZWNhdXNlIHRoZXkgbWlnaHQgY291bnRcbiAqIHdoZW4gY29tcHV0aW5nIHRoZSBudW1iZXIgb2YgdW5pZm9ybXMvYXR0cmlidXRlcyB1c2VkIHdoZW4geW91IHdhbnQgdG9cbiAqIGtub3cgaWYgeW91IGFyZSBuZWFyIHRoZSBsaW1pdC4gVGhhdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlXG4gKiB0byBtZSBidXQgdGhlIGZhY3QgdGhhdCB0aGVzZSBnZXQgcmV0dXJuZWQgYXJlIGluIHRoZSBzcGVjLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xBY3RpdmVJbmZvfSBpbmZvIEFzIHJldHVybmVkIGZyb20gYGdsLmdldEFjdGl2ZVVuaWZvcm1gIG9yXG4gKiAgICBgZ2wuZ2V0QWN0aXZlQXR0cmliYC5cbiAqIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaXQncyByZXNlcnZlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCdWlsdEluKGluZm8pIHtcbiAgY29uc3QgbmFtZSA9IGluZm8ubmFtZTtcbiAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aChcImdsX1wiKSB8fCBuYW1lLnN0YXJ0c1dpdGgoXCJ3ZWJnbF9cIik7XG59XG5cbmNvbnN0IHRva2VuUkUgPSAvKFxcLnxcXFt8XXxcXHcrKS9nO1xuY29uc3QgaXNEaWdpdCA9IHMgPT4gcyA+PSAnMCcgJiYgcyA8PSAnOSc7XG5mdW5jdGlvbiBhZGRTZXR0ZXJUb1VuaWZvcm1UcmVlKGZ1bGxQYXRoLCBzZXR0ZXIsIG5vZGUsIHVuaWZvcm1TZXR0ZXJzKSB7XG4gIGNvbnN0IHRva2VucyA9IGZ1bGxQYXRoLnNwbGl0KHRva2VuUkUpLmZpbHRlcihzID0+IHMgIT09ICcnKTtcbiAgbGV0IHRva2VuTmR4ID0gMDtcbiAgbGV0IHBhdGggPSAnJztcblxuICBmb3IgKDs7KSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbdG9rZW5OZHgrK107ICAvLyBoYXMgdG8gYmUgbmFtZSBvciBudW1iZXJcbiAgICBwYXRoICs9IHRva2VuO1xuICAgIGNvbnN0IGlzQXJyYXlJbmRleCA9IGlzRGlnaXQodG9rZW5bMF0pO1xuICAgIGNvbnN0IGFjY2Vzc29yID0gaXNBcnJheUluZGV4XG4gICAgICAgID8gcGFyc2VJbnQodG9rZW4pXG4gICAgICAgIDogdG9rZW47XG4gICAgaWYgKGlzQXJyYXlJbmRleCkge1xuICAgICAgcGF0aCArPSB0b2tlbnNbdG9rZW5OZHgrK107ICAvLyBza2lwICddJ1xuICAgIH1cbiAgICBjb25zdCBpc0xhc3RUb2tlbiA9IHRva2VuTmR4ID09PSB0b2tlbnMubGVuZ3RoO1xuICAgIGlmIChpc0xhc3RUb2tlbikge1xuICAgICAgbm9kZVthY2Nlc3Nvcl0gPSBzZXR0ZXI7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbdG9rZW5OZHgrK107ICAvLyBoYXMgdG8gYmUgLiBvciBbXG4gICAgICBjb25zdCBpc0FycmF5ID0gdG9rZW4gPT09ICdbJztcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZVthY2Nlc3Nvcl0gfHwgKGlzQXJyYXkgPyBbXSA6IHt9KTtcbiAgICAgIG5vZGVbYWNjZXNzb3JdID0gY2hpbGQ7XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgICB1bmlmb3JtU2V0dGVyc1twYXRoXSA9IHVuaWZvcm1TZXR0ZXJzW3BhdGhdIHx8IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgc2V0VW5pZm9ybVRyZWUobm9kZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgfShjaGlsZCk7XG4gICAgICBwYXRoICs9IHRva2VuO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgc2V0dGVyIGZ1bmN0aW9ucyBmb3IgYWxsIHVuaWZvcm1zIG9mIGEgc2hhZGVyXG4gKiBwcm9ncmFtLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldFVuaWZvcm1zfVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIHRoZSBwcm9ncmFtIHRvIGNyZWF0ZSBzZXR0ZXJzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBhbiBvYmplY3Qgd2l0aCBhIHNldHRlciBieSBuYW1lIGZvciBlYWNoIHVuaWZvcm1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtU2V0dGVycyhnbCwgcHJvZ3JhbSkge1xuICBsZXQgdGV4dHVyZVVuaXQgPSAwO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2V0dGVyIGZvciBhIHVuaWZvcm0gb2YgdGhlIGdpdmVuIHByb2dyYW0gd2l0aCBpdCdzXG4gICAqIGxvY2F0aW9uIGVtYmVkZGVkIGluIHRoZSBzZXR0ZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtXG4gICAqIEBwYXJhbSB7V2ViR0xVbmlmb3JtSW5mb30gdW5pZm9ybUluZm9cbiAgICogQHJldHVybnMge2Z1bmN0aW9ufSB0aGUgY3JlYXRlZCBzZXR0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVVbmlmb3JtU2V0dGVyKHByb2dyYW0sIHVuaWZvcm1JbmZvLCBsb2NhdGlvbikge1xuICAgIGNvbnN0IGlzQXJyYXkgPSB1bmlmb3JtSW5mby5uYW1lLmVuZHNXaXRoKFwiWzBdXCIpO1xuICAgIGNvbnN0IHR5cGUgPSB1bmlmb3JtSW5mby50eXBlO1xuICAgIGNvbnN0IHR5cGVJbmZvID0gdHlwZU1hcFt0eXBlXTtcbiAgICBpZiAoIXR5cGVJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogMHgke3R5cGUudG9TdHJpbmcoMTYpfWApOyAvLyB3ZSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmUuXG4gICAgfVxuICAgIGxldCBzZXR0ZXI7XG4gICAgaWYgKHR5cGVJbmZvLmJpbmRQb2ludCkge1xuICAgICAgLy8gaXQncyBhIHNhbXBsZXJcbiAgICAgIGNvbnN0IHVuaXQgPSB0ZXh0dXJlVW5pdDtcbiAgICAgIHRleHR1cmVVbml0ICs9IHVuaWZvcm1JbmZvLnNpemU7XG4gICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5hcnJheVNldHRlcihnbCwgdHlwZSwgdW5pdCwgbG9jYXRpb24sIHVuaWZvcm1JbmZvLnNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dGVyID0gdHlwZUluZm8uc2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgdW5pZm9ybUluZm8uc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlSW5mby5hcnJheVNldHRlciAmJiBpc0FycmF5KSB7XG4gICAgICAgIHNldHRlciA9IHR5cGVJbmZvLmFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0dGVyLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgcmV0dXJuIHNldHRlcjtcbiAgfVxuXG4gIGNvbnN0IHVuaWZvcm1TZXR0ZXJzID0ge307XG4gIGNvbnN0IHVuaWZvcm1UcmVlID0ge307XG4gIGNvbnN0IG51bVVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBBQ1RJVkVfVU5JRk9STVMpO1xuXG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBudW1Vbmlmb3JtczsgKytpaSkge1xuICAgIGNvbnN0IHVuaWZvcm1JbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpaSk7XG4gICAgaWYgKGlzQnVpbHRJbih1bmlmb3JtSW5mbykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgbmFtZSA9IHVuaWZvcm1JbmZvLm5hbWU7XG4gICAgLy8gcmVtb3ZlIHRoZSBhcnJheSBzdWZmaXguXG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoXCJbMF1cIikpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIDMpO1xuICAgIH1cbiAgICBjb25zdCBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtSW5mby5uYW1lKTtcbiAgICAvLyB0aGUgdW5pZm9ybSB3aWxsIGhhdmUgbm8gbG9jYXRpb24gaWYgaXQncyBpbiBhIHVuaWZvcm0gYmxvY2tcbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGNvbnN0IHNldHRlciA9IGNyZWF0ZVVuaWZvcm1TZXR0ZXIocHJvZ3JhbSwgdW5pZm9ybUluZm8sIGxvY2F0aW9uKTtcbiAgICAgIHVuaWZvcm1TZXR0ZXJzW25hbWVdID0gc2V0dGVyO1xuICAgICAgYWRkU2V0dGVyVG9Vbmlmb3JtVHJlZShuYW1lLCBzZXR0ZXIsIHVuaWZvcm1UcmVlLCB1bmlmb3JtU2V0dGVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuaWZvcm1TZXR0ZXJzO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zZm9ybUZlZWRiYWNrSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4IGluZGV4IG9mIHRyYW5zZm9ybSBmZWVkYmFja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGUgR0wgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemUgMSAtIDRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlIFRyYW5zZm9ybUZlZWRiYWNrSW5mbyBmb3IgcGFzc2luZyB0byBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW0gYW4gZXhpc3RpbmcgV2ViR0xQcm9ncmFtLlxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgbW9kdWxlOnR3Z2wuVHJhbnNmb3JtRmVlZGJhY2tJbmZvPn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8oZ2wsIHByb2dyYW0pIHtcbiAgY29uc3QgaW5mbyA9IHt9O1xuICBjb25zdCBudW1WYXJ5aW5ncyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgVFJBTlNGT1JNX0ZFRURCQUNLX1ZBUllJTkdTKTtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG51bVZhcnlpbmdzOyArK2lpKSB7XG4gICAgY29uc3QgdmFyeWluZyA9IGdsLmdldFRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZyhwcm9ncmFtLCBpaSk7XG4gICAgaW5mb1t2YXJ5aW5nLm5hbWVdID0ge1xuICAgICAgaW5kZXg6IGlpLFxuICAgICAgdHlwZTogdmFyeWluZy50eXBlLFxuICAgICAgc2l6ZTogdmFyeWluZy5zaXplLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogQmluZHMgYnVmZmVycyBmb3IgdHJhbnNmb3JtIGZlZWRiYWNrLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfE9iamVjdDxzdHJpbmcsIG1vZHVsZTp0d2dsLlRyYW5zZm9ybUZlZWRiYWNrSW5mbz4pfSB0cmFuc2Zvcm1GZWVkYmFja0luZm8gQSBQcm9ncmFtSW5mbyBvciBUcmFuc2Zvcm1GZWVkYmFja0luZm8uXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfE9iamVjdDxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+KX0gW2J1ZmZlckluZm9dIEEgQnVmZmVySW5mbyBvciBzZXQgb2YgQXR0cmliSW5mb3MuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuZnVuY3Rpb24gYmluZFRyYW5zZm9ybUZlZWRiYWNrSW5mbyhnbCwgdHJhbnNmb3JtRmVlZGJhY2tJbmZvLCBidWZmZXJJbmZvKSB7XG4gIGlmICh0cmFuc2Zvcm1GZWVkYmFja0luZm8udHJhbnNmb3JtRmVlZGJhY2tJbmZvKSB7XG4gICAgdHJhbnNmb3JtRmVlZGJhY2tJbmZvID0gdHJhbnNmb3JtRmVlZGJhY2tJbmZvLnRyYW5zZm9ybUZlZWRiYWNrSW5mbztcbiAgfVxuICBpZiAoYnVmZmVySW5mby5hdHRyaWJzKSB7XG4gICAgYnVmZmVySW5mbyA9IGJ1ZmZlckluZm8uYXR0cmlicztcbiAgfVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gYnVmZmVySW5mbykge1xuICAgIGNvbnN0IHZhcnlpbmcgPSB0cmFuc2Zvcm1GZWVkYmFja0luZm9bbmFtZV07XG4gICAgaWYgKHZhcnlpbmcpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IGJ1ZmZlckluZm9bbmFtZV07XG4gICAgICBpZiAoYnVmLm9mZnNldCkge1xuICAgICAgICBnbC5iaW5kQnVmZmVyUmFuZ2UoVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgdmFyeWluZy5pbmRleCwgYnVmLmJ1ZmZlciwgYnVmLm9mZnNldCwgYnVmLnNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlckJhc2UoVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgdmFyeWluZy5pbmRleCwgYnVmLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBmZWVkYmFjayBhbmQgc2V0cyB0aGUgYnVmZmVyc1xuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb30gcHJvZ3JhbUluZm8gQSBQcm9ncmFtSW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb31cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLkJ1ZmZlckluZm98T2JqZWN0PHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz4pfSBbYnVmZmVySW5mb10gQSBCdWZmZXJJbmZvIG9yIHNldCBvZiBBdHRyaWJJbmZvcy5cbiAqIEByZXR1cm4ge1dlYkdMVHJhbnNmb3JtRmVlZGJhY2t9IHRoZSBjcmVhdGVkIHRyYW5zZm9ybSBmZWVkYmFja1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbykge1xuICBjb25zdCB0ZiA9IGdsLmNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG4gIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhUUkFOU0ZPUk1fRkVFREJBQ0ssIHRmKTtcbiAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtSW5mby5wcm9ncmFtKTtcbiAgYmluZFRyYW5zZm9ybUZlZWRiYWNrSW5mbyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuICBnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsKTtcbiAgcmV0dXJuIHRmO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVuaWZvcm1EYXRhXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdW5pZm9ybVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGUgVGhlIFdlYkdMIHR5cGUgZW51bSBmb3IgdGhpcyB1bmlmb3JtXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB0aGlzIHVuaWZvcm1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja05keCBUaGUgYmxvY2sgaW5kZXggdGhpcyB1bmlmb3JtIGFwcGVhcnMgaW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgVGhlIGJ5dGUgb2Zmc2V0IGluIHRoZSBibG9jayBmb3IgdGhpcyB1bmlmb3JtJ3MgdmFsdWVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogVGhlIHNwZWNpZmljYXRpb24gZm9yIG9uZSBVbmlmb3JtQmxvY2tPYmplY3RcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCbG9ja1NwZWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGJsb2NrLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemUgVGhlIHNpemUgaW4gYnl0ZXMgbmVlZGVkIGZvciB0aGUgYmxvY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHVuaWZvcm1JbmRpY2VzIFRoZSBpbmRpY2VzIG9mIHRoZSB1bmlmb3JtcyB1c2VkIGJ5IHRoZSBibG9jay4gVGhlc2UgaW5kaWNlc1xuICogICAgY29ycmVzcG9uZCB0byBlbnRyaWVzIGluIGEgVW5pZm9ybURhdGEgYXJyYXkgaW4gdGhlIHtAbGluayBtb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tTcGVjfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gdXNlZEJ5VmVydGV4U2hhZGVyIFNlbGYgZXhwbGFuYXRvcnlcbiAqIEBwcm9wZXJ0eSB7Ym9vbH0gdXNlZEJ5RnJhZ21lbnRTaGFkZXIgU2VsZiBleHBsYW5hdG9yeVxuICogQHByb3BlcnR5IHtib29sfSB1c2VkIFNlbGYgZXhwbGFuYXRvcnlcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQSBgVW5pZm9ybUJsb2NrU3BlY2AgcmVwcmVzZW50cyB0aGUgZGF0YSBuZWVkZWQgdG8gY3JlYXRlIGFuZCBiaW5kXG4gKiBVbmlmb3JtQmxvY2tPYmplY3RzIGZvciBhIGdpdmVuIHByb2dyYW1cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmlmb3JtQmxvY2tTcGVjXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBtb2R1bGU6dHdnbC5CbG9ja1NwZWM+fSBibG9ja1NwZWNzIFRoZSBCbG9ja1NwZWMgZm9yIGVhY2ggYmxvY2sgYnkgYmxvY2sgbmFtZVxuICogQHByb3BlcnR5IHtVbmlmb3JtRGF0YVtdfSB1bmlmb3JtRGF0YSBBbiBhcnJheSBvZiBkYXRhIGZvciBlYWNoIHVuaWZvcm0gYnkgdW5pZm9ybSBpbmRleC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIFVuaWZvcm1CbG9ja1NwZWMgZm9yIHRoZSBnaXZlbiBwcm9ncmFtLlxuICpcbiAqIEEgVW5pZm9ybUJsb2NrU3BlYyByZXByZXNlbnRzIHRoZSBkYXRhIG5lZWRlZCB0byBjcmVhdGUgYW5kIGJpbmRcbiAqIFVuaWZvcm1CbG9ja09iamVjdHNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wyIFJlbmRlcmluZyBDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBBIFdlYkdMUHJvZ3JhbSBmb3IgYSBzdWNjZXNzZnVsbHkgbGlua2VkIHByb2dyYW1cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWN9IFRoZSBjcmVhdGVkIFVuaWZvcm1CbG9ja1NwZWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW0oZ2wsIHByb2dyYW0pIHtcbiAgY29uc3QgbnVtVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIEFDVElWRV9VTklGT1JNUyk7XG4gIGNvbnN0IHVuaWZvcm1EYXRhID0gW107XG4gIGNvbnN0IHVuaWZvcm1JbmRpY2VzID0gW107XG5cbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG51bVVuaWZvcm1zOyArK2lpKSB7XG4gICAgdW5pZm9ybUluZGljZXMucHVzaChpaSk7XG4gICAgdW5pZm9ybURhdGEucHVzaCh7fSk7XG4gICAgY29uc3QgdW5pZm9ybUluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGlpKTtcbiAgICB1bmlmb3JtRGF0YVtpaV0ubmFtZSA9IHVuaWZvcm1JbmZvLm5hbWU7XG4gIH1cblxuICBbXG4gICAgWyBcIlVOSUZPUk1fVFlQRVwiLCBcInR5cGVcIiBdLFxuICAgIFsgXCJVTklGT1JNX1NJWkVcIiwgXCJzaXplXCIgXSwgIC8vIG51bSBlbGVtZW50c1xuICAgIFsgXCJVTklGT1JNX0JMT0NLX0lOREVYXCIsIFwiYmxvY2tOZHhcIiBdLFxuICAgIFsgXCJVTklGT1JNX09GRlNFVFwiLCBcIm9mZnNldFwiLCBdLFxuICBdLmZvckVhY2goZnVuY3Rpb24ocGFpcikge1xuICAgIGNvbnN0IHBuYW1lID0gcGFpclswXTtcbiAgICBjb25zdCBrZXkgPSBwYWlyWzFdO1xuICAgIGdsLmdldEFjdGl2ZVVuaWZvcm1zKHByb2dyYW0sIHVuaWZvcm1JbmRpY2VzLCBnbFtwbmFtZV0pLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5keCkge1xuICAgICAgdW5pZm9ybURhdGFbbmR4XVtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IGJsb2NrU3BlY3MgPSB7fTtcblxuICBjb25zdCBudW1Vbmlmb3JtQmxvY2tzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBBQ1RJVkVfVU5JRk9STV9CTE9DS1MpO1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbnVtVW5pZm9ybUJsb2NrczsgKytpaSkge1xuICAgIGNvbnN0IG5hbWUgPSBnbC5nZXRBY3RpdmVVbmlmb3JtQmxvY2tOYW1lKHByb2dyYW0sIGlpKTtcbiAgICBjb25zdCBibG9ja1NwZWMgPSB7XG4gICAgICBpbmRleDogZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgocHJvZ3JhbSwgbmFtZSksXG4gICAgICB1c2VkQnlWZXJ0ZXhTaGFkZXI6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBpaSwgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVIpLFxuICAgICAgdXNlZEJ5RnJhZ21lbnRTaGFkZXI6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBpaSwgVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX0ZSQUdNRU5UX1NIQURFUiksXG4gICAgICBzaXplOiBnbC5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIocHJvZ3JhbSwgaWksIFVOSUZPUk1fQkxPQ0tfREFUQV9TSVpFKSxcbiAgICAgIHVuaWZvcm1JbmRpY2VzOiBnbC5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIocHJvZ3JhbSwgaWksIFVOSUZPUk1fQkxPQ0tfQUNUSVZFX1VOSUZPUk1fSU5ESUNFUyksXG4gICAgfTtcbiAgICBibG9ja1NwZWMudXNlZCA9IGJsb2NrU3BlYy51c2VkQnlWZXJ0ZXhTaGFkZXIgfHwgYmxvY2tTcGVjLnVzZWRCeUZyYWdtZW50U2hhZGVyO1xuICAgIGJsb2NrU3BlY3NbbmFtZV0gPSBibG9ja1NwZWM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJsb2NrU3BlY3M6IGJsb2NrU3BlY3MsXG4gICAgdW5pZm9ybURhdGE6IHVuaWZvcm1EYXRhLFxuICB9O1xufVxuXG5jb25zdCBhcnJheVN1ZmZpeFJFID0gL1xcW1xcZCtcXF1cXC4kLzsgIC8vIGJldHRlciB3YXkgdG8gY2hlY2s/XG5cbmNvbnN0IHBhZCA9ICh2LCBwYWRkaW5nKSA9PiAoKHYgKyAocGFkZGluZyAtIDEpKSAvIHBhZGRpbmcgfCAwKSAqIHBhZGRpbmc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1CbG9ja1VuaWZvcm1TZXR0ZXIodmlldywgaXNBcnJheSwgcm93cywgY29scykge1xuICBpZiAoaXNBcnJheSB8fCByb3dzKSB7XG4gICAgY29scyA9IGNvbHMgfHwgMTtcbiAgICBjb25zdCBudW1FbGVtZW50cyA9IHZpZXcubGVuZ3RoO1xuICAgIGNvbnN0IHRvdGFsUm93cyA9IG51bUVsZW1lbnRzIC8gNDtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGxldCBkc3QgPSAwO1xuICAgICAgbGV0IHNyYyA9IDA7XG4gICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0b3RhbFJvd3M7ICsrcm93KSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHM7ICsrY29sKSB7XG4gICAgICAgICAgdmlld1tkc3QrK10gPSB2YWx1ZVtzcmMrK107XG4gICAgICAgIH1cbiAgICAgICAgZHN0ICs9IDQgLSBjb2xzO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZpZXcuc2V0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXdbMF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIFVuaWZvcm1CbG9ja09iamVjdCBpbmNsdWRpbmcgYW4gQXJyYXlCdWZmZXIgd2l0aCBhbGwgdGhlIHVuaWZvcm0gdmFsdWVzXG4gKiBhbmQgYSBjb3JyZXNwb25kaW5nIFdlYkdMQnVmZmVyIHRvIGhvbGQgdGhvc2UgdmFsdWVzIG9uIHRoZSBHUFVcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmlmb3JtQmxvY2tJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYmxvY2tcbiAqIEBwcm9wZXJ0eSB7QXJyYXlCdWZmZXJ9IGFycmF5IFRoZSBhcnJheSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgdW5pZm9ybSB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBhc0Zsb2F0IEEgZmxvYXQgdmlldyBvbiB0aGUgYXJyYXkgYnVmZmVyLiBUaGlzIGlzIHVzZWZ1bFxuICogICAgaW5zcGVjdGluZyB0aGUgY29udGVudHMgb2YgdGhlIGJ1ZmZlciBpbiB0aGUgZGVidWdnZXIuXG4gKiBAcHJvcGVydHkge1dlYkdMQnVmZmVyfSBidWZmZXIgQSBXZWJHTCBidWZmZXIgdGhhdCB3aWxsIGhvbGQgYSBjb3B5IG9mIHRoZSB1bmlmb3JtIHZhbHVlcyBmb3IgcmVuZGVyaW5nLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRdIG9mZnNldCBpbnRvIGJ1ZmZlclxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBBcnJheUJ1ZmZlclZpZXc+fSB1bmlmb3JtcyBBIHVuaWZvcm0gbmFtZSB0byBBcnJheUJ1ZmZlclZpZXcgbWFwLlxuICogICBlYWNoIFVuaWZvcm0gaGFzIGEgY29ycmVjdGx5IHR5cGVkIGBBcnJheUJ1ZmZlclZpZXdgIGludG8gYXJyYXkgYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0XG4gKiAgIGFuZCBsZW5ndGggb2YgdGhhdCB1bmlmb3JtLiBTbyBmb3IgZXhhbXBsZSBhIGZsb2F0IHVuaWZvcm0gd291bGQgaGF2ZSBhIDEgZmxvYXQgYEZsb2F0MzJBcnJheWBcbiAqICAgdmlldy4gQSBzaW5nbGUgbWF0NCB3b3VsZCBoYXZlIGEgMTYgZWxlbWVudCBgRmxvYXQzMkFycmF5YCB2aWV3LiBBbiBpdmVjMiB3b3VsZCBoYXZlIGFuXG4gKiAgIGBJbnQzMkFycmF5YCB2aWV3LCBldGMuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIGZ1bmN0aW9uPn0gc2V0dGVycyBBIHNldHRlciBmb3IgdGhpcyB1bmlmb3JtLlxuICogICBUaGUgcmVhc29uIHRvIHVzZSBzZXR0ZXJzIGlzIGVsZW1lbnRzIG9mIGFycmF5cyBhcmUgcGFkZGVkIHRvIHZlYzQgc2l6ZXMgd2hpY2hcbiAqICAgbWVhbnMgaWYgeW91IHdhbnQgdG8gc2V0IGFuIGFycmF5IG9mIDQgZmxvYXRzIHlvdSdkIG5lZWQgdG8gc2V0IDE2IHZhbHVlc1xuICogICAob3Igc2V0IGVsZW1lbnRzIDAsIDQsIDgsIDEyKS4gSW4gb3RoZXIgd29yZHNcbiAqICAgYHNvbWVCbG9ja0luZm8udW5pZm9ybXMuc29tZTRGbG9hdEFycmF5VW5pZm9ybS5zZXQoWzAsICwgLCAsIDEsICwgLCAsIDIsICwgLCAsIDNdKWBcbiAqICAgd2hlcmUgYXMgdGhlIHNldHRlciBoYW5kbGVzIGp1c3QgcGFzc2luZyBpbiBbMCwgMSwgMiwgM10gZWl0aGVyIGRpcmVjdGx5IGFzIGluXG4gKiAgIGBzb21lQmxvY2tJbmZvLnNldHRlci5zb21lNEZsb2F0QXJyYXlVbmlmb3JtLnNldChbMCwgMSwgMiwgM10pYCAobm90IHJlY29tbWVuZGVkKVxuICogICBvciB2aWEge0BsaW5rIG1vZHVsZTp0d2dsLnNldEJsb2NrVW5pZm9ybXN9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgVW5pZm9ybUJsb2NrSW5mb2AgZm9yIHRoZSBzcGVjaWZpZWQgYmxvY2tcbiAqXG4gKiBOb3RlOiAqKklmIHRoZSBibG9ja05hbWUgbWF0Y2hlcyBubyBleGlzdGluZyBibG9ja3MgYSB3YXJuaW5nIGlzIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUgYW5kIGEgZHVtbXlcbiAqIGBVbmlmb3JtQmxvY2tJbmZvYCBpcyByZXR1cm5lZCoqLiBUaGlzIGlzIGJlY2F1c2Ugd2hlbiBkZWJ1Z2dpbmcgR0xTTFxuICogaXQgaXMgY29tbW9uIHRvIGNvbW1lbnQgb3V0IGxhcmdlIHBvcnRpb25zIG9mIGEgc2hhZGVyIG9yIGZvciBleGFtcGxlIHNldFxuICogdGhlIGZpbmFsIG91dHB1dCB0byBhIGNvbnN0YW50LiBXaGVuIHRoYXQgaGFwcGVucyBibG9ja3MgZ2V0IG9wdGltaXplZCBvdXQuXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGRpZCBub3QgY3JlYXRlIGR1bW15IGJsb2NrcyB5b3VyIGNvZGUgd291bGQgY3Jhc2ggd2hlbiBkZWJ1Z2dpbmcuXG4gKlxuICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMMlJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIEEgV2ViR0xQcm9ncmFtXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWN9IHVuaWZvcm1CbG9ja1NwZWMuIEEgVW5pZm9ybUJsb2NrU3BlYyBhcyByZXR1cm5lZFxuICogICAgIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja1NwZWNGcm9tUHJvZ3JhbX0uXG4gKiBAcGFyYW0ge3N0cmluZ30gYmxvY2tOYW1lIFRoZSBuYW1lIG9mIHRoZSBibG9jay5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja0luZm99IFRoZSBjcmVhdGVkIFVuaWZvcm1CbG9ja0luZm9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0oZ2wsIHByb2dyYW0sIHVuaWZvcm1CbG9ja1NwZWMsIGJsb2NrTmFtZSkge1xuICBjb25zdCBibG9ja1NwZWNzID0gdW5pZm9ybUJsb2NrU3BlYy5ibG9ja1NwZWNzO1xuICBjb25zdCB1bmlmb3JtRGF0YSA9IHVuaWZvcm1CbG9ja1NwZWMudW5pZm9ybURhdGE7XG4gIGNvbnN0IGJsb2NrU3BlYyA9IGJsb2NrU3BlY3NbYmxvY2tOYW1lXTtcbiAgaWYgKCFibG9ja1NwZWMpIHtcbiAgICB3YXJuKFwibm8gdW5pZm9ybSBibG9jayBvYmplY3QgbmFtZWQ6XCIsIGJsb2NrTmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGJsb2NrTmFtZSxcbiAgICAgIHVuaWZvcm1zOiB7fSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5QnVmZmVyKGJsb2NrU3BlYy5zaXplKTtcbiAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIGNvbnN0IHVuaWZvcm1CdWZmZXJJbmRleCA9IGJsb2NrU3BlYy5pbmRleDtcbiAgZ2wuYmluZEJ1ZmZlcihVTklGT1JNX0JVRkZFUiwgYnVmZmVyKTtcbiAgZ2wudW5pZm9ybUJsb2NrQmluZGluZyhwcm9ncmFtLCBibG9ja1NwZWMuaW5kZXgsIHVuaWZvcm1CdWZmZXJJbmRleCk7XG5cbiAgbGV0IHByZWZpeCA9IGJsb2NrTmFtZSArIFwiLlwiO1xuICBpZiAoYXJyYXlTdWZmaXhSRS50ZXN0KHByZWZpeCkpIHtcbiAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZShhcnJheVN1ZmZpeFJFLCBcIi5cIik7XG4gIH1cbiAgY29uc3QgdW5pZm9ybXMgPSB7fTtcbiAgY29uc3Qgc2V0dGVycyA9IHt9O1xuICBjb25zdCBzZXR0ZXJUcmVlID0ge307XG4gIGJsb2NrU3BlYy51bmlmb3JtSW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHVuaWZvcm1OZHgpIHtcbiAgICBjb25zdCBkYXRhID0gdW5pZm9ybURhdGFbdW5pZm9ybU5keF07XG4gICAgbGV0IG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIocHJlZml4Lmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGlzQXJyYXkgPSBuYW1lLmVuZHNXaXRoKCdbMF0nKTtcbiAgICBpZiAoaXNBcnJheSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gMyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVJbmZvID0gdHlwZU1hcFtkYXRhLnR5cGVdO1xuICAgIGNvbnN0IFR5cGUgPSB0eXBlSW5mby5UeXBlO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBpc0FycmF5XG4gICAgICAgID8gcGFkKHR5cGVJbmZvLnNpemUsIDE2KSAqIGRhdGEuc2l6ZVxuICAgICAgICA6IHR5cGVJbmZvLnNpemUgKiBkYXRhLnNpemU7XG4gICAgY29uc3QgdW5pZm9ybVZpZXcgPSBuZXcgVHlwZShhcnJheSwgZGF0YS5vZmZzZXQsIGJ5dGVMZW5ndGggLyBUeXBlLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICB1bmlmb3Jtc1tuYW1lXSA9IHVuaWZvcm1WaWV3O1xuICAgIC8vIE5vdGU6IEknbSBub3Qgc3VyZSB3aGF0IHRvIGRvIGhlcmUuIFRoZSBvcmlnaW5hbFxuICAgIC8vIGlkZWEgd2FzIHRvIGNyZWF0ZSBUeXBlZEFycmF5IHZpZXdzIGludG8gZWFjaCBwYXJ0XG4gICAgLy8gb2YgdGhlIGJsb2NrLiBUaGlzIGlzIHVzZWZ1bCwgZm9yIGV4YW1wbGUgaWYgeW91IGhhdmVcbiAgICAvLyBhIGJsb2NrIHdpdGggeyBtYXQ0OiBtb2RlbDsgbWF0NCB2aWV3OyBtYXQ0IHByb2plY3Rpb247IH1cbiAgICAvLyB5b3UnbGwgZ2V0IGEgRmxvYXQzMkFycmF5IGZvciBlYWNoIG9uZSBzdWl0YWJsZSBmb3JcbiAgICAvLyBwYXNzaW5nIHRvIG1vc3QgSlMgbWF0aCBsaWJyYXJpZXMgaW5jbHVkaW5nIHR3Z2wncyBhbmQgZ2xNYXRyaXguanMuXG4gICAgLy9cbiAgICAvLyBCdXQsIGlmIHlvdSBoYXZlIGEgYW4gYXJyYXkgb2Ygc3RydWN0dXJlcywgZXNwZWNpYWxseSBpZiB0aGF0XG4gICAgLy8gYXJyYXkgaXMgbGFyZ2UsIHlvdSBnZXQgYSB3aG9sZSBidW5jaCBvZiBUeXBlZEFycmF5IHZpZXdzLlxuICAgIC8vIEV2ZXJ5IG9uZSBvZiB0aGVtIGhhcyBvdmVyaGVhZCBhbmQgc3dpdGNoaW5nIGJldHdlZW4gdGhlbSBhbGxcbiAgICAvLyBpcyBwcm9iYWJseSBhIGNhY2hlIG1pc3MuIEluIHRoYXQgY2FzZSBpdCB3b3VsZCByZWFsbHkgYmUgYmV0dGVyXG4gICAgLy8gdG8ganVzdCBoYXZlIG9uZSB2aWV3IChhc0Zsb2F0KSBhbmQgaGF2ZSBhbGwgdGhlIHNldHRlcnNcbiAgICAvLyBqdXN0IHJlZmVyZW5jZSB0aGUgY29ycmVjdCBwb3J0aW9uLiBCdXQsIHRoZW4geW91IGNhbid0IGVhc2lseVxuICAgIC8vIHRyZWF0IGEgbWF0cml4LCBvciBhIHZlYzQsIGFzIGEgc3RhbmRhbG9uZSB0aGluZyBsaWtlIHlvdSBjYW5cbiAgICAvLyB3aXRoIGFsbCB0aGUgdmlld3MuXG4gICAgLy9cbiAgICAvLyBBbm90aGVyIHByb2JsZW0gd2l0aCB0aGUgdmlld3MgaXMgdGhleSBhcmUgbm90IHNoYXJlZC4gV2l0aFxuICAgIC8vIHVuaWZvcm1zIHlvdSBoYXZlIG9uZSBzZXQgb2Ygc2V0dGVycy4gV2l0aCBVbmlmb3JtQmxvY2tJbmZvXG4gICAgLy8geW91IGhhdmUgYSBzZXQgb2Ygc2V0dGVycyAqcHJlIGJsb2NrIGluc3RhbmNlKi4gVGhhdCdzIGJlY2F1c2VcbiAgICAvLyBUeXBlZEFycmF5IHZpZXdzIGNhbid0IGJlIG1hcHBlZCB0byBkaWZmZXJlbnQgYnVmZmVycy5cbiAgICAvL1xuICAgIC8vIE15IGd1dCByaWdodCBub3cgaXMgaWYgeW91IHJlYWxseSB3YW50IHRoZSBzcGVlZCBhbmQgY29tcGFjdG5lc3NcbiAgICAvLyB0aGVuIHlvdSBzaG91bGQgcHJvYmFibHkgcm9sbCB5b3VyIG93biBzb2x1dGlvbi4gVFdHTCdzIGdvYWxcbiAgICAvLyBoZXJlIGlzIGVhc2Ugb2YgdXNlIGFzIEFGQUlDVCB0aGVyZSBpcyBubyBzaW1wbGUgZ2VuZXJpYyBlZmZpY2llbnRcbiAgICAvLyBzb2x1dGlvbi5cbiAgICBjb25zdCBzZXR0ZXIgPSBjcmVhdGVVbmlmb3JtQmxvY2tVbmlmb3JtU2V0dGVyKHVuaWZvcm1WaWV3LCBpc0FycmF5LCB0eXBlSW5mby5yb3dzLCB0eXBlSW5mby5jb2xzKTtcbiAgICBzZXR0ZXJzW25hbWVdID0gc2V0dGVyO1xuICAgIGFkZFNldHRlclRvVW5pZm9ybVRyZWUobmFtZSwgc2V0dGVyLCBzZXR0ZXJUcmVlLCBzZXR0ZXJzKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogYmxvY2tOYW1lLFxuICAgIGFycmF5LFxuICAgIGFzRmxvYXQ6IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpLCAgLy8gZm9yIGRlYnVnZ2luZ1xuICAgIGJ1ZmZlcixcbiAgICB1bmlmb3JtcyxcbiAgICBzZXR0ZXJzLFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgVW5pZm9ybUJsb2NrSW5mb2AgZm9yIHRoZSBzcGVjaWZpZWQgYmxvY2tcbiAqXG4gKiBOb3RlOiAqKklmIHRoZSBibG9ja05hbWUgbWF0Y2hlcyBubyBleGlzdGluZyBibG9ja3MgYSB3YXJuaW5nIGlzIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUgYW5kIGEgZHVtbXlcbiAqIGBVbmlmb3JtQmxvY2tJbmZvYCBpcyByZXR1cm5lZCoqLiBUaGlzIGlzIGJlY2F1c2Ugd2hlbiBkZWJ1Z2dpbmcgR0xTTFxuICogaXQgaXMgY29tbW9uIHRvIGNvbW1lbnQgb3V0IGxhcmdlIHBvcnRpb25zIG9mIGEgc2hhZGVyIG9yIGZvciBleGFtcGxlIHNldFxuICogdGhlIGZpbmFsIG91dHB1dCB0byBhIGNvbnN0YW50LiBXaGVuIHRoYXQgaGFwcGVucyBibG9ja3MgZ2V0IG9wdGltaXplZCBvdXQuXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGRpZCBub3QgY3JlYXRlIGR1bW15IGJsb2NrcyB5b3VyIGNvZGUgd291bGQgY3Jhc2ggd2hlbiBkZWJ1Z2dpbmcuXG4gKlxuICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMMlJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm99IHByb2dyYW1JbmZvIGEgYFByb2dyYW1JbmZvYFxuICogICAgIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfVxuICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrTmFtZSBUaGUgbmFtZSBvZiB0aGUgYmxvY2suXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tJbmZvfSBUaGUgY3JlYXRlZCBVbmlmb3JtQmxvY2tJbmZvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybUJsb2NrSW5mbyhnbCwgcHJvZ3JhbUluZm8sIGJsb2NrTmFtZSkge1xuICByZXR1cm4gY3JlYXRlVW5pZm9ybUJsb2NrSW5mb0Zyb21Qcm9ncmFtKGdsLCBwcm9ncmFtSW5mby5wcm9ncmFtLCBwcm9ncmFtSW5mby51bmlmb3JtQmxvY2tTcGVjLCBibG9ja05hbWUpO1xufVxuXG4vKipcbiAqIEJpbmRzIGEgdW5pZm9ybSBibG9jayB0byB0aGUgbWF0Y2hpbmcgdW5pZm9ybSBibG9jayBwb2ludC5cbiAqIE1hdGNoZXMgYnkgYmxvY2tzIGJ5IG5hbWUgc28gYmxvY2tzIG11c3QgaGF2ZSB0aGUgc2FtZSBuYW1lIG5vdCBqdXN0IHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUuXG4gKlxuICogSWYgeW91IGhhdmUgY2hhbmdlZCBhbnkgdmFsdWVzIGFuZCB5b3UgdXBsb2FkIHRoZSB2YWx1ZXMgaW50byB0aGUgY29ycmVzcG9uZGluZyBXZWJHTEJ1ZmZlclxuICogY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0VW5pZm9ybUJsb2NrfSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTCAyIHJlbmRlcmluZyBjb250ZXh0LlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm98bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlYyl9IHByb2dyYW1JbmZvIGEgYFByb2dyYW1JbmZvYFxuICogICAgIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfSBvciBvciBgVW5pZm9ybUJsb2NrU3BlY2AgYXNcbiAqICAgICByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW19LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tJbmZvfSB1bmlmb3JtQmxvY2tJbmZvIGEgYFVuaWZvcm1CbG9ja0luZm9gIGFzIHJldHVybmVkIGZyb21cbiAqICAgICB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrSW5mb30uXG4gKiBAcmV0dXJuIHtib29sfSB0cnVlIGlmIGJ1ZmZlciB3YXMgYm91bmQuIElmIHRoZSBwcm9ncmFtSW5mbyBoYXMgbm8gYmxvY2sgd2l0aCB0aGUgc2FtZSBibG9jayBuYW1lXG4gKiAgICAgbm8gYnVmZmVyIGlzIGJvdW5kLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGJpbmRVbmlmb3JtQmxvY2soZ2wsIHByb2dyYW1JbmZvLCB1bmlmb3JtQmxvY2tJbmZvKSB7XG4gIGNvbnN0IHVuaWZvcm1CbG9ja1NwZWMgPSBwcm9ncmFtSW5mby51bmlmb3JtQmxvY2tTcGVjIHx8IHByb2dyYW1JbmZvO1xuICBjb25zdCBibG9ja1NwZWMgPSB1bmlmb3JtQmxvY2tTcGVjLmJsb2NrU3BlY3NbdW5pZm9ybUJsb2NrSW5mby5uYW1lXTtcbiAgaWYgKGJsb2NrU3BlYykge1xuICAgIGNvbnN0IGJ1ZmZlckJpbmRJbmRleCA9IGJsb2NrU3BlYy5pbmRleDtcbiAgICBnbC5iaW5kQnVmZmVyUmFuZ2UoVU5JRk9STV9CVUZGRVIsIGJ1ZmZlckJpbmRJbmRleCwgdW5pZm9ybUJsb2NrSW5mby5idWZmZXIsIHVuaWZvcm1CbG9ja0luZm8ub2Zmc2V0IHx8IDAsIHVuaWZvcm1CbG9ja0luZm8uYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFVwbG9hZHMgdGhlIGN1cnJlbnQgdW5pZm9ybSB2YWx1ZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgV2ViR0xCdWZmZXJcbiAqIGFuZCBiaW5kcyB0aGF0IGJ1ZmZlciB0byB0aGUgcHJvZ3JhbSdzIGNvcnJlc3BvbmRpbmcgYmluZCBwb2ludCBmb3IgdGhlIHVuaWZvcm0gYmxvY2sgb2JqZWN0LlxuICpcbiAqIElmIHlvdSBoYXZlbid0IGNoYW5nZWQgYW55IHZhbHVlcyBhbmQgeW91IG9ubHkgbmVlZCB0byBiaW5kIHRoZSB1bmlmb3JtIGJsb2NrIG9iamVjdFxuICogY2FsbCB7QGxpbmsgbW9kdWxlOnR3Z2wuYmluZFVuaWZvcm1CbG9ja30gaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wgMiByZW5kZXJpbmcgY29udGV4dC5cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfG1vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWMpfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb30gb3Igb3IgYFVuaWZvcm1CbG9ja1NwZWNgIGFzXG4gKiAgICAgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtfS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gdW5pZm9ybUJsb2NrSW5mbyBhIGBVbmlmb3JtQmxvY2tJbmZvYCBhcyByZXR1cm5lZCBmcm9tXG4gKiAgICAge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm99LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIHNldFVuaWZvcm1CbG9jayhnbCwgcHJvZ3JhbUluZm8sIHVuaWZvcm1CbG9ja0luZm8pIHtcbiAgaWYgKGJpbmRVbmlmb3JtQmxvY2soZ2wsIHByb2dyYW1JbmZvLCB1bmlmb3JtQmxvY2tJbmZvKSkge1xuICAgIGdsLmJ1ZmZlckRhdGEoVU5JRk9STV9CVUZGRVIsIHVuaWZvcm1CbG9ja0luZm8uYXJyYXksIERZTkFNSUNfRFJBVyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHZhbHVlcyBvZiBhIHVuaWZvcm0gYmxvY2sgb2JqZWN0XG4gKlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tJbmZvfSB1bmlmb3JtQmxvY2tJbmZvIEEgVW5pZm9ybUJsb2NrSW5mbyBhcyByZXR1cm5lZCBieSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrSW5mb30uXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gdmFsdWVzIEEgdW5pZm9ybSBuYW1lIHRvIHZhbHVlIG1hcCB3aGVyZSB0aGUgdmFsdWUgaXMgY29ycmVjdCBmb3IgdGhlIGdpdmVuXG4gKiAgICB0eXBlIG9mIHVuaWZvcm0uIFNvIGZvciBleGFtcGxlIGdpdmVuIGEgYmxvY2sgbGlrZVxuICpcbiAqICAgICAgIHVuaWZvcm0gU29tZUJsb2NrIHtcbiAqICAgICAgICAgZmxvYXQgc29tZUZsb2F0O1xuICogICAgICAgICB2ZWMyIHNvbWVWZWMyO1xuICogICAgICAgICB2ZWMzIHNvbWVWZWMzQXJyYXlbMl07XG4gKiAgICAgICAgIGludCBzb21lSW50O1xuICogICAgICAgfVxuICpcbiAqICBZb3UgY2FuIHNldCB0aGUgdmFsdWVzIG9mIHRoZSB1bmlmb3JtIGJsb2NrIHdpdGhcbiAqXG4gKiAgICAgICB0d2dsLnNldEJsb2NrVW5pZm9ybXMoc29tZUJsb2NrSW5mbywge1xuICogICAgICAgICAgc29tZUZsb2F0OiAxMi4zLFxuICogICAgICAgICAgc29tZVZlYzI6IFsxLCAyXSxcbiAqICAgICAgICAgIHNvbWVWZWMzQXJyYXk6IFsxLCAyLCAzLCA0LCA1LCA2XSxcbiAqICAgICAgICAgIHNvbWVJbnQ6IDUsXG4gKiAgICAgICB9XG4gKlxuICogIEFycmF5cyBjYW4gYmUgSmF2YVNjcmlwdCBhcnJheXMgb3IgdHlwZWQgYXJyYXlzXG4gKlxuICogIFlvdSBjYW4gYWxzbyBmaWxsIG91dCBzdHJ1Y3R1cmUgYW5kIGFycmF5IHZhbHVlcyBlaXRoZXIgdmlhXG4gKiAgc2hvcnRjdXQuIEV4YW1wbGVcbiAqXG4gKiAgICAgLy8gLS0gaW4gc2hhZGVyIC0tXG4gKiAgICAgc3RydWN0IExpZ2h0IHtcbiAqICAgICAgIGZsb2F0IGludGVuc2l0eTtcbiAqICAgICAgIHZlYzQgY29sb3I7XG4gKiAgICAgICBmbG9hdCBuZWFyRmFyWzJdO1xuICogICAgIH07XG4gKiAgICAgdW5pZm9ybSBMaWdodHMge1xuICogICAgICAgTGlnaHQgbGlnaHRzWzJdO1xuICogICAgIH07XG4gKlxuICogICAgIC8vIGluIEphdmFTY3JpcHRcbiAqXG4gKiAgICAgdHdnbC5zZXRCbG9ja1VuaWZvcm1zKHNvbWVCbG9ja0luZm8sIHtcbiAqICAgICAgIGxpZ2h0czogW1xuICogICAgICAgICB7IGludGVuc2l0eTogNS4wLCBjb2xvcjogWzEsIDAsIDAsIDFdLCBuZWFyRmFyWzAuMSwgMTBdIH0sXG4gKiAgICAgICAgIHsgaW50ZW5zaXR5OiAyLjAsIGNvbG9yOiBbMCwgMCwgMSwgMV0sIG5lYXJGYXJbMC4yLCAxNV0gfSxcbiAqICAgICAgIF0sXG4gKiAgICAgfSk7XG4gKlxuICogICBvciB0aGUgbW9yZSB0cmFkaXRpb25hbCB3YXlcbiAqXG4gKiAgICAgdHdnbC5zZXRCbG9ja1VuaWZvcm1zKHNvbWVCbG9ja0luZm8sIHtcbiAqICAgICAgIFwibGlnaHRzWzBdLmludGVuc2l0eVwiOiA1LjAsXG4gKiAgICAgICBcImxpZ2h0c1swXS5jb2xvclwiOiBbMSwgMCwgMCwgMV0sXG4gKiAgICAgICBcImxpZ2h0c1swXS5uZWFyRmFyXCI6IFswLjEsIDEwXSxcbiAqICAgICAgIFwibGlnaHRzWzFdLmludGVuc2l0eVwiOiAyLjAsXG4gKiAgICAgICBcImxpZ2h0c1sxXS5jb2xvclwiOiBbMCwgMCwgMSwgMV0sXG4gKiAgICAgICBcImxpZ2h0c1sxXS5uZWFyRmFyXCI6IFswLjIsIDE1XSxcbiAqICAgICB9KTtcbiAqXG4gKiAgIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IHBhcnRpYWwgcGF0aHNcbiAqXG4gKiAgICAgdHdnbC5zZXRCbG9ja1VuaWZvcm1zKHNvbWVCbG9ja0luZm8sIHtcbiAqICAgICAgICdsaWdodHNbMV0nOiB7IGludGVuc2l0eTogNS4wLCBjb2xvcjogWzEsIDAsIDAsIDFdLCBuZWFyRmFyWzAuMiwgMTVdIH0sXG4gKiAgICAgfSk7XG4gKlxuICogICBCdXQgeW91IGNhbiBub3Qgc3BlY2lmeSBsZWFmIGFycmF5IGluZGljZXMuXG4gKlxuICogICAgIHR3Z2wuc2V0QmxvY2tVbmlmb3Jtcyhzb21lQmxvY2tJbmZvLCB7XG4gKiAgICAgICAnbGlnaHRzWzFdLm5lYXJGYXJbMV0nOiAxNSwgICAgIC8vIEJBRCEgbmVhckZhciBpcyBhIGxlYWZcbiAqICAgICAgICdsaWdodHNbMV0ubmVhckZhcic6IFswLjIsIDE1XSwgLy8gR09PRFxuICogICAgIH0pO1xuICpcbiAqICAqKklNUE9SVEFOVCEqKiwgcGFja2luZyBpbiBhIFVuaWZvcm1CbG9jayBpcyB1bmludHVpdGl2ZS5cbiAqICBGb3IgZXhhbXBsZSB0aGUgYWN0dWFsIGxheW91dCBvZiBgc29tZVZlYzNBcnJheWAgYWJvdmUgaW4gbWVtb3J5XG4gKiAgaXMgYDEsIDIsIDMsIHVudXNlZCwgNCwgNSwgNiwgdW51c2VkYC4gdHdnbCB0YWtlcyBpbiA2IHZhbHVlc1xuICogIGFzIHNob3duIGFib3V0IGFuZCBjb3BpZXMgdGhlbSwgc2tpcHBpbmcgdGhlIHBhZGRpbmcuIFRoaXMgbWlnaHRcbiAqICBiZSBjb25mdXNpbmcgaWYgeW91J3JlIGFscmVhZHkgZmFtaWxpYXIgd2l0aCBVbmlmb3JtIGJsb2Nrcy5cbiAqXG4gKiAgSWYgeW91IHdhbnQgdG8gZGVhbCB3aXRoIHRoZSBwYWRkaW5nIHlvdXJzZWxmIHlvdSBjYW4gYWNjZXNzIHRoZSBhcnJheVxuICogIGJ1ZmZlciB2aWV3cyBkaXJlY3RseS4gZWc6XG4gKlxuICogICAgICBzb21lQmxvY2tJbmZvLnNvbWVWZWMzQXJyYXkuc2V0KFsxLCAyLCAzLCAwLCA0LCA1LCA2LCAwXSk7XG4gKlxuICogIEFueSBuYW1lIHRoYXQgZG9lc24ndCBtYXRjaCB3aWxsIGJlIGlnbm9yZWRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBzZXRCbG9ja1VuaWZvcm1zKHVuaWZvcm1CbG9ja0luZm8sIHZhbHVlcykge1xuICBjb25zdCBzZXR0ZXJzID0gdW5pZm9ybUJsb2NrSW5mby5zZXR0ZXJzO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWVzKSB7XG4gICAgY29uc3Qgc2V0dGVyID0gc2V0dGVyc1tuYW1lXTtcbiAgICBpZiAoc2V0dGVyKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tuYW1lXTtcbiAgICAgIHNldHRlcih2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFVuaWZvcm1UcmVlKHRyZWUsIHZhbHVlcykge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWVzKSB7XG4gICAgY29uc3QgcHJvcCA9IHRyZWVbbmFtZV07XG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wKHZhbHVlc1tuYW1lXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFVuaWZvcm1UcmVlKHRyZWVbbmFtZV0sIHZhbHVlc1tuYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2V0IHVuaWZvcm1zIGFuZCBiaW5kcyByZWxhdGVkIHRleHR1cmVzLlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1JbmZvID0gY3JlYXRlUHJvZ3JhbUluZm8oXG4gKiAgICAgICAgIGdsLCBbXCJzb21lLXZzXCIsIFwic29tZS1mc1wiXSk7XG4gKlxuICogICAgIGNvbnN0IHRleDEgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gKiAgICAgY29uc3QgdGV4MiA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAqXG4gKiAgICAgLi4uIGFzc3VtZSB3ZSBzZXR1cCB0aGUgdGV4dHVyZXMgd2l0aCBkYXRhIC4uLlxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHRleDEsXG4gKiAgICAgICB1X3NvbWVPdGhlclNhbXBsZXI6IHRleDIsXG4gKiAgICAgICB1X3NvbWVDb2xvcjogWzEsMCwwLDFdLFxuICogICAgICAgdV9zb21lUG9zaXRpb246IFswLDEsMV0sXG4gKiAgICAgICB1X3NvbWVNYXRyaXg6IFtcbiAqICAgICAgICAgMSwwLDAsMCxcbiAqICAgICAgICAgMCwxLDAsMCxcbiAqICAgICAgICAgMCwwLDEsMCxcbiAqICAgICAgICAgMCwwLDAsMCxcbiAqICAgICAgIF0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtSW5mby5wcm9ncmFtKTtcbiAqXG4gKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBiaW5kIHRoZSB0ZXh0dXJlcyBBTkQgc2V0IHRoZVxuICogdW5pZm9ybXMuXG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHVuaWZvcm1zKTtcbiAqXG4gKiBGb3IgdGhlIGV4YW1wbGUgYWJvdmUgaXQgaXMgZXF1aXZhbGVudCB0b1xuICpcbiAqICAgICBsZXQgdGV4VW5pdCA9IDA7XG4gKiAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleFVuaXQpO1xuICogICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleDEpO1xuICogICAgIGdsLnVuaWZvcm0xaSh1X3NvbWVTYW1wbGVyTG9jYXRpb24sIHRleFVuaXQrKyk7XG4gKiAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleFVuaXQpO1xuICogICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleDIpO1xuICogICAgIGdsLnVuaWZvcm0xaSh1X3NvbWVTYW1wbGVyTG9jYXRpb24sIHRleFVuaXQrKyk7XG4gKiAgICAgZ2wudW5pZm9ybTRmdih1X3NvbWVDb2xvckxvY2F0aW9uLCBbMSwgMCwgMCwgMV0pO1xuICogICAgIGdsLnVuaWZvcm0zZnYodV9zb21lUG9zaXRpb25Mb2NhdGlvbiwgWzAsIDEsIDFdKTtcbiAqICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVfc29tZU1hdHJpeCwgZmFsc2UsIFtcbiAqICAgICAgICAgMSwwLDAsMCxcbiAqICAgICAgICAgMCwxLDAsMCxcbiAqICAgICAgICAgMCwwLDEsMCxcbiAqICAgICAgICAgMCwwLDAsMCxcbiAqICAgICAgIF0pO1xuICpcbiAqIE5vdGUgaXQgaXMgcGVyZmVjdGx5IHJlYXNvbmFibGUgdG8gY2FsbCBgc2V0VW5pZm9ybXNgIG11bHRpcGxlIHRpbWVzLiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHRleDEsXG4gKiAgICAgICB1X3NvbWVPdGhlclNhbXBsZXI6IHRleDIsXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgY29uc3QgbW9yZVVuaWZvcm1zIHtcbiAqICAgICAgIHVfc29tZUNvbG9yOiBbMSwwLDAsMV0sXG4gKiAgICAgICB1X3NvbWVQb3NpdGlvbjogWzAsMSwxXSxcbiAqICAgICAgIHVfc29tZU1hdHJpeDogW1xuICogICAgICAgICAxLDAsMCwwLFxuICogICAgICAgICAwLDEsMCwwLFxuICogICAgICAgICAwLDAsMSwwLFxuICogICAgICAgICAwLDAsMCwwLFxuICogICAgICAgXSxcbiAqICAgICB9O1xuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCB1bmlmb3Jtcyk7XG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgbW9yZVVuaWZvcm1zKTtcbiAqXG4gKiBZb3UgY2FuIGFsc28gYWRkIFdlYkdMU2FtcGxlcnMgdG8gdW5pZm9ybSBzYW1wbGVycyBhcyBpblxuICpcbiAqICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAqICAgICAgIHVfc29tZVNhbXBsZXI6IHtcbiAqICAgICAgICAgdGV4dHVyZTogc29tZVdlYkdMVGV4dHVyZSxcbiAqICAgICAgICAgc2FtcGxlcjogc29tZVdlYkdMU2FtcGxlcixcbiAqICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiBJbiB3aGljaCBjYXNlIGJvdGggdGhlIHNhbXBsZXIgYW5kIHRleHR1cmUgd2lsbCBiZSBib3VuZCB0byB0aGVcbiAqIHNhbWUgdW5pdC5cbiAqXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KX0gc2V0dGVycyBhIGBQcm9ncmFtSW5mb2AgYXMgcmV0dXJuZWQgZnJvbSBgY3JlYXRlUHJvZ3JhbUluZm9gIG9yIHRoZSBzZXR0ZXJzIHJldHVybmVkIGZyb21cbiAqICAgICAgICBgY3JlYXRlVW5pZm9ybVNldHRlcnNgLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IHZhbHVlcyBhbiBvYmplY3Qgd2l0aCB2YWx1ZXMgZm9yIHRoZVxuICogICAgICAgIHVuaWZvcm1zLlxuICogICBZb3UgY2FuIHBhc3MgbXVsdGlwbGUgb2JqZWN0cyBieSBwdXR0aW5nIHRoZW0gaW4gYW4gYXJyYXkgb3IgYnkgY2FsbGluZyB3aXRoIG1vcmUgYXJndW1lbnRzLkZvciBleGFtcGxlXG4gKlxuICogICAgIGNvbnN0IHNoYXJlZFVuaWZvcm1zID0ge1xuICogICAgICAgdV9mb2dOZWFyOiAxMCxcbiAqICAgICAgIHVfcHJvamVjdGlvbjogLi4uXG4gKiAgICAgICAuLi5cbiAqICAgICB9O1xuICpcbiAqICAgICBjb25zdCBsb2NhbFVuaWZvcm1zID0ge1xuICogICAgICAgdV93b3JsZDogLi4uXG4gKiAgICAgICB1X2RpZmZ1c2VDb2xvcjogLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXMpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCBbc2hhcmVkVW5pZm9ybXMsIGxvY2FsVW5pZm9ybXNdKTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgc2hhcmVkVW5pZm9ybXMpO1xuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIGxvY2FsVW5pZm9ybXN9O1xuICpcbiAqICAgWW91IGNhbiBhbHNvIGZpbGwgb3V0IHN0cnVjdHVyZSBhbmQgYXJyYXkgdmFsdWVzIGVpdGhlciB2aWFcbiAqICAgc2hvcnRjdXQuIEV4YW1wbGVcbiAqXG4gKiAgICAgLy8gLS0gaW4gc2hhZGVyIC0tXG4gKiAgICAgc3RydWN0IExpZ2h0IHtcbiAqICAgICAgIGZsb2F0IGludGVuc2l0eTtcbiAqICAgICAgIHZlYzQgY29sb3I7XG4gKiAgICAgICBmbG9hdCBuZWFyRmFyWzJdO1xuICogICAgIH07XG4gKiAgICAgdW5pZm9ybSBMaWdodCBsaWdodHNbMl07XG4gKlxuICogICAgIC8vIGluIEphdmFTY3JpcHRcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywge1xuICogICAgICAgbGlnaHRzOiBbXG4gKiAgICAgICAgIHsgaW50ZW5zaXR5OiA1LjAsIGNvbG9yOiBbMSwgMCwgMCwgMV0sIG5lYXJGYXJbMC4xLCAxMF0gfSxcbiAqICAgICAgICAgeyBpbnRlbnNpdHk6IDIuMCwgY29sb3I6IFswLCAwLCAxLCAxXSwgbmVhckZhclswLjIsIDE1XSB9LFxuICogICAgICAgXSxcbiAqICAgICB9KTtcbiAqXG4gKiAgIG9yIHRoZSBtb3JlIHRyYWRpdGlvbmFsIHdheVxuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCB7XG4gKiAgICAgICBcImxpZ2h0c1swXS5pbnRlbnNpdHlcIjogNS4wLFxuICogICAgICAgXCJsaWdodHNbMF0uY29sb3JcIjogWzEsIDAsIDAsIDFdLFxuICogICAgICAgXCJsaWdodHNbMF0ubmVhckZhclwiOiBbMC4xLCAxMF0sXG4gKiAgICAgICBcImxpZ2h0c1sxXS5pbnRlbnNpdHlcIjogMi4wLFxuICogICAgICAgXCJsaWdodHNbMV0uY29sb3JcIjogWzAsIDAsIDEsIDFdLFxuICogICAgICAgXCJsaWdodHNbMV0ubmVhckZhclwiOiBbMC4yLCAxNV0sXG4gKiAgICAgfSk7XG4gKlxuICogICBZb3UgY2FuIGFsc28gc3BlY2lmeSBwYXJ0aWFsIHBhdGhzXG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHtcbiAqICAgICAgICdsaWdodHNbMV0nOiB7IGludGVuc2l0eTogNS4wLCBjb2xvcjogWzEsIDAsIDAsIDFdLCBuZWFyRmFyWzAuMiwgMTVdIH0sXG4gKiAgICAgfSk7XG4gKlxuICogICBCdXQgeW91IGNhbiBub3Qgc3BlY2lmeSBsZWFmIGFycmF5IGluZGljZXNcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywge1xuICogICAgICAgJ2xpZ2h0c1sxXS5uZWFyRmFyWzFdJzogMTUsICAgICAvLyBCQUQhIG5lYXJGYXIgaXMgYSBsZWFmXG4gKiAgICAgICAnbGlnaHRzWzFdLm5lYXJGYXInOiBbMC4yLCAxNV0sIC8vIEdPT0RcbiAqICAgICB9KTtcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuZnVuY3Rpb24gc2V0VW5pZm9ybXMoc2V0dGVycywgLi4uYXJncykgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBjb25zdCBhY3R1YWxTZXR0ZXJzID0gc2V0dGVycy51bmlmb3JtU2V0dGVycyB8fCBzZXR0ZXJzO1xuICBjb25zdCBudW1BcmdzID0gYXJncy5sZW5ndGg7XG4gIGZvciAobGV0IGFOZHggPSAwOyBhTmR4IDwgbnVtQXJnczsgKythTmR4KSB7XG4gICAgY29uc3QgdmFsdWVzID0gYXJnc1thTmR4XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBjb25zdCBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG51bVZhbHVlczsgKytpaSkge1xuICAgICAgICBzZXRVbmlmb3JtcyhhY3R1YWxTZXR0ZXJzLCB2YWx1ZXNbaWldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlcykge1xuICAgICAgICBjb25zdCBzZXR0ZXIgPSBhY3R1YWxTZXR0ZXJzW25hbWVdO1xuICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgc2V0dGVyKHZhbHVlc1tuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbGlhcyBmb3IgYHNldFVuaWZvcm1zYFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KX0gc2V0dGVycyBhIGBQcm9ncmFtSW5mb2AgYXMgcmV0dXJuZWQgZnJvbSBgY3JlYXRlUHJvZ3JhbUluZm9gIG9yIHRoZSBzZXR0ZXJzIHJldHVybmVkIGZyb21cbiAqICAgICAgICBgY3JlYXRlVW5pZm9ybVNldHRlcnNgLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IHZhbHVlcyBhbiBvYmplY3Qgd2l0aCB2YWx1ZXMgZm9yIHRoZVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmNvbnN0IHNldFVuaWZvcm1zQW5kQmluZFRleHR1cmVzID0gc2V0VW5pZm9ybXM7XG5cbi8qKlxuICogQ3JlYXRlcyBzZXR0ZXIgZnVuY3Rpb25zIGZvciBhbGwgYXR0cmlidXRlcyBvZiBhIHNoYWRlclxuICogcHJvZ3JhbS4gWW91IGNhbiBwYXNzIHRoaXMgdG8ge0BsaW5rIG1vZHVsZTp0d2dsLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzfSB0byBzZXQgYWxsIHlvdXIgYnVmZmVycyBhbmQgYXR0cmlidXRlcy5cbiAqXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6dHdnbC5zZXRBdHRyaWJ1dGVzfSBmb3IgZXhhbXBsZVxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW0gdGhlIHByb2dyYW0gdG8gY3JlYXRlIHNldHRlcnMgZm9yLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gYW4gb2JqZWN0IHdpdGggYSBzZXR0ZXIgZm9yIGVhY2ggYXR0cmlidXRlIGJ5IG5hbWUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhnbCwgcHJvZ3JhbSkge1xuICBjb25zdCBhdHRyaWJTZXR0ZXJzID0ge1xuICB9O1xuXG4gIGNvbnN0IG51bUF0dHJpYnMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIEFDVElWRV9BVFRSSUJVVEVTKTtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG51bUF0dHJpYnM7ICsraWkpIHtcbiAgICBjb25zdCBhdHRyaWJJbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGlpKTtcbiAgICBpZiAoaXNCdWlsdEluKGF0dHJpYkluZm8pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJJbmZvLm5hbWUpO1xuICAgIGNvbnN0IHR5cGVJbmZvID0gYXR0clR5cGVNYXBbYXR0cmliSW5mby50eXBlXTtcbiAgICBjb25zdCBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIGluZGV4LCB0eXBlSW5mbyk7XG4gICAgc2V0dGVyLmxvY2F0aW9uID0gaW5kZXg7XG4gICAgYXR0cmliU2V0dGVyc1thdHRyaWJJbmZvLm5hbWVdID0gc2V0dGVyO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYlNldHRlcnM7XG59XG5cbi8qKlxuICogU2V0cyBhdHRyaWJ1dGVzIGFuZCBiaW5kcyBidWZmZXJzIChkZXByZWNhdGVkLi4uIHVzZSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9KVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtRnJvbVNjcmlwdHMoXG4gKiAgICAgICAgIGdsLCBbXCJzb21lLXZzXCIsIFwic29tZS1mc1wiKTtcbiAqXG4gKiAgICAgY29uc3QgYXR0cmliU2V0dGVycyA9IGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnMocHJvZ3JhbSk7XG4gKlxuICogICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gKiAgICAgY29uc3QgdGV4Y29vcmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAqXG4gKiAgICAgY29uc3QgYXR0cmlicyA9IHtcbiAqICAgICAgIGFfcG9zaXRpb246IHtidWZmZXI6IHBvc2l0aW9uQnVmZmVyLCBudW1Db21wb25lbnRzOiAzfSxcbiAqICAgICAgIGFfdGV4Y29vcmQ6IHtidWZmZXI6IHRleGNvb3JkQnVmZmVyLCBudW1Db21wb25lbnRzOiAyfSxcbiAqICAgICB9O1xuICpcbiAqICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICpcbiAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJpbmQgdGhlIGJ1ZmZlcnMgQU5EIHNldCB0aGVcbiAqIGF0dHJpYnV0ZXMuXG4gKlxuICogICAgIHNldEF0dHJpYnV0ZXMoYXR0cmliU2V0dGVycywgYXR0cmlicyk7XG4gKlxuICogUHJvcGVydGllcyBvZiBhdHRyaWJzLiBGb3IgZWFjaCBhdHRyaWIgeW91IGNhbiBhZGRcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogKiAgIHR5cGU6IHRoZSB0eXBlIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdCA9IGdsLkZMT0FUXG4gKiAqICAgbm9ybWFsaXplOiB3aGV0aGVyIG9yIG5vdCB0byBub3JtYWxpemUgdGhlIGRhdGEuIERlZmF1bHQgPSBmYWxzZVxuICogKiAgIHN0cmlkZTogdGhlIHN0cmlkZS4gRGVmYXVsdCA9IDBcbiAqICogICBvZmZzZXQ6IG9mZnNldCBpbnRvIHRoZSBidWZmZXIuIERlZmF1bHQgPSAwXG4gKiAqICAgZGl2aXNvcjogdGhlIGRpdmlzb3IgZm9yIGluc3RhbmNlcy4gRGVmYXVsdCA9IHVuZGVmaW5lZFxuICpcbiAqIEZvciBleGFtcGxlIGlmIHlvdSBoYWQgMyB2YWx1ZSBmbG9hdCBwb3NpdGlvbnMsIDIgdmFsdWVcbiAqIGZsb2F0IHRleGNvb3JkIGFuZCA0IHZhbHVlIHVpbnQ4IGNvbG9ycyB5b3UnZCBzZXR1cCB5b3VyXG4gKiBhdHRyaWJzIGxpa2UgdGhpc1xuICpcbiAqICAgICBjb25zdCBhdHRyaWJzID0ge1xuICogICAgICAgYV9wb3NpdGlvbjoge2J1ZmZlcjogcG9zaXRpb25CdWZmZXIsIG51bUNvbXBvbmVudHM6IDN9LFxuICogICAgICAgYV90ZXhjb29yZDoge2J1ZmZlcjogdGV4Y29vcmRCdWZmZXIsIG51bUNvbXBvbmVudHM6IDJ9LFxuICogICAgICAgYV9jb2xvcjoge1xuICogICAgICAgICBidWZmZXI6IGNvbG9yQnVmZmVyLFxuICogICAgICAgICBudW1Db21wb25lbnRzOiA0LFxuICogICAgICAgICB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLFxuICogICAgICAgICBub3JtYWxpemU6IHRydWUsXG4gKiAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBzZXR0ZXJzIEF0dHJpYnV0ZSBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmlidXRlU2V0dGVyc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz59IGJ1ZmZlcnMgQXR0cmliSW5mb3MgbWFwcGVkIGJ5IGF0dHJpYnV0ZSBuYW1lLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIG1vZHVsZTp0d2dsLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhzZXR0ZXJzLCBidWZmZXJzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBidWZmZXJzKSB7XG4gICAgY29uc3Qgc2V0dGVyID0gc2V0dGVyc1tuYW1lXTtcbiAgICBpZiAoc2V0dGVyKSB7XG4gICAgICBzZXR0ZXIoYnVmZmVyc1tuYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2V0cyBhdHRyaWJ1dGVzIGFuZCBidWZmZXJzIGluY2x1ZGluZyB0aGUgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYCBpZiBhcHByb3ByaWF0ZVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1JbmZvID0gY3JlYXRlUHJvZ3JhbUluZm8oXG4gKiAgICAgICAgIGdsLCBbXCJzb21lLXZzXCIsIFwic29tZS1mc1wiKTtcbiAqXG4gKiAgICAgY29uc3QgYXJyYXlzID0ge1xuICogICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSwgfSxcbiAqICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSwgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgY29uc3QgYnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBhcnJheXMpO1xuICpcbiAqICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW1JbmZvLnByb2dyYW0pO1xuICpcbiAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJpbmQgdGhlIGJ1ZmZlcnMgQU5EIHNldCB0aGVcbiAqIGF0dHJpYnV0ZXMuXG4gKlxuICogICAgIHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gKlxuICogRm9yIHRoZSBleGFtcGxlIGFib3ZlIGl0IGlzIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAqICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX3Bvc2l0aW9uTG9jYXRpb24pO1xuICogICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9wb3NpdGlvbkxvY2F0aW9uLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhjb29yZEJ1ZmZlcik7XG4gKiAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV90ZXhjb29yZExvY2F0aW9uKTtcbiAqICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfdGV4Y29vcmRMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+KX0gc2V0dGVycyBBIGBQcm9ncmFtSW5mb2AgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99IG9yIEF0dHJpYnV0ZSBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUF0dHJpYnV0ZVNldHRlcnN9XG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfG1vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mbyl9IGJ1ZmZlcnMgYSBgQnVmZmVySW5mb2AgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9LlxuICogICBvciBhIGBWZXJ0ZXhBcnJheUluZm9gIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVZlcnRleEFycmF5SW5mb31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlcnMpIHtcbiAgaWYgKGJ1ZmZlcnMudmVydGV4QXJyYXlPYmplY3QpIHtcbiAgICBnbC5iaW5kVmVydGV4QXJyYXkoYnVmZmVycy52ZXJ0ZXhBcnJheU9iamVjdCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0QXR0cmlidXRlcyhwcm9ncmFtSW5mby5hdHRyaWJTZXR0ZXJzIHx8IHByb2dyYW1JbmZvLCBidWZmZXJzLmF0dHJpYnMpO1xuICAgIGlmIChidWZmZXJzLmluZGljZXMpIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoRUxFTUVOVF9BUlJBWV9CVUZGRVIkMSwgYnVmZmVycy5pbmRpY2VzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9ncmFtSW5mb1xuICogQHByb3BlcnR5IHtXZWJHTFByb2dyYW19IHByb2dyYW0gQSBzaGFkZXIgcHJvZ3JhbVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbj59IHVuaWZvcm1TZXR0ZXJzIG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlVW5pZm9ybVNldHRlcnMsXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIGZ1bmN0aW9uPn0gYXR0cmliU2V0dGVycyBvYmplY3Qgb2Ygc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYlNldHRlcnMsXG4gKiBAcHJvcGVydHkge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWN9IFt1bmlmb3JtQmxvY2tTcGVjXSBhIHVuaWZvcm0gYmxvY2sgc3BlYyBmb3IgbWFraW5nIFVuaWZvcm1CbG9ja0luZm9zIHdpdGggY3JlYXRlVW5pZm9ybUJsb2NrSW5mbyBldGMuLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+fSBbdHJhbnNmb3JtRmVlZGJhY2tJbmZvXSBpbmZvIGZvciB0cmFuc2Zvcm0gZmVlZGJhY2tzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm9ncmFtSW5mbyBmcm9tIGFuIGV4aXN0aW5nIHByb2dyYW0uXG4gKlxuICogQSBQcm9ncmFtSW5mbyBjb250YWluc1xuICpcbiAqICAgICBwcm9ncmFtSW5mbyA9IHtcbiAqICAgICAgICBwcm9ncmFtOiBXZWJHTFByb2dyYW0sXG4gKiAgICAgICAgdW5pZm9ybVNldHRlcnM6IG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlVW5pZm9ybVNldHRlcnMsXG4gKiAgICAgICAgYXR0cmliU2V0dGVyczogb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVBdHRyaWJTZXR0ZXJzLFxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIGFuIGV4aXN0aW5nIFdlYkdMUHJvZ3JhbS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBUaGUgY3JlYXRlZCBQcm9ncmFtSW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gIGNvbnN0IHVuaWZvcm1TZXR0ZXJzID0gY3JlYXRlVW5pZm9ybVNldHRlcnMoZ2wsIHByb2dyYW0pO1xuICBjb25zdCBhdHRyaWJTZXR0ZXJzID0gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhnbCwgcHJvZ3JhbSk7XG4gIGNvbnN0IHByb2dyYW1JbmZvID0ge1xuICAgIHByb2dyYW0sXG4gICAgdW5pZm9ybVNldHRlcnMsXG4gICAgYXR0cmliU2V0dGVycyxcbiAgfTtcblxuICBpZiAoaXNXZWJHTDIoZ2wpKSB7XG4gICAgcHJvZ3JhbUluZm8udW5pZm9ybUJsb2NrU3BlYyA9IGNyZWF0ZVVuaWZvcm1CbG9ja1NwZWNGcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgcHJvZ3JhbUluZm8udHJhbnNmb3JtRmVlZGJhY2tJbmZvID0gY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2tJbmZvKGdsLCBwcm9ncmFtKTtcbiAgfVxuXG4gIHJldHVybiBwcm9ncmFtSW5mbztcbn1cblxuY29uc3Qgbm90SWRSRSA9IC9cXHN8e3x9fDsvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm9ncmFtSW5mbyBmcm9tIDIgc291cmNlcy5cbiAqXG4gKiBBIFByb2dyYW1JbmZvIGNvbnRhaW5zXG4gKlxuICogICAgIHByb2dyYW1JbmZvID0ge1xuICogICAgICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAqICAgICAgICB1bmlmb3JtU2V0dGVyczogb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVVbmlmb3JtU2V0dGVycyxcbiAqICAgICAgICBhdHRyaWJTZXR0ZXJzOiBvYmplY3Qgb2Ygc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYlNldHRlcnMsXG4gKiAgICAgfVxuICpcbiAqIE5PVEU6IFRoZXJlIGFyZSA0IHNpZ25hdHVyZXMgZm9yIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUluZm8oZ2wsIFt2cywgZnNdLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzaGFkZXJTb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMgZm9yIHRoZVxuICogICAgICAgIHNoYWRlcnMgb3IgaWRzLiBUaGUgZmlyc3QgaXMgYXNzdW1lZCB0byBiZSB0aGUgdmVydGV4IHNoYWRlcixcbiAqICAgICAgICB0aGUgc2Vjb25kIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfYXR0cmlic10gT3B0aW9ucyBmb3IgdGhlIHByb2dyYW0gb3IgYW4gYXJyYXkgb2YgYXR0cmlicyBuYW1lcyBvciBhbiBlcnJvciBjYWxsYmFjay4gTG9jYXRpb25zIHdpbGwgYmUgYXNzaWduZWQgYnkgaW5kZXggaWYgbm90IHBhc3NlZCBpblxuICogQHBhcmFtIHtudW1iZXJbXXxtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrfSBbb3B0X2xvY2F0aW9uc10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMgb3IgYW4gZXJyb3IgY2FsbGJhY2suXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm8/fSBUaGUgY3JlYXRlZCBQcm9ncmFtSW5mbyBvciBudWxsIGlmIGl0IGZhaWxlZCB0byBsaW5rIG9yIGNvbXBpbGVcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtSW5mbyhcbiAgICBnbCwgc2hhZGVyU291cmNlcywgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIGNvbnN0IHByb2dPcHRpb25zID0gZ2V0UHJvZ3JhbU9wdGlvbnMob3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKTtcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIHNoYWRlclNvdXJjZXMgPSBzaGFkZXJTb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAvLyBMZXRzIGFzc3VtZSBpZiB0aGVyZSBpcyBubyBcXG4gaXQncyBhbiBpZFxuICAgIGlmICghbm90SWRSRS50ZXN0KHNvdXJjZSkpIHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGdldEVsZW1lbnRCeUlkKHNvdXJjZSk7XG4gICAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICBjb25zdCBlcnIgPSBgbm8gZWxlbWVudCB3aXRoIGlkOiAke3NvdXJjZX1gO1xuICAgICAgICBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2UgPSBzY3JpcHQudGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSk7XG5cbiAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVwb3J0RXJyb3IocHJvZ09wdGlvbnMsICcnKTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdDYWxsYmFjayA9IHByb2dPcHRpb25zLmNhbGxiYWNrO1xuICBpZiAob3JpZ0NhbGxiYWNrKSB7XG4gICAgcHJvZ09wdGlvbnMuY2FsbGJhY2sgPSAoZXJyLCBwcm9ncmFtKSA9PiB7XG4gICAgICBvcmlnQ2FsbGJhY2soZXJyLCBlcnIgPyB1bmRlZmluZWQgOiBjcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtKGdsLCBwcm9ncmFtKSk7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtRnJvbVNvdXJjZXMoZ2wsIHNoYWRlclNvdXJjZXMsIHByb2dPcHRpb25zKTtcbiAgaWYgKCFwcm9ncmFtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQWxsUHJvZ3JhbXMoZ2wsIHByb2dyYW1zLCBwcm9ncmFtU3BlY3MsIG5vRGVsZXRlU2hhZGVyc1NldCwgcHJvZ3JhbU9wdGlvbnMpIHtcbiAgLy8gY2hlY2sgZXJyb3JzIGZvciBldmVyeXRoaW5nLlxuICBmb3IgKGNvbnN0IFtuYW1lLCBwcm9ncmFtXSBvZiBPYmplY3QuZW50cmllcyhwcm9ncmFtcykpIHtcbiAgICBjb25zdCBvcHRpb25zID0gey4uLnByb2dyYW1PcHRpb25zfTtcbiAgICBjb25zdCBzcGVjID0gcHJvZ3JhbVNwZWNzW25hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBzcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JzID0gZ2V0UHJvZ3JhbUVycm9ycyhnbCwgcHJvZ3JhbSwgb3B0aW9ucy5lcnJvckNhbGxiYWNrKTtcbiAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAvLyBkZWxldGUgZXZlcnl0aGluZyB3ZSBjcmVhdGVkXG4gICAgICBmb3IgKGNvbnN0IHByb2dyYW0gb2YgT2JqZWN0LnZhbHVlcyhwcm9ncmFtcykpIHtcbiAgICAgICAgY29uc3Qgc2hhZGVycyA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZm9yIChjb25zdCBzaGFkZXIgb2Ygc2hhZGVycykge1xuICAgICAgICAgIC8vIERvbid0IGRlbGV0ZSBpdCBpZiB3ZSBkaWRuJ3QgY3JlYXRlIGl0LlxuICAgICAgICAgIGlmICghbm9EZWxldGVTaGFkZXJzU2V0LmhhcyhzaGFkZXIpKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIG11bHRpcGxlIHByb2dyYW1zXG4gKlxuICogTm90ZTogdGhlIHJlYXNvbiB0aGlzIGZ1bmN0aW9uIGV4aXN0cyBpcyBiZWNhdXNlIHRoZSBmYXN0ZXN0IHdheSB0byBjcmVhdGUgbXVsdGlwbGVcbiAqIHByb2dyYW1zIGluIFdlYkdMIGlzIHRvIGNyZWF0ZSBhbmQgY29tcGlsZSBhbGwgc2hhZGVycyBhbmQgbGluayBhbGwgcHJvZ3JhbXMgYW5kIG9ubHlcbiAqIGFmdGVyd2FyZHMgY2hlY2sgaWYgdGhleSBzdWNjZWVkZWQuIEluIHRoYXQgd2F5LCBnaXZpbmcgYWxsIHlvdXIgc2hhZGVyc1xuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW19XG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcHJvZ3JhbXMgPSB0d2dsLmNyZWF0ZVByb2dyYW1zKGdsLCB7XG4gKiAgICAgICBsYW1iZXJ0OiBbbGFtYmVydFZTLCBsYW1iZXJ0RlNdLFxuICogICAgICAgcGhvbmc6IFtwaG9uZ1ZTLCBwaG9uZUZTXSxcbiAqICAgICAgIHBhcnRpY2xlczoge1xuICogICAgICAgICBzaGFkZXJzOiBbcGFydGljbGVzVlMsIHBhcnRpY2xlc0ZTXSxcbiAqICAgICAgICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nczogWydwb3NpdGlvbicsICd2ZWxvY2l0eSddLFxuICogICAgICAgfSxcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuUHJvZ3JhbVNwZWM+fSBwcm9ncmFtU3BlY3MgQW4gb2JqZWN0IG9mIFByb2dyYW1TcGVjcywgb25lIHBlciBwcm9ncmFtLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc30gW3Byb2dyYW1PcHRpb25zXSBvcHRpb25zIHRvIGFwcGx5IHRvIGFsbCBwcm9ncmFtc1xuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMUHJvZ3JhbT4/fSB0aGUgY3JlYXRlZCBwcm9ncmFtSW5mb3MgYnkgbmFtZVxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtcyhnbCwgcHJvZ3JhbVNwZWNzLCBwcm9ncmFtT3B0aW9ucyA9IHt9KSB7XG4gIC8vIFJlbWVtYmVyIGV4aXN0aW5nIHNoYWRlcnMgc28gdGhhdCBpZiB0aGVyZSBpcyBhbiBlcnJvciB3ZSBkb24ndCBkZWxldGUgdGhlbVxuICBjb25zdCBub0RlbGV0ZVNoYWRlcnNTZXQgPSBuZXcgU2V0KCk7XG5cbiAgLy8gY29tcGlsZSBhbmQgbGluayBldmVyeXRoaW5nXG4gIGNvbnN0IHByb2dyYW1zID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHByb2dyYW1TcGVjcykubWFwKChbbmFtZSwgc3BlY10pID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gey4uLnByb2dyYW1PcHRpb25zfTtcbiAgICBjb25zdCBzaGFkZXJzID0gQXJyYXkuaXNBcnJheShzcGVjKSA/IHNwZWMgOiBzcGVjLnNoYWRlcnM7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHNwZWMpO1xuICAgIH1cbiAgICBzaGFkZXJzLmZvckVhY2gobm9EZWxldGVTaGFkZXJzU2V0LmFkZCwgbm9EZWxldGVTaGFkZXJzU2V0KTtcbiAgICByZXR1cm4gW25hbWUsIGNyZWF0ZVByb2dyYW1Ob0NoZWNrKGdsLCBzaGFkZXJzLCBvcHRpb25zKV07XG4gIH0pKTtcblxuICBpZiAocHJvZ3JhbU9wdGlvbnMuY2FsbGJhY2spIHtcbiAgICB3YWl0Rm9yQWxsUHJvZ3JhbXNMaW5rQ29tcGxldGlvbkFzeW5jKGdsLCBwcm9ncmFtcykudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvcnMgPSBjaGVja0FsbFByb2dyYW1zKGdsLCBwcm9ncmFtcywgcHJvZ3JhbVNwZWNzLCBub0RlbGV0ZVNoYWRlcnNTZXQsIHByb2dyYW1PcHRpb25zKTtcbiAgICAgIHByb2dyYW1PcHRpb25zLmNhbGxiYWNrKGVycm9ycywgZXJyb3JzID8gdW5kZWZpbmVkIDogcHJvZ3JhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBlcnJvcnMgPSBjaGVja0FsbFByb2dyYW1zKGdsLCBwcm9ncmFtcywgcHJvZ3JhbVNwZWNzLCBub0RlbGV0ZVNoYWRlcnNTZXQsIHByb2dyYW1PcHRpb25zKTtcbiAgcmV0dXJuIGVycm9ycyA/IHVuZGVmaW5lZCA6IHByb2dyYW1zO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgbXVsdGlwbGUgcHJvZ3JhbUluZm9zXG4gKlxuICogTm90ZTogdGhlIHJlYXNvbiB0aGlzIGZ1bmN0aW9uIGV4aXN0cyBpcyBiZWNhdXNlIHRoZSBmYXN0ZXN0IHdheSB0byBjcmVhdGUgbXVsdGlwbGVcbiAqIHByb2dyYW1zIGluIFdlYkdMIGlzIHRvIGNyZWF0ZSBhbmQgY29tcGlsZSBhbGwgc2hhZGVycyBhbmQgbGluayBhbGwgcHJvZ3JhbXMgYW5kIG9ubHlcbiAqIGFmdGVyd2FyZHMgY2hlY2sgaWYgdGhleSBzdWNjZWVkZWQuIEluIHRoYXQgd2F5LCBnaXZpbmcgYWxsIHlvdXIgc2hhZGVyc1xuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfVxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICBjb25zdCBwcm9ncmFtSW5mb3MgPSB0d2dsLmNyZWF0ZVByb2dyYW1JbmZvcyhnbCwge1xuICogICAgICAgbGFtYmVydDogW2xhbWJlcnRWUywgbGFtYmVydEZTXSxcbiAqICAgICAgIHBob25nOiBbcGhvbmdWUywgcGhvbmVGU10sXG4gKiAgICAgICBwYXJ0aWNsZXM6IHtcbiAqICAgICAgICAgc2hhZGVyczogW3BhcnRpY2xlc1ZTLCBwYXJ0aWNsZXNGU10sXG4gKiAgICAgICAgIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M6IFsncG9zaXRpb24nLCAndmVsb2NpdHknXSxcbiAqICAgICAgIH0sXG4gKiAgICAgfSk7XG4gKlxuICogb3JcbiAqXG4gKiAgICAgY29uc3Qge2xhbWJlcnQsIHBob25nLCBwYXJ0aWNsZXN9ID0gdHdnbC5jcmVhdGVQcm9ncmFtSW5mb3MoZ2wsIHtcbiAqICAgICAgIGxhbWJlcnQ6IFtsYW1iZXJ0VlMsIGxhbWJlcnRGU10sXG4gKiAgICAgICBwaG9uZzogW3Bob25nVlMsIHBob25lRlNdLFxuICogICAgICAgcGFydGljbGVzOiB7XG4gKiAgICAgICAgIHNoYWRlcnM6IFtwYXJ0aWNsZXNWUywgcGFydGljbGVzRlNdLFxuICogICAgICAgICB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzOiBbJ3Bvc2l0aW9uJywgJ3ZlbG9jaXR5J10sXG4gKiAgICAgICB9LFxuICogICAgIH0pO1xuICpcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuUHJvZ3JhbVNwZWM+fSBwcm9ncmFtU3BlY3MgQW4gb2JqZWN0IG9mIFByb2dyYW1TcGVjcywgb25lIHBlciBwcm9ncmFtLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc30gW3Byb2dyYW1PcHRpb25zXSBvcHRpb25zIHRvIGFwcGx5IHRvIGFsbCBwcm9ncmFtc1xuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvPj99IHRoZSBjcmVhdGVkIHByb2dyYW1JbmZvcyBieSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1JbmZvcyhnbCwgcHJvZ3JhbVNwZWNzLCBwcm9ncmFtT3B0aW9ucykge1xuICBwcm9ncmFtT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKHByb2dyYW1PcHRpb25zKTtcblxuICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtSW5mb3NGb3JQcm9ncmFtcyhnbCwgcHJvZ3JhbXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHByb2dyYW1zKS5tYXAoKFtuYW1lLCBwcm9ncmFtXSkgPT5cbiAgICAgIFtuYW1lLCBjcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtKGdsLCBwcm9ncmFtKV1cbiAgICApKTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdDYWxsYmFjayA9IHByb2dyYW1PcHRpb25zLmNhbGxiYWNrO1xuICBpZiAob3JpZ0NhbGxiYWNrKSB7XG4gICAgcHJvZ3JhbU9wdGlvbnMuY2FsbGJhY2sgPSAoZXJyLCBwcm9ncmFtcykgPT4ge1xuICAgICAgb3JpZ0NhbGxiYWNrKGVyciwgZXJyID8gdW5kZWZpbmVkIDogY3JlYXRlUHJvZ3JhbUluZm9zRm9yUHJvZ3JhbXMoZ2wsIHByb2dyYW1zKSk7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHByb2dyYW1zID0gY3JlYXRlUHJvZ3JhbXMoZ2wsIHByb2dyYW1TcGVjcywgcHJvZ3JhbU9wdGlvbnMpO1xuICBpZiAob3JpZ0NhbGxiYWNrIHx8ICFwcm9ncmFtcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUHJvZ3JhbUluZm9zRm9yUHJvZ3JhbXMoZ2wsIHByb2dyYW1zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIG11bHRpcGxlIHByb2dyYW1zIGFzeW5jaHJvbm91c2x5XG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUFzeW5jfVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1zID0gYXdhaXQgdHdnbC5jcmVhdGVQcm9ncmFtc0FzeW5jKGdsLCB7XG4gKiAgICAgICBsYW1iZXJ0OiBbbGFtYmVydFZTLCBsYW1iZXJ0RlNdLFxuICogICAgICAgcGhvbmc6IFtwaG9uZ1ZTLCBwaG9uZUZTXSxcbiAqICAgICAgIHBhcnRpY2xlczoge1xuICogICAgICAgICBzaGFkZXJzOiBbcGFydGljbGVzVlMsIHBhcnRpY2xlc0ZTXSxcbiAqICAgICAgICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nczogWydwb3NpdGlvbicsICd2ZWxvY2l0eSddLFxuICogICAgICAgfSxcbiAqICAgICB9KTtcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBtb2R1bGU6dHdnbC5Qcm9ncmFtU3BlYz59IHByb2dyYW1TcGVjcyBBbiBvYmplY3Qgb2YgUHJvZ3JhbVNwZWNzLCBvbmUgcGVyIHByb2dyYW0uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfSBbcHJvZ3JhbU9wdGlvbnNdIG9wdGlvbnMgdG8gYXBwbHkgdG8gYWxsIHByb2dyYW1zXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xQcm9ncmFtPj99IHRoZSBjcmVhdGVkIHByb2dyYW1JbmZvcyBieSBuYW1lXG4gKi9cbmNvbnN0IGNyZWF0ZVByb2dyYW1zQXN5bmMgPSB3cmFwQ2FsbGJhY2tGblRvQXN5bmNGbihjcmVhdGVQcm9ncmFtcyk7XG5cbi8qKlxuICogQ3JlYXRlcyBtdWx0aXBsZSBwcm9ncmFtSW5mb3MgYXN5bmNocm9ub3VzbHlcbiAqXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb0FzeW5jfVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb2dyYW1JbmZvcyA9IGF3YWl0IHR3Z2wuY3JlYXRlUHJvZ3JhbUluZm9zQXN5bmMoZ2wsIHtcbiAqICAgICAgIGxhbWJlcnQ6IFtsYW1iZXJ0VlMsIGxhbWJlcnRGU10sXG4gKiAgICAgICBwaG9uZzogW3Bob25nVlMsIHBob25lRlNdLFxuICogICAgICAgcGFydGljbGVzOiB7XG4gKiAgICAgICAgIHNoYWRlcnM6IFtwYXJ0aWNsZXNWUywgcGFydGljbGVzRlNdLFxuICogICAgICAgICB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzOiBbJ3Bvc2l0aW9uJywgJ3ZlbG9jaXR5J10sXG4gKiAgICAgICB9LFxuICogICAgIH0pO1xuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLlByb2dyYW1TcGVjPn0gcHJvZ3JhbVNwZWNzIEFuIG9iamVjdCBvZiBQcm9ncmFtU3BlY3MsIG9uZSBwZXIgcHJvZ3JhbS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN9IFtwcm9ncmFtT3B0aW9uc10gb3B0aW9ucyB0byBhcHBseSB0byBhbGwgcHJvZ3JhbXNcbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvPj59IHRoZSBjcmVhdGVkIHByb2dyYW1JbmZvcyBieSBuYW1lXG4gKi9cbmNvbnN0IGNyZWF0ZVByb2dyYW1JbmZvc0FzeW5jID0gd3JhcENhbGxiYWNrRm5Ub0FzeW5jRm4oY3JlYXRlUHJvZ3JhbUluZm9zKTtcblxudmFyIHByb2dyYW1zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnM6IGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnMsXG4gIGNyZWF0ZVByb2dyYW06IGNyZWF0ZVByb2dyYW0sXG4gIGNyZWF0ZVByb2dyYW1Bc3luYzogY3JlYXRlUHJvZ3JhbUFzeW5jLFxuICBjcmVhdGVQcm9ncmFtczogY3JlYXRlUHJvZ3JhbXMsXG4gIGNyZWF0ZVByb2dyYW1zQXN5bmM6IGNyZWF0ZVByb2dyYW1zQXN5bmMsXG4gIGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0czogY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzLFxuICBjcmVhdGVQcm9ncmFtRnJvbVNvdXJjZXM6IGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyxcbiAgY3JlYXRlUHJvZ3JhbUluZm86IGNyZWF0ZVByb2dyYW1JbmZvLFxuICBjcmVhdGVQcm9ncmFtSW5mb0FzeW5jOiBjcmVhdGVQcm9ncmFtSW5mb0FzeW5jLFxuICBjcmVhdGVQcm9ncmFtSW5mb3M6IGNyZWF0ZVByb2dyYW1JbmZvcyxcbiAgY3JlYXRlUHJvZ3JhbUluZm9zQXN5bmM6IGNyZWF0ZVByb2dyYW1JbmZvc0FzeW5jLFxuICBjcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtOiBjcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtLFxuICBjcmVhdGVVbmlmb3JtU2V0dGVyczogY3JlYXRlVW5pZm9ybVNldHRlcnMsXG4gIGNyZWF0ZVVuaWZvcm1CbG9ja1NwZWNGcm9tUHJvZ3JhbTogY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtLFxuICBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW06IGNyZWF0ZVVuaWZvcm1CbG9ja0luZm9Gcm9tUHJvZ3JhbSxcbiAgY3JlYXRlVW5pZm9ybUJsb2NrSW5mbzogY3JlYXRlVW5pZm9ybUJsb2NrSW5mbyxcbiAgY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2s6IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrLFxuICBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm86IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrSW5mbyxcbiAgYmluZFRyYW5zZm9ybUZlZWRiYWNrSW5mbzogYmluZFRyYW5zZm9ybUZlZWRiYWNrSW5mbyxcbiAgc2V0QXR0cmlidXRlczogc2V0QXR0cmlidXRlcyxcbiAgc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXM6IHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzLFxuICBzZXRVbmlmb3Jtczogc2V0VW5pZm9ybXMsXG4gIHNldFVuaWZvcm1zQW5kQmluZFRleHR1cmVzOiBzZXRVbmlmb3Jtc0FuZEJpbmRUZXh0dXJlcyxcbiAgc2V0VW5pZm9ybUJsb2NrOiBzZXRVbmlmb3JtQmxvY2ssXG4gIHNldEJsb2NrVW5pZm9ybXM6IHNldEJsb2NrVW5pZm9ybXMsXG4gIGJpbmRVbmlmb3JtQmxvY2s6IGJpbmRVbmlmb3JtQmxvY2tcbn0pO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IFRSSUFOR0xFUyAgICAgICAgICAgICAgICAgICAgICA9IDB4MDAwNDtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUICAgICAgICAgICAgICAgICA9IDB4MTQwMztcblxuLyoqXG4gKiBEcmF3aW5nIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wuZHJhd2AgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL2RyYXdcbiAqL1xuXG4vKipcbiAqIENhbGxzIGBnbC5kcmF3RWxlbWVudHNgIG9yIGBnbC5kcmF3QXJyYXlzYCwgd2hpY2hldmVyIGlzIGFwcHJvcHJpYXRlXG4gKlxuICogbm9ybWFsbHkgeW91J2QgY2FsbCBgZ2wuZHJhd0VsZW1lbnRzYCBvciBgZ2wuZHJhd0FycmF5c2AgeW91cnNlbGZcbiAqIGJ1dCBjYWxsaW5nIHRoaXMgbWVhbnMgaWYgeW91IHN3aXRjaCBmcm9tIGluZGV4ZWQgZGF0YSB0byBub24taW5kZXhlZFxuICogZGF0YSB5b3UgZG9uJ3QgaGF2ZSB0byByZW1lbWJlciB0byB1cGRhdGUgeW91ciBkcmF3IGNhbGwuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfG1vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mbyl9IGJ1ZmZlckluZm8gQSBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzfSBvclxuICogICBhIFZlcnRleEFycmF5SW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVWZXJ0ZXhBcnJheUluZm99XG4gKiBAcGFyYW0ge251bWJlcn0gW3R5cGVdIGVnIChnbC5UUklBTkdMRVMsIGdsLkxJTkVTLCBnbC5QT0lOVFMsIGdsLlRSSUFOR0xFX1NUUklQLCAuLi4pLiBEZWZhdWx0cyB0byBgZ2wuVFJJQU5HTEVTYFxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gQW4gb3B0aW9uYWwgY291bnQuIERlZmF1bHRzIHRvIGJ1ZmZlckluZm8ubnVtRWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBBbiBvcHRpb25hbCBvZmZzZXQuIERlZmF1bHRzIHRvIDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2luc3RhbmNlQ291bnRdIEFuIG9wdGlvbmFsIGluc3RhbmNlQ291bnQuIGlmIHNldCB0aGVuIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCBvciBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkYCB3aWxsIGJlIGNhbGxlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2RyYXdcbiAqL1xuZnVuY3Rpb24gZHJhd0J1ZmZlckluZm8oZ2wsIGJ1ZmZlckluZm8sIHR5cGUsIGNvdW50LCBvZmZzZXQsIGluc3RhbmNlQ291bnQpIHtcbiAgdHlwZSA9IHR5cGUgPT09IHVuZGVmaW5lZCA/IFRSSUFOR0xFUyA6IHR5cGU7XG4gIGNvbnN0IGluZGljZXMgPSBidWZmZXJJbmZvLmluZGljZXM7XG4gIGNvbnN0IGVsZW1lbnRUeXBlID0gYnVmZmVySW5mby5lbGVtZW50VHlwZTtcbiAgY29uc3QgbnVtRWxlbWVudHMgPSBjb3VudCA9PT0gdW5kZWZpbmVkID8gYnVmZmVySW5mby5udW1FbGVtZW50cyA6IGNvdW50O1xuICBvZmZzZXQgPSBvZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAgOiBvZmZzZXQ7XG4gIGlmIChlbGVtZW50VHlwZSB8fCBpbmRpY2VzKSB7XG4gICAgaWYgKGluc3RhbmNlQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkKHR5cGUsIG51bUVsZW1lbnRzLCBlbGVtZW50VHlwZSA9PT0gdW5kZWZpbmVkID8gVU5TSUdORURfU0hPUlQgOiBidWZmZXJJbmZvLmVsZW1lbnRUeXBlLCBvZmZzZXQsIGluc3RhbmNlQ291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5kcmF3RWxlbWVudHModHlwZSwgbnVtRWxlbWVudHMsIGVsZW1lbnRUeXBlID09PSB1bmRlZmluZWQgPyBVTlNJR05FRF9TSE9SVCA6IGJ1ZmZlckluZm8uZWxlbWVudFR5cGUsIG9mZnNldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpbnN0YW5jZUNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQodHlwZSwgb2Zmc2V0LCBudW1FbGVtZW50cywgaW5zdGFuY2VDb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRyYXdBcnJheXModHlwZSwgb2Zmc2V0LCBudW1FbGVtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSBEcmF3T2JqZWN0IGlzIHVzZWZ1bCBmb3IgcHV0dGluZyBvYmplY3RzIGluIHRvIGFuIGFycmF5IGFuZCBwYXNzaW5nIHRoZW0gdG8ge0BsaW5rIG1vZHVsZTp0d2dsLmRyYXdPYmplY3RMaXN0fS5cbiAqXG4gKiBZb3UgbmVlZCBlaXRoZXIgYSBgQnVmZmVySW5mb2Agb3IgYSBgVmVydGV4QXJyYXlJbmZvYC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEcmF3T2JqZWN0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthY3RpdmVdIHdoZXRoZXIgb3Igbm90IHRvIGRyYXcuIERlZmF1bHQgPSBgdHJ1ZWAgKG11c3QgYmUgYGZhbHNlYCB0byBiZSBub3QgdHJ1ZSkuIEluIG90aGVyIHdvcmRzIGB1bmRlZmluZWRgID0gYHRydWVgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIHR5cGUgdG8gZHJhdyBlZy4gYGdsLlRSSUFOR0xFU2AsIGBnbC5MSU5FU2AsIGV0Yy4uLlxuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb30gcHJvZ3JhbUluZm8gQSBQcm9ncmFtSW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb31cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gW2J1ZmZlckluZm9dIEEgQnVmZmVySW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5c31cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnR3Z2wuVmVydGV4QXJyYXlJbmZvfSBbdmVydGV4QXJyYXlJbmZvXSBBIFZlcnRleEFycmF5SW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVWZXJ0ZXhBcnJheUluZm99XG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsID8+fSB1bmlmb3JtcyBUaGUgdmFsdWVzIGZvciB0aGUgdW5pZm9ybXMuXG4gKiAgIFlvdSBjYW4gcGFzcyBtdWx0aXBsZSBvYmplY3RzIGJ5IHB1dHRpbmcgdGhlbSBpbiBhbiBhcnJheS4gRm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIHNoYXJlZFVuaWZvcm1zID0ge1xuICogICAgICAgdV9mb2dOZWFyOiAxMCxcbiAqICAgICAgIHVfcHJvamVjdGlvbjogLi4uXG4gKiAgICAgICAuLi5cbiAqICAgICB9O1xuICpcbiAqICAgICB2YXIgbG9jYWxVbmlmb3JtcyA9IHtcbiAqICAgICAgIHVfd29ybGQ6IC4uLlxuICogICAgICAgdV9kaWZmdXNlQ29sb3I6IC4uLlxuICogICAgIH07XG4gKlxuICogICAgIHZhciBkcmF3T2JqID0ge1xuICogICAgICAgLi4uXG4gKiAgICAgICB1bmlmb3JtczogW3NoYXJlZFVuaWZvcm1zLCBsb2NhbFVuaWZvcm1zXSxcbiAqICAgICB9O1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0XSB0aGUgb2Zmc2V0IHRvIHBhc3MgdG8gYGdsLmRyYXdBcnJheXNgIG9yIGBnbC5kcmF3RWxlbWVudHNgLiBEZWZhdWx0cyB0byAwLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb3VudF0gdGhlIGNvdW50IHRvIHBhc3MgdG8gYGdsLmRyYXdBcnJheXNgIG9yIGBnbC5kcmF3RWxlbWVudHNgLiBEZWZhdWx0cyB0byBidWZmZXJJbmZvLm51bUVsZW1lbnRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtpbnN0YW5jZUNvdW50XSB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcy4gRGVmYXVsdHMgdG8gdW5kZWZpbmVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBEcmF3cyBhIGxpc3Qgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge0RyYXdPYmplY3RbXX0gb2JqZWN0c1RvRHJhdyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIGRyYXcuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvZHJhd1xuICovXG5mdW5jdGlvbiBkcmF3T2JqZWN0TGlzdChnbCwgb2JqZWN0c1RvRHJhdykge1xuICBsZXQgbGFzdFVzZWRQcm9ncmFtSW5mbyA9IG51bGw7XG4gIGxldCBsYXN0VXNlZEJ1ZmZlckluZm8gPSBudWxsO1xuXG4gIG9iamVjdHNUb0RyYXcuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IG9iamVjdC5wcm9ncmFtSW5mbztcbiAgICBjb25zdCBidWZmZXJJbmZvID0gb2JqZWN0LnZlcnRleEFycmF5SW5mbyB8fCBvYmplY3QuYnVmZmVySW5mbztcbiAgICBsZXQgYmluZEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlID0gb2JqZWN0LnR5cGUgPT09IHVuZGVmaW5lZCA/IFRSSUFOR0xFUyA6IG9iamVjdC50eXBlO1xuXG4gICAgaWYgKHByb2dyYW1JbmZvICE9PSBsYXN0VXNlZFByb2dyYW1JbmZvKSB7XG4gICAgICBsYXN0VXNlZFByb2dyYW1JbmZvID0gcHJvZ3JhbUluZm87XG4gICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW1JbmZvLnByb2dyYW0pO1xuXG4gICAgICAvLyBXZSBoYXZlIHRvIHJlYmluZCBidWZmZXJzIHdoZW4gY2hhbmdpbmcgcHJvZ3JhbXMgYmVjYXVzZSB3ZVxuICAgICAgLy8gb25seSBiaW5kIGJ1ZmZlcnMgdGhlIHByb2dyYW0gdXNlcy4gU28gaWYgMiBwcm9ncmFtcyB1c2UgdGhlIHNhbWVcbiAgICAgIC8vIGJ1ZmZlckluZm8gYnV0IHRoZSAxc3Qgb25lIHVzZXMgb25seSBwb3NpdGlvbnMgdGhlIHdoZW4gdGhlXG4gICAgICAvLyB3ZSBzd2l0Y2ggdG8gdGhlIDJuZCBvbmUgc29tZSBvZiB0aGUgYXR0cmlidXRlcyB3aWxsIG5vdCBiZSBvbi5cbiAgICAgIGJpbmRCdWZmZXJzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBhbGwgdGhlIG5lZWRlZCBhdHRyaWJ1dGVzLlxuICAgIGlmIChiaW5kQnVmZmVycyB8fCBidWZmZXJJbmZvICE9PSBsYXN0VXNlZEJ1ZmZlckluZm8pIHtcbiAgICAgIGlmIChsYXN0VXNlZEJ1ZmZlckluZm8gJiYgbGFzdFVzZWRCdWZmZXJJbmZvLnZlcnRleEFycmF5T2JqZWN0ICYmICFidWZmZXJJbmZvLnZlcnRleEFycmF5T2JqZWN0KSB7XG4gICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgICAgIH1cbiAgICAgIGxhc3RVc2VkQnVmZmVySW5mbyA9IGJ1ZmZlckluZm87XG4gICAgICBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgdW5pZm9ybXMuXG4gICAgc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIG9iamVjdC51bmlmb3Jtcyk7XG5cbiAgICAvLyBEcmF3XG4gICAgZHJhd0J1ZmZlckluZm8oZ2wsIGJ1ZmZlckluZm8sIHR5cGUsIG9iamVjdC5jb3VudCwgb2JqZWN0Lm9mZnNldCwgb2JqZWN0Lmluc3RhbmNlQ291bnQpO1xuICB9KTtcblxuICBpZiAobGFzdFVzZWRCdWZmZXJJbmZvICYmIGxhc3RVc2VkQnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgfVxufVxuXG52YXIgZHJhdyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkcmF3QnVmZmVySW5mbzogZHJhd0J1ZmZlckluZm8sXG4gIGRyYXdPYmplY3RMaXN0OiBkcmF3T2JqZWN0TGlzdFxufSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuY29uc3QgRlJBTUVCVUZGRVIgICAgICAgICAgICAgICAgICAgID0gMHg4ZDQwO1xuY29uc3QgUkVOREVSQlVGRkVSICAgICAgICAgICAgICAgICAgID0gMHg4ZDQxO1xuY29uc3QgVEVYVFVSRV8yRCAgICAgICAgICAgICAgICAgICAgID0gMHgwZGUxO1xuXG5jb25zdCBVTlNJR05FRF9CWVRFICAgICAgICAgICAgICAgICAgPSAweDE0MDE7XG5cbi8qIFBpeGVsRm9ybWF0ICovXG5jb25zdCBERVBUSF9DT01QT05FTlQgICAgICAgICAgICAgICAgPSAweDE5MDI7XG5jb25zdCBSR0JBICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE5MDg7XG5jb25zdCBERVBUSF9DT01QT05FTlQyNCAgICAgICAgICAgICAgPSAweDgxYTY7XG5jb25zdCBERVBUSF9DT01QT05FTlQzMkYgICAgICAgICAgICAgPSAweDhjYWM7XG5jb25zdCBERVBUSDI0X1NURU5DSUw4ICAgICAgICAgICAgICAgPSAweDg4ZjA7XG5jb25zdCBERVBUSDMyRl9TVEVOQ0lMOCAgICAgICAgICAgICAgPSAweDhjYWQ7XG5cbi8qIEZyYW1lYnVmZmVyIE9iamVjdC4gKi9cbmNvbnN0IFJHQkE0ICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODA1NjtcbmNvbnN0IFJHQjVfQTEgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODA1NztcbmNvbnN0IFJHQjU2NSAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ2MjtcbmNvbnN0IERFUFRIX0NPTVBPTkVOVDE2ICAgICAgICAgICAgICA9IDB4ODFBNTtcbmNvbnN0IFNURU5DSUxfSU5ERVggICAgICAgICAgICAgICAgICA9IDB4MTkwMTtcbmNvbnN0IFNURU5DSUxfSU5ERVg4ICAgICAgICAgICAgICAgICA9IDB4OEQ0ODtcbmNvbnN0IERFUFRIX1NURU5DSUwgICAgICAgICAgICAgICAgICA9IDB4ODRGOTtcbmNvbnN0IENPTE9SX0FUVEFDSE1FTlQwICAgICAgICAgICAgICA9IDB4OENFMDtcbmNvbnN0IERFUFRIX0FUVEFDSE1FTlQgICAgICAgICAgICAgICA9IDB4OEQwMDtcbmNvbnN0IFNURU5DSUxfQVRUQUNITUVOVCAgICAgICAgICAgICA9IDB4OEQyMDtcbmNvbnN0IERFUFRIX1NURU5DSUxfQVRUQUNITUVOVCAgICAgICA9IDB4ODIxQTtcblxuLyogVGV4dHVyZVdyYXBNb2RlICovXG5jb25zdCBDTEFNUF9UT19FREdFICAgICAgICAgICAgICAgICAgPSAweDgxMkY7XG5cbi8qIFRleHR1cmVNYWdGaWx0ZXIgKi9cbmNvbnN0IExJTkVBUiAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MjYwMTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyBmb3IgYSBmcmFtZWJ1ZmZlciBhdHRhY2htZW50LlxuICpcbiAqIE5vdGU6IEZvciBhIGBmb3JtYXRgIHRoYXQgaXMgYSB0ZXh0dXJlIGluY2x1ZGUgYWxsIHRoZSB0ZXh0dXJlXG4gKiBvcHRpb25zIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBmb3IgZXhhbXBsZVxuICogYG1pbmAsIGBtYWdgLCBgY2xhbXBgLCBldGMuLi4gTm90ZSB0aGF0IHVubGlrZSB7QGxpbmsgbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9XG4gKiBgYXV0b2AgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3IgYXR0YWNobWVudCB0ZXh0dXJlcyBidXQgYG1pbmAgYW5kIGBtYWdgIGRlZmF1bHRcbiAqIHRvIGBnbC5MSU5FQVJgIGFuZCBgd3JhcGAgZGVmYXVsdHMgdG8gYENMQU1QX1RPX0VER0VgXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQXR0YWNobWVudE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYXR0YWNobWVudFBvaW50XSBUaGUgYXR0YWNobWVudCBwb2ludC4gRGVmYXVsdHNcbiAqICAgdG8gYGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgbmR4YCB1bmxlc3MgdHlwZSBpcyBhIGRlcHRoIG9yIHN0ZW5jaWwgdHlwZVxuICogICB0aGVuIGl0J3MgZ2wuREVQVEhfQVRUQUNITUVOVCBvciBgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UYCBkZXBlbmRpbmdcbiAqICAgb24gdGhlIGZvcm1hdCBvciBhdHRhY2htZW50IHR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Zvcm1hdF0gVGhlIGZvcm1hdC4gSWYgb25lIG9mIGBnbC5SR0JBNGAsXG4gKiAgIGBnbC5SR0I1NjVgLCBgZ2wuUkdCNV9BMWAsIGBnbC5ERVBUSF9DT01QT05FTlQxNmAsXG4gKiAgIGBnbC5TVEVOQ0lMX0lOREVYOGAgb3IgYGdsLkRFUFRIX1NURU5DSUxgIHRoZW4gd2lsbCBjcmVhdGUgYVxuICogICByZW5kZXJidWZmZXIuIE90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIHRleHR1cmUuIERlZmF1bHQgPSBgZ2wuUkdCQWBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHlwZV0gVGhlIHR5cGUuIFVzZWQgZm9yIHRleHR1cmUuIERlZmF1bHQgPSBgZ2wuVU5TSUdORURfQllURWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldF0gVGhlIHRleHR1cmUgdGFyZ2V0IGZvciBgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkRgLlxuICogICBEZWZhdWx0cyB0byBgZ2wuVEVYVFVSRV8yRGAuIFNldCB0byBhcHByb3ByaWF0ZSBmYWNlIGZvciBjdWJlIG1hcHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NhbXBsZXNdIFRoZSBudW1iZXIgb2Ygc2FtcGxlcy4gRGVmYXVsdCA9IDFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGV2ZWxdIGxldmVsIGZvciBgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkRgLiBEZWZhdWx0cyB0byAwLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYXllcl0gbGF5ZXIgZm9yIGBnbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcmAuIERlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAqICAgSWYgc2V0IHRoZW4gYGdsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyYCBpcyBjYWxsZWQsIGlmIG5vdCB0aGVuIGBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRGBcbiAqIEBwcm9wZXJ0eSB7KFdlYkdMUmVuZGVyYnVmZmVyIHwgV2ViR0xUZXh0dXJlKX0gW2F0dGFjaG1lbnRdIEFuIGV4aXN0aW5nIHJlbmRlcmJ1ZmZlciBvciB0ZXh0dXJlLlxuICogICAgSWYgcHJvdmlkZWQgd2lsbCBhdHRhY2ggdGhpcyBPYmplY3QuIFRoaXMgYWxsb3dzIHlvdSB0byBzaGFyZVxuICogICAgYXR0YWNobWVudHMgYWNyb3NzIGZyYW1lYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICogQG1peGVzIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zXG4gKi9cblxuY29uc3QgZGVmYXVsdEF0dGFjaG1lbnRzID0gW1xuICB7IGZvcm1hdDogUkdCQSwgdHlwZTogVU5TSUdORURfQllURSwgbWluOiBMSU5FQVIsIHdyYXA6IENMQU1QX1RPX0VER0UsIH0sXG4gIHsgZm9ybWF0OiBERVBUSF9TVEVOQ0lMLCB9LFxuXTtcblxuY29uc3QgYXR0YWNobWVudHNCeUZvcm1hdCA9IHt9O1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSF9TVEVOQ0lMXSA9IERFUFRIX1NURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbU1RFTkNJTF9JTkRFWF0gPSBTVEVOQ0lMX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W1NURU5DSUxfSU5ERVg4XSA9IFNURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UXSA9IERFUFRIX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIX0NPTVBPTkVOVDE2XSA9IERFUFRIX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIX0NPTVBPTkVOVDI0XSA9IERFUFRIX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIX0NPTVBPTkVOVDMyRl0gPSBERVBUSF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSDI0X1NURU5DSUw4XSA9IERFUFRIX1NURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEgzMkZfU1RFTkNJTDhdID0gREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UO1xuXG5mdW5jdGlvbiBnZXRBdHRhY2htZW50UG9pbnRGb3JGb3JtYXQoZm9ybWF0LCBpbnRlcm5hbEZvcm1hdCkge1xuICByZXR1cm4gYXR0YWNobWVudHNCeUZvcm1hdFtmb3JtYXRdIHx8IGF0dGFjaG1lbnRzQnlGb3JtYXRbaW50ZXJuYWxGb3JtYXRdO1xufVxuXG5jb25zdCByZW5kZXJidWZmZXJGb3JtYXRzID0ge307XG5yZW5kZXJidWZmZXJGb3JtYXRzW1JHQkE0XSA9IHRydWU7XG5yZW5kZXJidWZmZXJGb3JtYXRzW1JHQjVfQTFdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbUkdCNTY1XSA9IHRydWU7XG5yZW5kZXJidWZmZXJGb3JtYXRzW0RFUFRIX1NURU5DSUxdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbREVQVEhfQ09NUE9ORU5UMTZdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbU1RFTkNJTF9JTkRFWF0gPSB0cnVlO1xucmVuZGVyYnVmZmVyRm9ybWF0c1tTVEVOQ0lMX0lOREVYOF0gPSB0cnVlO1xuXG5mdW5jdGlvbiBpc1JlbmRlcmJ1ZmZlckZvcm1hdChmb3JtYXQpIHtcbiAgcmV0dXJuIHJlbmRlcmJ1ZmZlckZvcm1hdHNbZm9ybWF0XTtcbn1cblxuY29uc3QgTUFYX0NPTE9SX0FUVEFDSE1FTlRfUE9JTlRTID0gMzI7ICAvLyBldmVuIGFuIDMwOTAgb25seSBzdXBwb3J0cyA4IGJ1dCBXZWJHTC9PcGVuR0wgRVMgZGVmaW5lIGNvbnN0YW50cyBmb3IgMzJcblxuZnVuY3Rpb24gaXNDb2xvckF0dGFjaG1lbnRQb2ludChhdHRhY2htZW50UG9pbnQpIHtcbiAgcmV0dXJuIGF0dGFjaG1lbnRQb2ludCA+PSBDT0xPUl9BVFRBQ0hNRU5UMCAmJiBhdHRhY2htZW50UG9pbnQgPCBDT0xPUl9BVFRBQ0hNRU5UMCArIE1BWF9DT0xPUl9BVFRBQ0hNRU5UX1BPSU5UUztcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGcmFtZWJ1ZmZlckluZm9cbiAqIEBwcm9wZXJ0eSB7V2ViR0xGcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXIgVGhlIFdlYkdMRnJhbWVidWZmZXIgZm9yIHRoaXMgZnJhbWVidWZmZXJJbmZvXG4gKiBAcHJvcGVydHkge0FycmF5LjwoV2ViR0xSZW5kZXJidWZmZXIgfCBXZWJHTFRleHR1cmUpPn0gYXR0YWNobWVudHMgVGhlIGNyZWF0ZWQgYXR0YWNobWVudHMgaW4gdGhlIHNhbWUgb3JkZXIgYXMgcGFzc2VkIGluIHRvIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm99LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgZnJhbWVidWZmZXIgYW5kIGl0cyBhdHRhY2htZW50c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCBUaGUgd2lkdGggb2YgdGhlIGZyYW1lYnVmZmVyIGFuZCBpdHMgYXR0YWNobWVudHNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyYW1lYnVmZmVyIGFuZCBhdHRhY2htZW50cy5cbiAqXG4gKiBUaGlzIHJldHVybnMgYSB7QGxpbmsgbW9kdWxlOnR3Z2wuRnJhbWVidWZmZXJJbmZvfSBiZWNhdXNlIGl0IG5lZWRzIHRvIHJldHVybiB0aGUgYXR0YWNobWVudHMgYXMgd2VsbCBhcyB0aGUgZnJhbWVidWZmZXIuXG4gKiBJdCBhbHNvIGxlYXZlcyB0aGUgZnJhbWVidWZmZXIgaXQganVzdCBjcmVhdGVkIGFzIHRoZSBjdXJyZW50bHkgYm91bmQgYEZSQU1FQlVGRkVSYC5cbiAqIE5vdGU6IElmIHRoaXMgaXMgV2ViR0wyIG9yIGlmIHlvdSBjYWxsZWQge0BsaW5rIG1vZHVsZTp0d2dsLmFkZEV4dGVuc2lvbnNUb0NvbnRleHR9IHRoZW4gaXQgd2lsbCBzZXQgdGhlIGRyYXdCdWZmZXJzXG4gKiB0byBgW0NPTE9SX0FUVEFDSE1FTlQwLCBDT0xPUl9BVFRBQ0hNRU5UMSwgLi4uXWAgZm9yIGhvdyBldmVyIG1hbnkgY29sb3IgYXR0YWNobWVudHMgd2VyZSBjcmVhdGVkLlxuICpcbiAqIFRoZSBzaW1wbGVzdCB1c2FnZVxuICpcbiAqICAgICAvLyBjcmVhdGUgYW4gUkdCQS9VTlNJR05FRF9CWVRFIHRleHR1cmUgYW5kIERFUFRIX1NURU5DSUwgcmVuZGVyYnVmZmVyXG4gKiAgICAgY29uc3QgZmJpID0gdHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm8oZ2wpO1xuICpcbiAqIE1vcmUgY29tcGxleCB1c2FnZVxuICpcbiAqICAgICAvLyBjcmVhdGUgYW4gUkdCNTY1IHJlbmRlcmJ1ZmZlciBhbmQgYSBTVEVOQ0lMX0lOREVYOCByZW5kZXJidWZmZXJcbiAqICAgICBjb25zdCBhdHRhY2htZW50cyA9IFtcbiAqICAgICAgIHsgZm9ybWF0OiBSR0I1NjUsIG1hZzogTkVBUkVTVCB9LFxuICogICAgICAgeyBmb3JtYXQ6IFNURU5DSUxfSU5ERVg4IH0sXG4gKiAgICAgXVxuICogICAgIGNvbnN0IGZiaSA9IHR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvKGdsLCBhdHRhY2htZW50cyk7XG4gKlxuICogUGFzc2luZyBpbiBhIHNwZWNpZmljIHNpemVcbiAqXG4gKiAgICAgY29uc3Qgd2lkdGggPSAyNTY7XG4gKiAgICAgY29uc3QgaGVpZ2h0ID0gMjU2O1xuICogICAgIGNvbnN0IGZiaSA9IHR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvKGdsLCBhdHRhY2htZW50cywgd2lkdGgsIGhlaWdodCk7XG4gKlxuICogKipOb3RlISEqKiBJdCBpcyB1cCB0byB5b3UgdG8gY2hlY2sgaWYgdGhlIGZyYW1lYnVmZmVyIGlzIHJlbmRlcmFibGUgYnkgY2FsbGluZyBgZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1c2AuXG4gKiBbV2ViR0wxIG9ubHkgZ3VhcmFudGVlcyAzIGNvbWJpbmF0aW9ucyBvZiBhdHRhY2htZW50cyB3b3JrXShodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9zcGVjcy9sYXRlc3QvMS4wLyM2LjYpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkF0dGFjaG1lbnRPcHRpb25zW119IFthdHRhY2htZW50c10gd2hpY2ggYXR0YWNobWVudHMgdG8gY3JlYXRlLiBJZiBub3QgcHJvdmlkZWQgdGhlIGRlZmF1bHQgaXMgYSBmcmFtZWJ1ZmZlciB3aXRoIGFuXG4gKiAgICBgUkdCQWAsIGBVTlNJR05FRF9CWVRFYCB0ZXh0dXJlIGBDT0xPUl9BVFRBQ0hNRU5UMGAgYW5kIGEgYERFUFRIX1NURU5DSUxgIHJlbmRlcmJ1ZmZlciBgREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIHRoZSB3aWR0aCBmb3IgdGhlIGF0dGFjaG1lbnRzLiBEZWZhdWx0ID0gc2l6ZSBvZiBkcmF3aW5nQnVmZmVyXG4gKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gdGhlIGhlaWdodCBmb3IgdGhlIGF0dGFjaG1lbnRzLiBEZWZhdWx0ID0gc2l6ZSBvZiBkcmF3aW5nQnVmZmVyXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5GcmFtZWJ1ZmZlckluZm99IHRoZSBmcmFtZWJ1ZmZlciBhbmQgYXR0YWNobWVudHMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvZnJhbWVidWZmZXJzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gRlJBTUVCVUZGRVI7XG4gIGNvbnN0IGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZmIpO1xuICB3aWR0aCAgPSB3aWR0aCAgfHwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xuICBoZWlnaHQgPSBoZWlnaHQgfHwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgYXR0YWNobWVudHMgPSBhdHRhY2htZW50cyB8fCBkZWZhdWx0QXR0YWNobWVudHM7XG4gIGNvbnN0IHVzZWRDb2xvckF0dGFjaG1lbnRzUG9pbnRzID0gW107XG4gIGNvbnN0IGZyYW1lYnVmZmVySW5mbyA9IHtcbiAgICBmcmFtZWJ1ZmZlcjogZmIsXG4gICAgYXR0YWNobWVudHM6IFtdLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgfTtcblxuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGF0dGFjaG1lbnRPcHRpb25zLCBpKSB7XG4gICAgbGV0IGF0dGFjaG1lbnQgPSBhdHRhY2htZW50T3B0aW9ucy5hdHRhY2htZW50O1xuICAgIGNvbnN0IHNhbXBsZXMgPSBhdHRhY2htZW50T3B0aW9ucy5zYW1wbGVzO1xuICAgIGNvbnN0IGZvcm1hdCA9IGF0dGFjaG1lbnRPcHRpb25zLmZvcm1hdDtcbiAgICBsZXQgYXR0YWNobWVudFBvaW50ID0gYXR0YWNobWVudE9wdGlvbnMuYXR0YWNobWVudFBvaW50IHx8IGdldEF0dGFjaG1lbnRQb2ludEZvckZvcm1hdChmb3JtYXQsIGF0dGFjaG1lbnRPcHRpb25zLmludGVybmFsRm9ybWF0KTtcbiAgICBpZiAoIWF0dGFjaG1lbnRQb2ludCkge1xuICAgICAgYXR0YWNobWVudFBvaW50ID0gQ09MT1JfQVRUQUNITUVOVDAgKyBpO1xuICAgIH1cbiAgICBpZiAoaXNDb2xvckF0dGFjaG1lbnRQb2ludChhdHRhY2htZW50UG9pbnQpKSB7XG4gICAgICB1c2VkQ29sb3JBdHRhY2htZW50c1BvaW50cy5wdXNoKGF0dGFjaG1lbnRQb2ludCk7XG4gICAgfVxuICAgIGlmICghYXR0YWNobWVudCkge1xuICAgICAgaWYgKHNhbXBsZXMgIT09IHVuZGVmaW5lZCB8fCBpc1JlbmRlcmJ1ZmZlckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIGF0dGFjaG1lbnQgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihSRU5ERVJCVUZGRVIsIGF0dGFjaG1lbnQpO1xuICAgICAgICBpZiAoc2FtcGxlcyA+IDEpIHtcbiAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoUkVOREVSQlVGRkVSLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0dXJlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGF0dGFjaG1lbnRPcHRpb25zKTtcbiAgICAgICAgdGV4dHVyZU9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGV4dHVyZU9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBpZiAodGV4dHVyZU9wdGlvbnMuYXV0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMuYXV0byA9IGZhbHNlO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLm1pbiA9IHRleHR1cmVPcHRpb25zLm1pbiB8fCB0ZXh0dXJlT3B0aW9ucy5taW5NYWcgfHwgTElORUFSO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLm1hZyA9IHRleHR1cmVPcHRpb25zLm1hZyB8fCB0ZXh0dXJlT3B0aW9ucy5taW5NYWcgfHwgTElORUFSO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLndyYXBTID0gdGV4dHVyZU9wdGlvbnMud3JhcFMgfHwgdGV4dHVyZU9wdGlvbnMud3JhcCB8fCBDTEFNUF9UT19FREdFO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLndyYXBUID0gdGV4dHVyZU9wdGlvbnMud3JhcFQgfHwgdGV4dHVyZU9wdGlvbnMud3JhcCB8fCBDTEFNUF9UT19FREdFO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaG1lbnQgPSBjcmVhdGVUZXh0dXJlKGdsLCB0ZXh0dXJlT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlbmRlcmJ1ZmZlcihnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHRhcmdldCwgYXR0YWNobWVudFBvaW50LCBSRU5ERVJCVUZGRVIsIGF0dGFjaG1lbnQpO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0dXJlKGdsLCBhdHRhY2htZW50KSkge1xuICAgICAgaWYgKGF0dGFjaG1lbnRPcHRpb25zLmxheWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGF0dGFjaG1lbnRQb2ludCxcbiAgICAgICAgICBhdHRhY2htZW50LFxuICAgICAgICAgIGF0dGFjaG1lbnRPcHRpb25zLmxldmVsIHx8IDAsXG4gICAgICAgICAgYXR0YWNobWVudE9wdGlvbnMubGF5ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBhdHRhY2htZW50UG9pbnQsXG4gICAgICAgICAgICBhdHRhY2htZW50T3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRCxcbiAgICAgICAgICAgIGF0dGFjaG1lbnQsXG4gICAgICAgICAgICBhdHRhY2htZW50T3B0aW9ucy5sZXZlbCB8fCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGF0dGFjaG1lbnQgdHlwZScpO1xuICAgIH1cbiAgICBmcmFtZWJ1ZmZlckluZm8uYXR0YWNobWVudHMucHVzaChhdHRhY2htZW50KTtcbiAgfSk7XG4gIGlmIChnbC5kcmF3QnVmZmVycykge1xuICAgIGdsLmRyYXdCdWZmZXJzKHVzZWRDb2xvckF0dGFjaG1lbnRzUG9pbnRzKTtcbiAgfVxuICByZXR1cm4gZnJhbWVidWZmZXJJbmZvO1xufVxuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIGF0dGFjaG1lbnRzIG9mIGEgZnJhbWVidWZmZXIuXG4gKlxuICogWW91IG5lZWQgdG8gcGFzcyBpbiB0aGUgc2FtZSBgYXR0YWNobWVudHNgIGFzIHlvdSBwYXNzZWQgaW4ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb31cbiAqIGJlY2F1c2UgVFdHTCBoYXMgbm8gaWRlYSB0aGUgZm9ybWF0L3R5cGUgb2YgZWFjaCBhdHRhY2htZW50LlxuICpcbiAqIFRoZSBzaW1wbGVzdCB1c2FnZVxuICpcbiAqICAgICAvLyBjcmVhdGUgYW4gUkdCQS9VTlNJR05FRF9CWVRFIHRleHR1cmUgYW5kIERFUFRIX1NURU5DSUwgcmVuZGVyYnVmZmVyXG4gKiAgICAgY29uc3QgZmJpID0gdHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm8oZ2wpO1xuICpcbiAqICAgICAuLi5cbiAqXG4gKiAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICogICAgICAgaWYgKHR3Z2wucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZShnbC5jYW52YXMpKSB7XG4gKiAgICAgICAgIC8vIHJlc2l6ZSB0aGUgYXR0YWNobWVudHNcbiAqICAgICAgICAgdHdnbC5yZXNpemVGcmFtZWJ1ZmZlckluZm8oZ2wsIGZiaSk7XG4gKiAgICAgICB9XG4gKlxuICogTW9yZSBjb21wbGV4IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0I1NjUgcmVuZGVyYnVmZmVyIGFuZCBhIFNURU5DSUxfSU5ERVg4IHJlbmRlcmJ1ZmZlclxuICogICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gW1xuICogICAgICAgeyBmb3JtYXQ6IFJHQjU2NSwgbWFnOiBORUFSRVNUIH0sXG4gKiAgICAgICB7IGZvcm1hdDogU1RFTkNJTF9JTkRFWDggfSxcbiAqICAgICBdXG4gKiAgICAgY29uc3QgZmJpID0gdHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm8oZ2wsIGF0dGFjaG1lbnRzKTtcbiAqXG4gKiAgICAgLi4uXG4gKlxuICogICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAqICAgICAgIGlmICh0d2dsLnJlc2l6ZUNhbnZhc1RvRGlzcGxheVNpemUoZ2wuY2FudmFzKSkge1xuICogICAgICAgICAvLyByZXNpemUgdGhlIGF0dGFjaG1lbnRzIHRvIG1hdGNoXG4gKiAgICAgICAgIHR3Z2wucmVzaXplRnJhbWVidWZmZXJJbmZvKGdsLCBmYmksIGF0dGFjaG1lbnRzKTtcbiAqICAgICAgIH1cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5GcmFtZWJ1ZmZlckluZm99IGZyYW1lYnVmZmVySW5mbyBhIGZyYW1lYnVmZmVySW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm99LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BdHRhY2htZW50T3B0aW9uc1tdfSBbYXR0YWNobWVudHNdIHRoZSBzYW1lIGF0dGFjaG1lbnRzIG9wdGlvbnMgYXMgcGFzc2VkIHRvIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm99LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gdGhlIHdpZHRoIGZvciB0aGUgYXR0YWNobWVudHMuIERlZmF1bHQgPSBzaXplIG9mIGRyYXdpbmdCdWZmZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSB0aGUgaGVpZ2h0IGZvciB0aGUgYXR0YWNobWVudHMuIERlZmF1bHQgPSBzaXplIG9mIGRyYXdpbmdCdWZmZXJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9mcmFtZWJ1ZmZlcnNcbiAqL1xuZnVuY3Rpb24gcmVzaXplRnJhbWVidWZmZXJJbmZvKGdsLCBmcmFtZWJ1ZmZlckluZm8sIGF0dGFjaG1lbnRzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHdpZHRoICA9IHdpZHRoICB8fCBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gIGhlaWdodCA9IGhlaWdodCB8fCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICBmcmFtZWJ1ZmZlckluZm8ud2lkdGggPSB3aWR0aDtcbiAgZnJhbWVidWZmZXJJbmZvLmhlaWdodCA9IGhlaWdodDtcbiAgYXR0YWNobWVudHMgPSBhdHRhY2htZW50cyB8fCBkZWZhdWx0QXR0YWNobWVudHM7XG4gIGF0dGFjaG1lbnRzLmZvckVhY2goZnVuY3Rpb24oYXR0YWNobWVudE9wdGlvbnMsIG5keCkge1xuICAgIGNvbnN0IGF0dGFjaG1lbnQgPSBmcmFtZWJ1ZmZlckluZm8uYXR0YWNobWVudHNbbmR4XTtcbiAgICBjb25zdCBmb3JtYXQgPSBhdHRhY2htZW50T3B0aW9ucy5mb3JtYXQ7XG4gICAgY29uc3Qgc2FtcGxlcyA9IGF0dGFjaG1lbnRPcHRpb25zLnNhbXBsZXM7XG4gICAgaWYgKHNhbXBsZXMgIT09IHVuZGVmaW5lZCB8fCBpc1JlbmRlcmJ1ZmZlcihnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoUkVOREVSQlVGRkVSLCBhdHRhY2htZW50KTtcbiAgICAgIGlmIChzYW1wbGVzID4gMSkge1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShSRU5ERVJCVUZGRVIsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHR1cmUoZ2wsIGF0dGFjaG1lbnQpKSB7XG4gICAgICByZXNpemVUZXh0dXJlKGdsLCBhdHRhY2htZW50LCBhdHRhY2htZW50T3B0aW9ucywgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBhdHRhY2htZW50IHR5cGUnKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEJpbmRzIGEgZnJhbWVidWZmZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHByZXR0eSBtdWNoIHNvbGVseSBleGlzdHMgYmVjYXVzZSBJIHNwZW50IGhvdXJzXG4gKiB0cnlpbmcgdG8gZmlndXJlIG91dCB3aHkgc29tZXRoaW5nIEkgd3JvdGUgd2Fzbid0IHdvcmtpbmcgb25seVxuICogdG8gcmVhbGl6ZSBJIGZvcmdldCB0byBzZXQgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4gKiBNeSBob3BlIGlzIHRoaXMgZnVuY3Rpb24gd2lsbCBmaXggdGhhdC5cbiAqXG4gKiBJdCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHNvbWVGcmFtZWJ1ZmZlckluZm8uZnJhbWVidWZmZXIpO1xuICogICAgIGdsLnZpZXdwb3J0KDAsIDAsIHNvbWVGcmFtZWJ1ZmZlckluZm8ud2lkdGgsIHNvbWVGcmFtZWJ1ZmZlckluZm8uaGVpZ2h0KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5GcmFtZWJ1ZmZlckluZm98bnVsbH0gW2ZyYW1lYnVmZmVySW5mb10gYSBmcmFtZWJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfS5cbiAqICAgSWYgZmFsc3kgd2lsbCBiaW5kIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3RhcmdldF0gVGhlIHRhcmdldC4gSWYgbm90IHBhc3NlZCBgZ2wuRlJBTUVCVUZGRVJgIHdpbGwgYmUgdXNlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9mcmFtZWJ1ZmZlcnNcbiAqL1xuXG5mdW5jdGlvbiBiaW5kRnJhbWVidWZmZXJJbmZvKGdsLCBmcmFtZWJ1ZmZlckluZm8sIHRhcmdldCkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwgRlJBTUVCVUZGRVI7XG4gIGlmIChmcmFtZWJ1ZmZlckluZm8pIHtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmcmFtZWJ1ZmZlckluZm8uZnJhbWVidWZmZXIpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGZyYW1lYnVmZmVySW5mby53aWR0aCwgZnJhbWVidWZmZXJJbmZvLmhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgbnVsbCk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgfVxufVxuXG52YXIgZnJhbWVidWZmZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJpbmRGcmFtZWJ1ZmZlckluZm86IGJpbmRGcmFtZWJ1ZmZlckluZm8sXG4gIGNyZWF0ZUZyYW1lYnVmZmVySW5mbzogY3JlYXRlRnJhbWVidWZmZXJJbmZvLFxuICByZXNpemVGcmFtZWJ1ZmZlckluZm86IHJlc2l6ZUZyYW1lYnVmZmVySW5mb1xufSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiB2ZXJ0ZXggYXJyYXkgb2JqZWN0IHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogWW91IHNob3VsZCBnZW5lcmFsbHkgbm90IG5lZWQgdG8gdXNlIHRoZXNlIGZ1bmN0aW9ucy4gVGhleSBhcmUgcHJvdmlkZWRcbiAqIGZvciB0aG9zZSBjYXNlcyB3aGVyZSB5b3UncmUgZG9pbmcgc29tZXRoaW5nIG91dCBvZiB0aGUgb3JkaW5hcnlcbiAqIGFuZCB5b3UgbmVlZCBsb3dlciBsZXZlbCBhY2Nlc3MuXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wuYXR0cmlidXRlc2AgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL3ZlcnRleEFycmF5c1xuICovXG5cbmNvbnN0IEVMRU1FTlRfQVJSQVlfQlVGRkVSICAgICAgICAgICA9IDB4ODg5MztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWZXJ0ZXhBcnJheUluZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1FbGVtZW50cyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHBhc3MgdG8gYGdsLmRyYXdBcnJheXNgIG9yIGBnbC5kcmF3RWxlbWVudHNgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlbGVtZW50VHlwZV0gVGhlIHR5cGUgb2YgaW5kaWNlcyBgVU5TSUdORURfQllURWAsIGBVTlNJR05FRF9TSE9SVGAgZXRjLi5cbiAqIEBwcm9wZXJ0eSB7V2ViR0xWZXJ0ZXhBcnJheU9iamVjdH0gW3ZlcnRleEFycmF5T2JqZWN0XSBhIHZlcnRleCBhcnJheSBvYmplY3RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIFZlcnRleEFycmF5SW5mbyBmcm9tIGEgQnVmZmVySW5mbyBhbmQgb25lIG9yIG1vcmUgUHJvZ3JhbUluZm9zXG4gKlxuICogVGhpcyBjYW4gYmUgcGFzc2VkIHRvIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlc30gYW5kIHRvXG4gKiB7QGxpbmsgbW9kdWxlOnR3Z2w6ZHJhd0J1ZmZlckluZm99LlxuICpcbiAqID4gKipJTVBPUlRBTlQ6KiogVmVydGV4IEFycmF5IE9iamVjdHMgYXJlICoqbm90KiogYSBkaXJlY3QgYW5hbG9nIGZvciBhIEJ1ZmZlckluZm8uIFZlcnRleCBBcnJheSBPYmplY3RzXG4gKiAgIGFzc2lnbiBidWZmZXJzIHRvIHNwZWNpZmljIGF0dHJpYnV0ZXMgYXQgY3JlYXRpb24gdGltZS4gVGhhdCBtZWFucyB0aGV5IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBwcm9ncmFtc1xuICogICB3aG8ncyBhdHRyaWJ1dGVzIHVzZSB0aGUgc2FtZSBhdHRyaWJ1dGUgbG9jYXRpb25zIGZvciB0aGUgc2FtZSBwdXJwb3Nlcy5cbiAqXG4gKiA+IEJpbmQgeW91ciBhdHRyaWJ1dGUgbG9jYXRpb25zIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb31cbiAqICAgb3IgdXNlIFdlYkdMIDIncyBHTFNMIEVTIDMncyBgbGF5b3V0KGxvY2F0aW9uID0gPG51bT4pYCB0byBtYWtlIHN1cmUgbG9jYXRpb25zIG1hdGNoLlxuICpcbiAqIGFsc29cbiAqXG4gKiA+ICoqSU1QT1JUQU5UOioqIEFmdGVyIGNhbGxpbmcgdHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlIHdpdGggYSBCdWZmZXJJbmZvIHRoYXQgdXNlcyBhIFZlcnRleCBBcnJheSBPYmplY3RcbiAqICAgdGhhdCBWZXJ0ZXggQXJyYXkgT2JqZWN0IHdpbGwgYmUgYm91bmQuIFRoYXQgbWVhbnMgKipBTlkgTUFOSVBVTEFUSU9OIE9GIEVMRU1FTlRfQVJSQVlfQlVGRkVSIG9yIEFUVFJJQlVURVMqKlxuICogICB3aWxsIGFmZmVjdCB0aGUgVmVydGV4IEFycmF5IE9iamVjdCBzdGF0ZS5cbiAqXG4gKiA+IENhbGwgYGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKWAgdG8gZ2V0IGJhY2sgbWFuaXB1bGF0aW5nIHRoZSBnbG9iYWwgYXR0cmlidXRlcyBhbmQgRUxFTUVOVF9BUlJBWV9CVUZGRVIuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvW119IHByb2dyYW1JbmZvIGEgcHJvZ3JhbUluZm8gb3IgYXJyYXkgb2YgcHJvZ3JhbUluZm9zXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IGJ1ZmZlckluZm8gQnVmZmVySW5mbyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzIGV0Yy4uLlxuICpcbiAqICAgIFlvdSBuZWVkIHRvIG1ha2Ugc3VyZSBldmVyeSBhdHRyaWJ1dGUgdGhhdCB3aWxsIGJlIHVzZWQgaXMgYm91bmQuIFNvIGZvciBleGFtcGxlIGFzc3VtZSBzaGFkZXIgMVxuICogICAgdXNlcyBhdHRyaWJ1dGVzIEEsIEIsIEMgYW5kIHNoYWRlciAyIHVzZXMgYXR0cmlidXRlcyBBLCBCLCBELiBJZiB5b3Ugb25seSBwYXNzIGluIHRoZSBwcm9ncmFtSW5mb1xuICogICAgZm9yIHNoYWRlciAxIHRoZW4gb25seSBhdHRyaWJ1dGVzIEEsIEIsIGFuZCBDIHdpbGwgaGF2ZSB0aGVpciBhdHRyaWJ1dGVzIHNldCBiZWNhdXNlIFRXR0wgZG9lc24ndFxuICogICAgbm93IGF0dHJpYnV0ZSBEJ3MgbG9jYXRpb24uXG4gKlxuICogICAgU28sIHlvdSBjYW4gcGFzcyBpbiBib3RoIHNoYWRlciAxIGFuZCBzaGFkZXIgMidzIHByb2dyYW1JbmZvXG4gKlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVmVydGV4QXJyYXlJbmZvfSBUaGUgY3JlYXRlZCBWZXJ0ZXhBcnJheUluZm9cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdmVydGV4QXJyYXlzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleEFycmF5SW5mbyhnbCwgcHJvZ3JhbUluZm9zLCBidWZmZXJJbmZvKSB7XG4gIGNvbnN0IHZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICBpZiAoIXByb2dyYW1JbmZvcy5sZW5ndGgpIHtcbiAgICBwcm9ncmFtSW5mb3MgPSBbcHJvZ3JhbUluZm9zXTtcbiAgfVxuICBwcm9ncmFtSW5mb3MuZm9yRWFjaChmdW5jdGlvbihwcm9ncmFtSW5mbykge1xuICAgIHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gIH0pO1xuICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gIHJldHVybiB7XG4gICAgbnVtRWxlbWVudHM6IGJ1ZmZlckluZm8ubnVtRWxlbWVudHMsXG4gICAgZWxlbWVudFR5cGU6IGJ1ZmZlckluZm8uZWxlbWVudFR5cGUsXG4gICAgdmVydGV4QXJyYXlPYmplY3Q6IHZhbyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdmVydGV4IGFycmF5IG9iamVjdCBhbmQgdGhlbiBzZXRzIHRoZSBhdHRyaWJ1dGVzIG9uIGl0XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBzZXR0ZXJzIEF0dHJpYnV0ZSBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmlidXRlU2V0dGVyc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz59IGF0dHJpYnMgQXR0cmliSW5mb3MgbWFwcGVkIGJ5IGF0dHJpYnV0ZSBuYW1lLlxuICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gW2luZGljZXNdIGFuIG9wdGlvbmFsIEVMRU1FTlRfQVJSQVlfQlVGRkVSIG9mIGluZGljZXNcbiAqXG4gKiBAcmV0dXJuIHtXZWJHTFZlcnRleEFycmF5T2JqZWN0fG51bGx9IFRoZSBjcmVhdGVkIFdlYkdMVmVydGV4QXJyYXlPYmplY3RcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdmVydGV4QXJyYXlzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZBT0FuZFNldEF0dHJpYnV0ZXMoZ2wsIHNldHRlcnMsIGF0dHJpYnMsIGluZGljZXMpIHtcbiAgY29uc3QgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gIHNldEF0dHJpYnV0ZXMoc2V0dGVycywgYXR0cmlicyk7XG4gIGlmIChpbmRpY2VzKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihFTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlcyk7XG4gIH1cbiAgLy8gV2UgdW5iaW5kIHRoaXMgYmVjYXVzZSBvdGhlcndpc2UgYW55IGNoYW5nZSB0byBFTEVNRU5UX0FSUkFZX0JVRkZFUlxuICAvLyBsaWtlIHdoZW4gY3JlYXRpbmcgYnVmZmVycyBmb3Igb3RoZXIgc3R1ZmYgd2lsbCBtZXNzIHVwIHRoaXMgVkFPJ3MgYmluZGluZ1xuICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gIHJldHVybiB2YW87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHZlcnRleCBhcnJheSBvYmplY3QgYW5kIHRoZW4gc2V0cyB0aGUgYXR0cmlidXRlc1xuICogb24gaXRcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPnwgbW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm99IHByb2dyYW1JbmZvIGFzIHJldHVybmVkIGZyb20gY3JlYXRlUHJvZ3JhbUluZm8gb3IgQXR0cmlidXRlIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IGJ1ZmZlckluZm8gQnVmZmVySW5mbyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzIGV0Yy4uLlxuICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gW2luZGljZXNdIGFuIG9wdGlvbmFsIEVMRU1FTlRfQVJSQVlfQlVGRkVSIG9mIGluZGljZXNcbiAqXG4gKiBAcmV0dXJuIHtXZWJHTFZlcnRleEFycmF5T2JqZWN0fG51bGx9IFRoZSBjcmVhdGVkIFdlYkdMVmVydGV4QXJyYXlPYmplY3RcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdmVydGV4QXJyYXlzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZBT0Zyb21CdWZmZXJJbmZvKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbykge1xuICByZXR1cm4gY3JlYXRlVkFPQW5kU2V0QXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8uYXR0cmliU2V0dGVycyB8fCBwcm9ncmFtSW5mbywgYnVmZmVySW5mby5hdHRyaWJzLCBidWZmZXJJbmZvLmluZGljZXMpO1xufVxuXG52YXIgdmVydGV4QXJyYXlzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNyZWF0ZVZlcnRleEFycmF5SW5mbzogY3JlYXRlVmVydGV4QXJyYXlJbmZvLFxuICBjcmVhdGVWQU9BbmRTZXRBdHRyaWJ1dGVzOiBjcmVhdGVWQU9BbmRTZXRBdHRyaWJ1dGVzLFxuICBjcmVhdGVWQU9Gcm9tQnVmZmVySW5mbzogY3JlYXRlVkFPRnJvbUJ1ZmZlckluZm9cbn0pO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYWRkRXh0ZW5zaW9uc1RvQ29udGV4dDogdHJ1ZSxcbn07XG5cbi8qKlxuICogVmFyaW91cyBkZWZhdWx0IHNldHRpbmdzIGZvciB0d2dsLlxuICpcbiAqIE5vdGU6IFlvdSBjYW4gY2FsbCB0aGlzIGFueSBudW1iZXIgb2YgdGltZXMuIEV4YW1wbGU6XG4gKlxuICogICAgIHR3Z2wuc2V0RGVmYXVsdHMoeyB0ZXh0dXJlQ29sb3I6IFsxLCAwLCAwLCAxXSB9KTtcbiAqICAgICB0d2dsLnNldERlZmF1bHRzKHsgYXR0cmliUHJlZml4OiAnYV8nIH0pO1xuICpcbiAqIGlzIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiAgICAgdHdnbC5zZXREZWZhdWx0cyh7XG4gKiAgICAgICB0ZXh0dXJlQ29sb3I6IFsxLCAwLCAwLCAxXSxcbiAqICAgICAgIGF0dHJpYlByZWZpeDogJ2FfJyxcbiAqICAgICB9KTtcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJQcmVmaXhdIFRoZSBwcmVmaXggdG8gc3RpY2sgb24gYXR0cmlidXRlc1xuICpcbiAqICAgV2hlbiB3cml0aW5nIHNoYWRlcnMgSSBwcmVmZXIgdG8gbmFtZSBhdHRyaWJ1dGVzIHdpdGggYGFfYCwgdW5pZm9ybXMgd2l0aCBgdV9gIGFuZCB2YXJ5aW5ncyB3aXRoIGB2X2BcbiAqICAgYXMgaXQgbWFrZXMgaXQgY2xlYXIgd2hlcmUgdGhleSBjYW1lIGZyb20uIEJ1dCwgd2hlbiBidWlsZGluZyBnZW9tZXRyeSBJIHByZWZlciB1c2luZyB1bi1wcmVmaXhlZCBuYW1lcy5cbiAqXG4gKiAgIEluIG90aGVyIHdvcmRzIEknbGwgY3JlYXRlIGFycmF5cyBvZiBnZW9tZXRyeSBsaWtlIHRoaXNcbiAqXG4gKiAgICAgICBjb25zdCBhcnJheXMgPSB7XG4gKiAgICAgICAgIHBvc2l0aW9uOiAuLi5cbiAqICAgICAgICAgbm9ybWFsOiAuLi5cbiAqICAgICAgICAgdGV4Y29vcmQ6IC4uLlxuICogICAgICAgfTtcbiAqXG4gKiAgIEJ1dCBuZWVkIHRob3NlIG1hcHBlZCB0byBhdHRyaWJ1dGVzIGFuZCBteSBhdHRyaWJ1dGVzIHN0YXJ0IHdpdGggYGFfYC5cbiAqXG4gKiAgIERlZmF1bHQ6IGBcIlwiYFxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IFt0ZXh0dXJlQ29sb3JdIEFycmF5IG9mIDQgdmFsdWVzIGluIHRoZSByYW5nZSAwIHRvIDFcbiAqXG4gKiAgIFRoZSBkZWZhdWx0IHRleHR1cmUgY29sb3IgaXMgdXNlZCB3aGVuIGxvYWRpbmcgdGV4dHVyZXMgZnJvbVxuICogICB1cmxzLiBCZWNhdXNlIHRoZSBVUkwgd2lsbCBiZSBsb2FkZWQgYXN5bmMgd2UnZCBsaWtlIHRvIGJlXG4gKiAgIGFibGUgdG8gdXNlIHRoZSB0ZXh0dXJlIGltbWVkaWF0ZWx5LiBCeSBwdXR0aW5nIGEgMXgxIHBpeGVsXG4gKiAgIGNvbG9yIGluIHRoZSB0ZXh0dXJlIHdlIGNhbiBzdGFydCB1c2luZyB0aGUgdGV4dHVyZSBiZWZvcmVcbiAqICAgdGhlIFVSTCBoYXMgbG9hZGVkLlxuICpcbiAqICAgRGVmYXVsdDogYFswLjUsIDAuNzUsIDEsIDFdYFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3Jvc3NPcmlnaW5dXG4gKlxuICogICBJZiBub3QgdW5kZWZpbmVkIHNldHMgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBvbiBpbWFnZXNcbiAqICAgdGhhdCB0d2dsIGNyZWF0ZXMgd2hlbiBkb3dubG9hZGluZyBpbWFnZXMgZm9yIHRleHR1cmVzLlxuICpcbiAqICAgQWxzbyBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2x9IFthZGRFeHRlbnNpb25zVG9Db250ZXh0XVxuICpcbiAqICAgSWYgdHJ1ZSwgdGhlbiwgd2hlbiB0d2dsIHdpbGwgdHJ5IHRvIGFkZCBhbnkgc3VwcG9ydGVkIFdlYkdMIGV4dGVuc2lvbnNcbiAqICAgZGlyZWN0bHkgdG8gdGhlIGNvbnRleHQgdW5kZXIgdGhlaXIgbm9ybWFsIEdMIG5hbWVzLiBGb3IgZXhhbXBsZVxuICogICBpZiBBTkdMRV9pbnN0YW5jZXNfYXJyYXlzIGV4aXN0cyB0aGVuIHR3Z2wgd291bGQgZW5hYmxlIGl0LFxuICogICBhZGQgdGhlIGZ1bmN0aW9ucyBgdmVydGV4QXR0cmliRGl2aXNvcmAsIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCxcbiAqICAgYGRyYXdFbGVtZW50c0luc3RhbmNlZGAsIGFuZCB0aGUgY29uc3RhbnQgYFZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUmBcbiAqICAgdG8gdGhlIGBXZWJHTFJlbmRlcmluZ0NvbnRleHRgLlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogU2V0cyB2YXJpb3VzIGRlZmF1bHRzIGZvciB0d2dsLlxuICpcbiAqIEluIHRoZSBpbnRlcmVzdCBvZiB0ZXJzZW5lc3Mgd2hpY2ggaXMga2luZCBvZiB0aGUgcG9pbnRcbiAqIG9mIHR3Z2wgSSd2ZSBpbnRlZ3JhdGVkIGEgZmV3IG9mIHRoZSBvbGRlciBmdW5jdGlvbnMgaGVyZVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRGVmYXVsdHN9IG5ld0RlZmF1bHRzIFRoZSBkZWZhdWx0IHNldHRpbmdzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGNvcHlFeGlzdGluZ1Byb3BlcnRpZXMobmV3RGVmYXVsdHMsIGRlZmF1bHRzKTtcbiAgc2V0RGVmYXVsdHMkMihuZXdEZWZhdWx0cyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHNldERlZmF1bHRzJDEobmV3RGVmYXVsdHMpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufVxuXG5jb25zdCBwcmVmaXhSRSA9IC9eKC4qPylfLztcbmZ1bmN0aW9uIGFkZEV4dGVuc2lvblRvQ29udGV4dChnbCwgZXh0ZW5zaW9uTmFtZSkge1xuICBnbEVudW1Ub1N0cmluZyhnbCwgMCk7XG4gIGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcbiAgaWYgKGV4dCkge1xuICAgIGNvbnN0IGVudW1zID0ge307XG4gICAgY29uc3QgZm5TdWZmaXggPSBwcmVmaXhSRS5leGVjKGV4dGVuc2lvbk5hbWUpWzFdO1xuICAgIGNvbnN0IGVudW1TdWZmaXggPSAnXycgKyBmblN1ZmZpeDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBleHQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0W2tleV07XG4gICAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgKHZhbHVlKSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGNvbnN0IHN1ZmZpeCA9IGlzRnVuYyA/IGZuU3VmZml4IDogZW51bVN1ZmZpeDtcbiAgICAgIGxldCBuYW1lID0ga2V5O1xuICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hlcmUgdGhpcyBpcyBub3QgdHJ1ZSBhcmUgV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcbiAgICAgIC8vIGFuZCBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcbiAgICAgIGlmIChrZXkuZW5kc1dpdGgoc3VmZml4KSkge1xuICAgICAgICBuYW1lID0ga2V5LnN1YnN0cmluZygwLCBrZXkubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoZ2xbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlzRnVuYyAmJiBnbFtuYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB3YXJuJDEobmFtZSwgZ2xbbmFtZV0sIHZhbHVlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgZ2xbbmFtZV0gPSBmdW5jdGlvbihvcmlnRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdGbi5hcHBseShleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0odmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgZW51bXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBwYXNzIHRoZSBtb2RpZmllZCBlbnVtcyB0byBnbEVudW1Ub1N0cmluZ1xuICAgIGVudW1zLmNvbnN0cnVjdG9yID0ge1xuICAgICAgbmFtZTogZXh0LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgfTtcbiAgICBnbEVudW1Ub1N0cmluZyhlbnVtcywgMCk7XG4gIH1cbiAgcmV0dXJuIGV4dDtcbn1cblxuLypcbiAqIElmIHlvdSdyZSB3b25kZXJpbmcgd2h5IHRoZSBjb2RlIGRvZXNuJ3QganVzdCBpdGVyYXRlXG4gKiBvdmVyIGFsbCBleHRlbnNpb25zIHVzaW5nIGBnbC5nZXRFeHRlbnNpb25zYCBpcyB0aGF0IGl0J3MgcG9zc2libGVcbiAqIHNvbWUgZnV0dXJlIGV4dGVuc2lvbiBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGlzIGNvZGUuIFJhdGhlciB0aGFuXG4gKiBoYXZlIHRoaW5nIHN1ZGRlbmx5IGJyZWFrIGl0IHNlZW1zIGJldHRlciB0byBtYW51YWxseSBhZGQgdG8gdGhpc1xuICogbGlzdC5cbiAqXG4gKi9cbmNvbnN0IHN1cHBvcnRlZEV4dGVuc2lvbnMgPSBbXG4gICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyxcbiAgJ0VYVF9ibGVuZF9taW5tYXgnLFxuICAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcsXG4gICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnLFxuICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JyxcbiAgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInLFxuICAnRVhUX2ZyYWdfZGVwdGgnLFxuICAnRVhUX3NSR0InLFxuICAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcsXG4gICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnLFxuICAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcsXG4gICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnLFxuICAnT0VTX3RleHR1cmVfZmxvYXQnLFxuICAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyxcbiAgJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnLFxuICAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInLFxuICAnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLFxuICAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyxcbiAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGMnLFxuICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnLFxuICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyxcbiAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyxcbiAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InLFxuICAnV0VCR0xfZGVwdGhfdGV4dHVyZScsXG4gICdXRUJHTF9kcmF3X2J1ZmZlcnMnLFxuXTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmFibGUgYWxsIG9mIHRoZSBmb2xsb3dpbmcgZXh0ZW5zaW9uc1xuICogYW5kIGFkZCB0aGVpciBmdW5jdGlvbnMgYW5kIGNvbnN0YW50cyB0byB0aGVcbiAqIGBXZWJHTFJlbmRlcmluZ0NvbnRleHRgIHVzaW5nIHRoZWlyIG5vcm1hbCBub24tZXh0ZW5zaW9uIGxpa2UgbmFtZXMuXG4gKlxuICogICAgICBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXG4gKiAgICAgIEVYVF9ibGVuZF9taW5tYXhcbiAqICAgICAgRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFxuICogICAgICBFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcbiAqICAgICAgRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XG4gKiAgICAgIEVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcbiAqICAgICAgRVhUX2ZyYWdfZGVwdGhcbiAqICAgICAgRVhUX3NSR0JcbiAqICAgICAgRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxuICogICAgICBFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcbiAqICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludFxuICogICAgICBPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcbiAqICAgICAgT0VTX3RleHR1cmVfZmxvYXRcbiAqICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXG4gKiAgICAgIE9FU190ZXh0dXJlX2hhbGZfZmxvYXRcbiAqICAgICAgT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcbiAqICAgICAgT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcbiAqICAgICAgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGNcbiAqICAgICAgV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcbiAqICAgICAgV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2JcbiAqICAgICAgV0VCR0xfZGVwdGhfdGV4dHVyZVxuICogICAgICBXRUJHTF9kcmF3X2J1ZmZlcnNcbiAqXG4gKiBGb3IgZXhhbXBsZSBpZiBgQU5HTEVfaW5zdGFuY2VkX2FycmF5c2AgZXhpc3RzIHRoZW4gdGhlIGZ1bmN0aW9uc1xuICogYGRyYXdBcnJheXNJbnN0YW5jZWRgLCBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkYCwgYHZlcnRleEF0dHJpYkRpdmlzb3JgXG4gKiBhbmQgdGhlIGNvbnN0YW50IGBWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JgIGFyZSBhZGRlZCB0byB0aGVcbiAqIGBXZWJHTFJlbmRlcmluZ0NvbnRleHRgLlxuICpcbiAqIE5vdGUgdGhhdCBpZiB5b3Ugd2FudCB0byBrbm93IGlmIHRoZSBleHRlbnNpb24gZXhpc3RzIHlvdSBzaG91bGRcbiAqIHByb2JhYmx5IGNhbGwgYGdsLmdldEV4dGVuc2lvbmAgZm9yIGVhY2ggZXh0ZW5zaW9uLiBBbHRlcm5hdGl2ZWx5XG4gKiB5b3UgY2FuIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHRoZSBmdW5jdGlvbnMgb3IgY29uc3RhbnRzIHRoYXRcbiAqIGFyZSBleHBlY3RlZCB0byBiZSBhZGRlZC4gRm9yIGV4YW1wbGVcbiAqXG4gKiAgICBpZiAoZ2wuZHJhd0J1ZmZlcnMpIHtcbiAqICAgICAgLy8gRWl0aGVyIFdFQkdMX2RyYXdfYnVmZmVycyB3YXMgZW5hYmxlZCBPUiB5b3UncmUgcnVubmluZyBpbiBXZWJHTDJcbiAqICAgICAgLi4uLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoZ2wpIHtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHN1cHBvcnRlZEV4dGVuc2lvbnMubGVuZ3RoOyArK2lpKSB7XG4gICAgYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBzdXBwb3J0ZWRFeHRlbnNpb25zW2lpXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgd2ViZ2wgY29udGV4dC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBUaGUgY2FudmFzIHRhZyB0byBnZXRcbiAqICAgICBjb250ZXh0IGZyb20uIElmIG9uZSBpcyBub3QgcGFzc2VkIGluIG9uZSB3aWxsIGJlXG4gKiAgICAgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGNyZWF0ZWQgY29udGV4dC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gIGNvbnN0IG5hbWVzID0gW1wid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gIGxldCBjb250ZXh0ID0gbnVsbDtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG5hbWVzLmxlbmd0aDsgKytpaSkge1xuICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpaV0sIG9wdF9hdHRyaWJzKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaWYgKGRlZmF1bHRzLmFkZEV4dGVuc2lvbnNUb0NvbnRleHQpIHtcbiAgICAgICAgYWRkRXh0ZW5zaW9uc1RvQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBHZXRzIGEgV2ViR0wxIGNvbnRleHQuXG4gKlxuICogTm90ZTogV2lsbCBhdHRlbXB0IHRvIGVuYWJsZSBWZXJ0ZXggQXJyYXkgT2JqZWN0c1xuICogYW5kIGFkZCBXZWJHTDIgZW50cnkgcG9pbnRzLiAodW5sZXNzIHlvdSBmaXJzdCBzZXQgZGVmYXVsdHMgd2l0aFxuICogYHR3Z2wuc2V0RGVmYXVsdHMoe2VuYWJsZVZlcnRleEFycmF5T2JqZWN0czogZmFsc2V9KWA7XG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIGEgY2FudmFzIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dEF0dHJpYnV0ZXN9IFtvcHRfYXR0cmlic10gb3B0aW9uYWwgd2ViZ2wgY29udGV4dCBjcmVhdGlvbiBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqIEBkZXByZWNhdGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoY2FudmFzLCBvcHRfYXR0cmlicykge1xuICBjb25zdCBnbCA9IGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgcmV0dXJuIGdsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB3ZWJnbCBjb250ZXh0LlxuICpcbiAqIFdpbGwgcmV0dXJuIGEgV2ViR0wyIGNvbnRleHQgaWYgcG9zc2libGUuXG4gKlxuICogWW91IGNhbiBjaGVjayBpZiBpdCdzIFdlYkdMMiB3aXRoXG4gKlxuICogICAgIHR3Z2wuaXNXZWJHTDIoZ2wpO1xuICpcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBUaGUgY2FudmFzIHRhZyB0byBnZXRcbiAqICAgICBjb250ZXh0IGZyb20uIElmIG9uZSBpcyBub3QgcGFzc2VkIGluIG9uZSB3aWxsIGJlXG4gKiAgICAgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGNyZWF0ZWQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gIGNvbnN0IG5hbWVzID0gW1wid2ViZ2wyXCIsIFwid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gIGxldCBjb250ZXh0ID0gbnVsbDtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG5hbWVzLmxlbmd0aDsgKytpaSkge1xuICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpaV0sIG9wdF9hdHRyaWJzKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaWYgKGRlZmF1bHRzLmFkZEV4dGVuc2lvbnNUb0NvbnRleHQpIHtcbiAgICAgICAgYWRkRXh0ZW5zaW9uc1RvQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBHZXRzIGEgV2ViR0wgY29udGV4dC4gIFdpbGwgY3JlYXRlIGEgV2ViR0wyIGNvbnRleHQgaWYgcG9zc2libGUuXG4gKlxuICogWW91IGNhbiBjaGVjayBpZiBpdCdzIFdlYkdMMiB3aXRoXG4gKlxuICogICAgZnVuY3Rpb24gaXNXZWJHTDIoZ2wpIHtcbiAqICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5WRVJTSU9OKS5pbmRleE9mKFwiV2ViR0wgMi4wIFwiKSA9PSAwO1xuICogICAgfVxuICpcbiAqIE5vdGU6IEZvciBhIFdlYkdMMSBjb250ZXh0IHdpbGwgYXR0ZW1wdCB0byBlbmFibGUgVmVydGV4IEFycmF5IE9iamVjdHNcbiAqIGFuZCBhZGQgV2ViR0wyIGVudHJ5IHBvaW50cy4gKHVubGVzcyB5b3UgZmlyc3Qgc2V0IGRlZmF1bHRzIHdpdGhcbiAqIGB0d2dsLnNldERlZmF1bHRzKHtlbmFibGVWZXJ0ZXhBcnJheU9iamVjdHM6IGZhbHNlfSlgO1xuICpcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBhIGNhbnZhcyBlbGVtZW50LlxuICogQHBhcmFtIHtXZWJHTENvbnRleHRBdHRyaWJ1dGVzfSBbb3B0X2F0dHJpYnNdIG9wdGlvbmFsIHdlYmdsIGNvbnRleHQgY3JlYXRpb24gYXR0cmlidXRlc1xuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3JlYXRlZCBjb250ZXh0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRleHQoY2FudmFzLCBvcHRfYXR0cmlicykge1xuICBjb25zdCBnbCA9IGNyZWF0ZUNvbnRleHQoY2FudmFzLCBvcHRfYXR0cmlicyk7XG4gIHJldHVybiBnbDtcbn1cblxuLyoqXG4gKiBSZXNpemUgYSBjYW52YXMgdG8gbWF0Y2ggdGhlIHNpemUgaXQncyBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgVGhlIGNhbnZhcyB0byByZXNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gW211bHRpcGxpZXJdIFNvIHlvdSBjYW4gcGFzcyBpbiBgd2luZG93LmRldmljZVBpeGVsUmF0aW9gIG9yIG90aGVyIHNjYWxlIHZhbHVlIGlmIHlvdSB3YW50IHRvLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIHdhcyByZXNpemVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhc1RvRGlzcGxheVNpemUoY2FudmFzLCBtdWx0aXBsaWVyKSB7XG4gIG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyIHx8IDE7XG4gIG11bHRpcGxpZXIgPSBNYXRoLm1heCgwLCBtdWx0aXBsaWVyKTtcbiAgY29uc3Qgd2lkdGggID0gY2FudmFzLmNsaWVudFdpZHRoICAqIG11bHRpcGxpZXIgfCAwO1xuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0ICogbXVsdGlwbGllciB8IDA7XG4gIGlmIChjYW52YXMud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBhZGRFeHRlbnNpb25zVG9Db250ZXh0LCBhdHRyaWJ1dGVzLCBiaW5kRnJhbWVidWZmZXJJbmZvLCBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvLCBiaW5kVW5pZm9ybUJsb2NrLCBjYW5GaWx0ZXIsIGNhbkdlbmVyYXRlTWlwbWFwLCBjcmVhdGVBdHRyaWJzRnJvbUFycmF5cywgY3JlYXRlQXR0cmlidXRlU2V0dGVycywgY3JlYXRlQnVmZmVyRnJvbUFycmF5LCBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheSwgY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMsIGNyZWF0ZUJ1ZmZlcnNGcm9tQXJyYXlzLCBjcmVhdGVGcmFtZWJ1ZmZlckluZm8sIGNyZWF0ZVByb2dyYW0sIGNyZWF0ZVByb2dyYW1Bc3luYywgY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzLCBjcmVhdGVQcm9ncmFtRnJvbVNvdXJjZXMsIGNyZWF0ZVByb2dyYW1JbmZvLCBjcmVhdGVQcm9ncmFtSW5mb0FzeW5jLCBjcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtLCBjcmVhdGVQcm9ncmFtSW5mb3MsIGNyZWF0ZVByb2dyYW1JbmZvc0FzeW5jLCBjcmVhdGVQcm9ncmFtcywgY3JlYXRlUHJvZ3JhbXNBc3luYywgY3JlYXRlU2FtcGxlciwgY3JlYXRlU2FtcGxlcnMsIGNyZWF0ZVRleHR1cmUsIGNyZWF0ZVRleHR1cmVzLCBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaywgY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2tJbmZvLCBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvLCBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0sIGNyZWF0ZVVuaWZvcm1CbG9ja1NwZWNGcm9tUHJvZ3JhbSwgY3JlYXRlVW5pZm9ybVNldHRlcnMsIGNyZWF0ZVZBT0FuZFNldEF0dHJpYnV0ZXMsIGNyZWF0ZVZBT0Zyb21CdWZmZXJJbmZvLCBjcmVhdGVWZXJ0ZXhBcnJheUluZm8sIGRyYXcsIGRyYXdCdWZmZXJJbmZvLCBkcmF3T2JqZWN0TGlzdCwgZnJhbWVidWZmZXJzLCBnZXRBcnJheSQxIGFzIGdldEFycmF5XywgZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQsIGdldENvbnRleHQsIGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdCwgZ2V0R0xUeXBlRm9yVHlwZWRBcnJheSwgZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUsIGdldE51bUNvbXBvbmVudHNGb3JGb3JtYXQsIGdldE51bUNvbXBvbmVudHMkMSBhcyBnZXROdW1Db21wb25lbnRzXywgZ2V0VHlwZWRBcnJheVR5cGVGb3JHTFR5cGUsIGdldFdlYkdMQ29udGV4dCwgZ2xFbnVtVG9TdHJpbmcsIGlzQXJyYXlCdWZmZXIkMSBhcyBpc0FycmF5QnVmZmVyLCBpc1dlYkdMMSwgaXNXZWJHTDIsIGxvYWRUZXh0dXJlRnJvbVVybCwgbTQsIHByaW1pdGl2ZXMsIHByb2dyYW1zLCByZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplLCByZXNpemVGcmFtZWJ1ZmZlckluZm8sIHJlc2l6ZVRleHR1cmUsIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXksIHNldERlZmF1bHRzJDIgYXMgc2V0QXR0cmlidXRlRGVmYXVsdHNfLCBzZXRBdHRyaWJ1dGVQcmVmaXgsIHNldEF0dHJpYnV0ZXMsIHNldEJsb2NrVW5pZm9ybXMsIHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzLCBzZXREZWZhdWx0VGV4dHVyZUNvbG9yLCBzZXREZWZhdWx0cywgc2V0RW1wdHlUZXh0dXJlLCBzZXRTYW1wbGVyUGFyYW1ldGVycywgc2V0RGVmYXVsdHMkMSBhcyBzZXRUZXh0dXJlRGVmYXVsdHNfLCBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZSwgc2V0VGV4dHVyZUZyb21BcnJheSwgc2V0VGV4dHVyZUZyb21FbGVtZW50LCBzZXRUZXh0dXJlUGFyYW1ldGVycywgc2V0VW5pZm9ybUJsb2NrLCBzZXRVbmlmb3Jtcywgc2V0VW5pZm9ybXNBbmRCaW5kVGV4dHVyZXMsIHRleHR1cmVzLCB0eXBlZGFycmF5cywgdXRpbHMsIHYzLCB2ZXJ0ZXhBcnJheXMgfTtcbiIsImltcG9ydCBTaGFkZXJTa2V0Y2hCYXNlIGZyb20gJy4vU2hhZGVyU2tldGNoQmFzZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeGFtcGxlU2hhZGVyU2tldGNoIGV4dGVuZHMgU2hhZGVyU2tldGNoQmFzZSB7XHJcbiAgY29uc3RydWN0b3IoY2FudmFzLCBmcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyKSB7XHJcbiAgICBzdXBlcihjYW52YXMsIGZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKHRpbWUpIHtcclxuICAgIHN1cGVyLnVwZGF0ZSh0aW1lKTtcclxuICB9XHJcbn0iLCIvKipcclxuICogUmVwcmVzZW50cyBhIGJhc2UgY2xhc3MgZm9yIHNoYWRlciBza2V0Y2hlcy5cclxuICogQGNsYXNzXHJcbiAqL1xyXG5pbXBvcnQgeyBcclxuICBjcmVhdGVQcm9ncmFtSW5mbywgXHJcbiAgY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMsIFxyXG4gIHJlc2l6ZUNhbnZhc1RvRGlzcGxheVNpemUsXHJcbiAgc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMsXHJcbiAgc2V0VW5pZm9ybXMsXHJcbiAgZHJhd0J1ZmZlckluZm9cclxufSBmcm9tIFwidHdnbC5qc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyU2tldGNoQmFzZSB7XHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiBTaGFkZXJTa2V0Y2hCYXNlLiBOb3QgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGRpcmVjdGx5LCBhbmQgaW5zdGVhZCB1c2VkIGFzIGEgYmFzZSBjbGFzcy5cclxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGVsZW1lbnQgdG8gcmVuZGVyIHRoZSBzaGFkZXIgc2tldGNoLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcmFnbWVudFNoYWRlciAtIFRoZSBmcmFnbWVudCBzaGFkZXIgY29kZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGV4U2hhZGVyIC0gVGhlIHZlcnRleCBzaGFkZXIgY29kZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihjYW52YXMsIGZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXIpIHtcclxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xyXG4gICAgdGhpcy5nbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcclxuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcclxuICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xyXG4gICAgdGhpcy5hbmltYXRpb25GcmFtZUlkID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnByb2dyYW1JbmZvID0gY3JlYXRlUHJvZ3JhbUluZm8odGhpcy5nbCwgW3RoaXMudmVydGV4U2hhZGVyLCB0aGlzLmZyYWdtZW50U2hhZGVyXSk7XHJcbiAgICB0aGlzLmJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyh0aGlzLmdsLCB7XHJcbiAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgbnVtQ29tcG9uZW50czogMixcclxuICAgICAgICBkYXRhOiBbXHJcbiAgICAgICAgICAtMSwgLTEsXHJcbiAgICAgICAgICAxLCAtMSxcclxuICAgICAgICAgIC0xLCAgMSxcclxuICAgICAgICAgIC0xLCAgMSxcclxuICAgICAgICAgIDEsIC0xLFxyXG4gICAgICAgICAgMSwgIDEsXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudW5pZm9ybXMgPSB7XHJcbiAgICAgIHVfdGltZTogMCxcclxuICAgICAgdV9yZXNvbHV0aW9uOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF0sXHJcbiAgICAgIHVfbW91c2U6IFswLCAwXSxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgdGhpcy51bmlmb3Jtcy51X21vdXNlID0gdGhpcy5nZXROb3JtYWxpemVkTW91c2VQb3NpdGlvbihldmVudCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyB0aGUgc2hhZGVyIHNrZXRjaC4gVXNlZCB0aHJvdWdoIHJlcXVlc3RBbmltYXRpb25GcmFtZSBsb29waW5nLlxyXG4gICAqIFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBUaGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cclxuICAgKi9cclxuICByZW5kZXIodGltZSkge1xyXG4gICAgcmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZSh0aGlzLmNhbnZhcyk7XHJcbiAgICB0aGlzLnVwZGF0ZSh0aW1lKTtcclxuXHJcbiAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbUluZm8ucHJvZ3JhbSk7XHJcbiAgICBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcyh0aGlzLmdsLCB0aGlzLnByb2dyYW1JbmZvLCB0aGlzLmJ1ZmZlckluZm8pO1xyXG4gICAgc2V0VW5pZm9ybXModGhpcy5wcm9ncmFtSW5mbywgdGhpcy51bmlmb3Jtcyk7XHJcbiAgICBkcmF3QnVmZmVySW5mbyh0aGlzLmdsLCB0aGlzLmJ1ZmZlckluZm8pO1xyXG5cclxuICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHNoYWRlciBza2V0Y2ggYmFzZS4gSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLiBcclxuICAgKiBDYWxsIHN1cGVyLnVwZGF0ZSh0aW1lKSB0byB1cGRhdGUgdGhlIGRlZmF1bHQgdW5pZm9ybXMuIENhbGxlZCBiZWZvcmUgdGhlIHNrZXRjaCBpcyByZW5kZXJlZC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIFRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAqL1xyXG4gIHVwZGF0ZSh0aW1lKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMudW5pZm9ybXMsIHtcclxuICAgICAgdV90aW1lOiB0aW1lICogMC4wMDEsXHJcbiAgICAgIHVfcmVzb2x1dGlvbjogW3RoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHRdLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgdGhlIHJlbmRlcmluZyBwcm9jZXNzIGJ5IHJlcXVlc3RpbmcgYW4gYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAqL1xyXG4gIHN0YXJ0KCkge1xyXG4gICAgdGhpcy5hbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcHMgdGhlIGFuaW1hdGlvbiBmcmFtZS5cclxuICAgKi9cclxuICBzdG9wKCkge1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUlkKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBtb3VzZSBwb3NpdGlvbiBub3JtYWxpemVkIHRvIGEgcmFuZ2Ugb2YgWzAsIDFdLiBJbnRlbmRlZCB0byBiZSB1c2VkIGluIHRoZSBtb3VzZW1vdmUgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICogXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIG1vdXNlIGV2ZW50IG9iamVjdC5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IC0gVGhlIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gYXMgYW4gYXJyYXkgb2YgdHdvIHZhbHVlcy5cclxuICAgKi9cclxuICBnZXROb3JtYWxpemVkTW91c2VQb3NpdGlvbihldmVudCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgZXZlbnQub2Zmc2V0WCAvIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoLFxyXG4gICAgICBldmVudC5vZmZzZXRZIC8gdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0LFxyXG4gICAgXTtcclxuICB9XHJcbn0iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IEV4YW1wbGVTaGFkZXJTa2V0Y2ggZnJvbSBcIi4vRXhhbXBsZVNoYWRlclNrZXRjaFwiO1xyXG5pbXBvcnQgZnJhZ21lbnRTaGFkZXIgZnJvbSBcIi4vc2hhZGVycy9mcmFnLmdsc2xcIjtcclxuaW1wb3J0IHZlcnRleFNoYWRlciBmcm9tIFwiLi9zaGFkZXJzL3ZlcnQuZ2xzbFwiO1xyXG5cclxuY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjYW52YXNcIik7XHJcbmNvbnN0IHNrZXRjaCA9IG5ldyBFeGFtcGxlU2hhZGVyU2tldGNoKGNhbnZhcywgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcik7XHJcbnNrZXRjaC5zdGFydCgpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=